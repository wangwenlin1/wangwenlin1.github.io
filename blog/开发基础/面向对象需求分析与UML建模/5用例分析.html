<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>用例分析 | 一名GO+PHP工程师</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b3aba94c.css" as="style"><link rel="preload" href="/blog/assets/js/app.5a38db11.js" as="script"><link rel="preload" href="/blog/assets/js/3.21e2e031.js" as="script"><link rel="preload" href="/blog/assets/js/5.0760b076.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.cc3bb372.js"><link rel="prefetch" href="/blog/assets/js/100.35b5db36.js"><link rel="prefetch" href="/blog/assets/js/101.a70b97e2.js"><link rel="prefetch" href="/blog/assets/js/102.30af4d63.js"><link rel="prefetch" href="/blog/assets/js/103.c5c5130e.js"><link rel="prefetch" href="/blog/assets/js/104.161b590d.js"><link rel="prefetch" href="/blog/assets/js/105.eaae1ece.js"><link rel="prefetch" href="/blog/assets/js/106.028ce766.js"><link rel="prefetch" href="/blog/assets/js/107.c9b230ac.js"><link rel="prefetch" href="/blog/assets/js/108.a5880443.js"><link rel="prefetch" href="/blog/assets/js/109.bab44539.js"><link rel="prefetch" href="/blog/assets/js/11.ef5dbacc.js"><link rel="prefetch" href="/blog/assets/js/110.7ba602f1.js"><link rel="prefetch" href="/blog/assets/js/111.2b0b0a78.js"><link rel="prefetch" href="/blog/assets/js/112.6b9220f5.js"><link rel="prefetch" href="/blog/assets/js/113.6a2724aa.js"><link rel="prefetch" href="/blog/assets/js/114.ac347ea2.js"><link rel="prefetch" href="/blog/assets/js/115.17c6c526.js"><link rel="prefetch" href="/blog/assets/js/116.1fd8cdf3.js"><link rel="prefetch" href="/blog/assets/js/117.193b54e8.js"><link rel="prefetch" href="/blog/assets/js/118.8a3e18a9.js"><link rel="prefetch" href="/blog/assets/js/119.2a5bb73a.js"><link rel="prefetch" href="/blog/assets/js/12.2003a6c5.js"><link rel="prefetch" href="/blog/assets/js/120.edb5435e.js"><link rel="prefetch" href="/blog/assets/js/121.6e61cfa4.js"><link rel="prefetch" href="/blog/assets/js/122.8ce24886.js"><link rel="prefetch" href="/blog/assets/js/123.beccf42c.js"><link rel="prefetch" href="/blog/assets/js/124.416ddc09.js"><link rel="prefetch" href="/blog/assets/js/125.7be39e4f.js"><link rel="prefetch" href="/blog/assets/js/126.49439b56.js"><link rel="prefetch" href="/blog/assets/js/127.7d06eb7f.js"><link rel="prefetch" href="/blog/assets/js/128.9b247099.js"><link rel="prefetch" href="/blog/assets/js/129.6503c09f.js"><link rel="prefetch" href="/blog/assets/js/13.93951a43.js"><link rel="prefetch" href="/blog/assets/js/130.3fa988b7.js"><link rel="prefetch" href="/blog/assets/js/131.f93ef260.js"><link rel="prefetch" href="/blog/assets/js/132.7dca0041.js"><link rel="prefetch" href="/blog/assets/js/133.286b95ad.js"><link rel="prefetch" href="/blog/assets/js/134.88627057.js"><link rel="prefetch" href="/blog/assets/js/135.a28b714b.js"><link rel="prefetch" href="/blog/assets/js/136.fba0a306.js"><link rel="prefetch" href="/blog/assets/js/137.5540419d.js"><link rel="prefetch" href="/blog/assets/js/138.82fb7775.js"><link rel="prefetch" href="/blog/assets/js/139.787b1320.js"><link rel="prefetch" href="/blog/assets/js/14.379e0027.js"><link rel="prefetch" href="/blog/assets/js/140.b68497e2.js"><link rel="prefetch" href="/blog/assets/js/141.cd76190b.js"><link rel="prefetch" href="/blog/assets/js/142.8e56d4f0.js"><link rel="prefetch" href="/blog/assets/js/143.23971a8d.js"><link rel="prefetch" href="/blog/assets/js/144.8c41b407.js"><link rel="prefetch" href="/blog/assets/js/145.95b58ec4.js"><link rel="prefetch" href="/blog/assets/js/146.18132cf9.js"><link rel="prefetch" href="/blog/assets/js/147.8275026a.js"><link rel="prefetch" href="/blog/assets/js/148.cc2257d6.js"><link rel="prefetch" href="/blog/assets/js/149.a98d647c.js"><link rel="prefetch" href="/blog/assets/js/15.5376294f.js"><link rel="prefetch" href="/blog/assets/js/150.7360f0a5.js"><link rel="prefetch" href="/blog/assets/js/151.0cf39bd7.js"><link rel="prefetch" href="/blog/assets/js/152.6f7d01ad.js"><link rel="prefetch" href="/blog/assets/js/153.f6075040.js"><link rel="prefetch" href="/blog/assets/js/154.12eeb9b2.js"><link rel="prefetch" href="/blog/assets/js/155.65f03a29.js"><link rel="prefetch" href="/blog/assets/js/156.d2f6d50d.js"><link rel="prefetch" href="/blog/assets/js/157.f4384a9b.js"><link rel="prefetch" href="/blog/assets/js/158.34747ec7.js"><link rel="prefetch" href="/blog/assets/js/159.410bff01.js"><link rel="prefetch" href="/blog/assets/js/16.abdf559d.js"><link rel="prefetch" href="/blog/assets/js/160.53124933.js"><link rel="prefetch" href="/blog/assets/js/161.0ab0763e.js"><link rel="prefetch" href="/blog/assets/js/162.39021ec7.js"><link rel="prefetch" href="/blog/assets/js/163.596b82cf.js"><link rel="prefetch" href="/blog/assets/js/164.cbd2db78.js"><link rel="prefetch" href="/blog/assets/js/165.6e6c3d3a.js"><link rel="prefetch" href="/blog/assets/js/166.5bcaa3dd.js"><link rel="prefetch" href="/blog/assets/js/167.b4296d08.js"><link rel="prefetch" href="/blog/assets/js/168.27dc81ce.js"><link rel="prefetch" href="/blog/assets/js/169.661c763c.js"><link rel="prefetch" href="/blog/assets/js/17.8b47c823.js"><link rel="prefetch" href="/blog/assets/js/170.e41001f5.js"><link rel="prefetch" href="/blog/assets/js/171.0724bbd4.js"><link rel="prefetch" href="/blog/assets/js/172.2d5b541f.js"><link rel="prefetch" href="/blog/assets/js/173.41d6e737.js"><link rel="prefetch" href="/blog/assets/js/174.bccb9fa6.js"><link rel="prefetch" href="/blog/assets/js/175.b1a13486.js"><link rel="prefetch" href="/blog/assets/js/176.6e26a58e.js"><link rel="prefetch" href="/blog/assets/js/177.67fa30a9.js"><link rel="prefetch" href="/blog/assets/js/178.7f4bf5e6.js"><link rel="prefetch" href="/blog/assets/js/18.6a619898.js"><link rel="prefetch" href="/blog/assets/js/19.ea80b1e1.js"><link rel="prefetch" href="/blog/assets/js/2.04feeb4a.js"><link rel="prefetch" href="/blog/assets/js/20.77762601.js"><link rel="prefetch" href="/blog/assets/js/21.656ab41e.js"><link rel="prefetch" href="/blog/assets/js/22.5922a16f.js"><link rel="prefetch" href="/blog/assets/js/23.41929ef9.js"><link rel="prefetch" href="/blog/assets/js/24.3b850e15.js"><link rel="prefetch" href="/blog/assets/js/25.aade9e50.js"><link rel="prefetch" href="/blog/assets/js/26.36c6a527.js"><link rel="prefetch" href="/blog/assets/js/27.907a8228.js"><link rel="prefetch" href="/blog/assets/js/28.cc2bee0d.js"><link rel="prefetch" href="/blog/assets/js/29.52c7bfa4.js"><link rel="prefetch" href="/blog/assets/js/30.f034dd77.js"><link rel="prefetch" href="/blog/assets/js/31.edcef4fa.js"><link rel="prefetch" href="/blog/assets/js/32.6735d3e7.js"><link rel="prefetch" href="/blog/assets/js/33.28f8dc69.js"><link rel="prefetch" href="/blog/assets/js/34.8a729d66.js"><link rel="prefetch" href="/blog/assets/js/35.920cdf75.js"><link rel="prefetch" href="/blog/assets/js/36.15f2a36b.js"><link rel="prefetch" href="/blog/assets/js/37.5b03bd21.js"><link rel="prefetch" href="/blog/assets/js/38.fed1555d.js"><link rel="prefetch" href="/blog/assets/js/39.68d965cd.js"><link rel="prefetch" href="/blog/assets/js/4.644e7959.js"><link rel="prefetch" href="/blog/assets/js/40.069924f4.js"><link rel="prefetch" href="/blog/assets/js/41.a44d976c.js"><link rel="prefetch" href="/blog/assets/js/42.47caadd3.js"><link rel="prefetch" href="/blog/assets/js/43.b1eb7b31.js"><link rel="prefetch" href="/blog/assets/js/44.96773f8a.js"><link rel="prefetch" href="/blog/assets/js/45.328fda2a.js"><link rel="prefetch" href="/blog/assets/js/46.24f71020.js"><link rel="prefetch" href="/blog/assets/js/47.96df34c4.js"><link rel="prefetch" href="/blog/assets/js/48.b0bfea08.js"><link rel="prefetch" href="/blog/assets/js/49.3dac2a21.js"><link rel="prefetch" href="/blog/assets/js/50.97f9d2b0.js"><link rel="prefetch" href="/blog/assets/js/51.29fb5c68.js"><link rel="prefetch" href="/blog/assets/js/52.d2042f8d.js"><link rel="prefetch" href="/blog/assets/js/53.02c82b26.js"><link rel="prefetch" href="/blog/assets/js/54.667f483f.js"><link rel="prefetch" href="/blog/assets/js/55.b6b1e0e7.js"><link rel="prefetch" href="/blog/assets/js/56.bd954c20.js"><link rel="prefetch" href="/blog/assets/js/57.45722d8c.js"><link rel="prefetch" href="/blog/assets/js/58.17cd106d.js"><link rel="prefetch" href="/blog/assets/js/59.51661424.js"><link rel="prefetch" href="/blog/assets/js/6.d309aec3.js"><link rel="prefetch" href="/blog/assets/js/60.18a9a452.js"><link rel="prefetch" href="/blog/assets/js/61.819ab903.js"><link rel="prefetch" href="/blog/assets/js/62.24bf6999.js"><link rel="prefetch" href="/blog/assets/js/63.2f87f55d.js"><link rel="prefetch" href="/blog/assets/js/64.68cd3b45.js"><link rel="prefetch" href="/blog/assets/js/65.7fe0d182.js"><link rel="prefetch" href="/blog/assets/js/66.948be4c4.js"><link rel="prefetch" href="/blog/assets/js/67.2522194c.js"><link rel="prefetch" href="/blog/assets/js/68.0a66e8af.js"><link rel="prefetch" href="/blog/assets/js/69.07a744c4.js"><link rel="prefetch" href="/blog/assets/js/7.073a2745.js"><link rel="prefetch" href="/blog/assets/js/70.c0e92ba6.js"><link rel="prefetch" href="/blog/assets/js/71.97a4d551.js"><link rel="prefetch" href="/blog/assets/js/72.78fc6941.js"><link rel="prefetch" href="/blog/assets/js/73.3e3efdc5.js"><link rel="prefetch" href="/blog/assets/js/74.cff95a30.js"><link rel="prefetch" href="/blog/assets/js/75.6c4af1f1.js"><link rel="prefetch" href="/blog/assets/js/76.96c205c1.js"><link rel="prefetch" href="/blog/assets/js/77.31c8dd27.js"><link rel="prefetch" href="/blog/assets/js/78.41729cec.js"><link rel="prefetch" href="/blog/assets/js/79.12735350.js"><link rel="prefetch" href="/blog/assets/js/8.5e05a8d5.js"><link rel="prefetch" href="/blog/assets/js/80.e5005d72.js"><link rel="prefetch" href="/blog/assets/js/81.04f50a1e.js"><link rel="prefetch" href="/blog/assets/js/82.db879ca5.js"><link rel="prefetch" href="/blog/assets/js/83.e89b8863.js"><link rel="prefetch" href="/blog/assets/js/84.07410b58.js"><link rel="prefetch" href="/blog/assets/js/85.d46c8682.js"><link rel="prefetch" href="/blog/assets/js/86.3869d59e.js"><link rel="prefetch" href="/blog/assets/js/87.e7860b15.js"><link rel="prefetch" href="/blog/assets/js/88.2b183553.js"><link rel="prefetch" href="/blog/assets/js/89.36e67a82.js"><link rel="prefetch" href="/blog/assets/js/9.8a6a0670.js"><link rel="prefetch" href="/blog/assets/js/90.acd5023c.js"><link rel="prefetch" href="/blog/assets/js/91.d1662d38.js"><link rel="prefetch" href="/blog/assets/js/92.4093acc4.js"><link rel="prefetch" href="/blog/assets/js/93.f09d7ba1.js"><link rel="prefetch" href="/blog/assets/js/94.1e2891fe.js"><link rel="prefetch" href="/blog/assets/js/95.83afadb6.js"><link rel="prefetch" href="/blog/assets/js/96.85084d66.js"><link rel="prefetch" href="/blog/assets/js/97.16a7a60a.js"><link rel="prefetch" href="/blog/assets/js/98.a84fee2e.js"><link rel="prefetch" href="/blog/assets/js/99.f9452cba.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b3aba94c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">一名GO+PHP工程师</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/面向对象需求分析与UML建模/2可视化建模技术" class="sidebar-heading clickable open"><span>面向对象需求分析与UML建模</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/面向对象需求分析与UML建模/2可视化建模技术.html" class="sidebar-link">UML 2概念模型</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/3业务建模.html" class="sidebar-link">业务建模</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/4用例建模.html" class="sidebar-link">用例建模</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html" class="active sidebar-link">用例分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#本章目标" class="sidebar-link">本章目标</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#主要内容" class="sidebar-link">主要内容</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#理解分析" class="sidebar-link">理解分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#从需求到分析" class="sidebar-link">从需求到分析</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#分析模型" class="sidebar-link">分析模型</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#分析的基本原则" class="sidebar-link">分析的基本原则</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#从用例开始分析" class="sidebar-link">从用例开始分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#用例驱动的迭代开发" class="sidebar-link">用例驱动的迭代开发</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#用例实现" class="sidebar-link">用例实现</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#建模指南" class="sidebar-link">建模指南</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#架构分析" class="sidebar-link">架构分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#备选架构" class="sidebar-link">备选架构</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#分析机制" class="sidebar-link">分析机制</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#关键抽象" class="sidebar-link">关键抽象</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#完善用例文档" class="sidebar-link">完善用例文档</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#识别分析类" class="sidebar-link">识别分析类</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#识别分析类实践" class="sidebar-link">识别分析类实践</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#分析交互" class="sidebar-link">分析交互</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#完成参与类类图" class="sidebar-link">完成参与类类图</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#处理用例间的关系" class="sidebar-link">处理用例间的关系</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#总结-构造用例实现" class="sidebar-link">总结：构造用例实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#定义分析类" class="sidebar-link">定义分析类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#定义职责" class="sidebar-link">定义职责</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#定义属性" class="sidebar-link">定义属性</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#定义关系" class="sidebar-link">定义关系</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#限定分析机制" class="sidebar-link">限定分析机制</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#统一分析类" class="sidebar-link">统一分析类</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#练习" class="sidebar-link">练习</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#选择题" class="sidebar-link">选择题</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#简答题" class="sidebar-link">简答题</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/面向对象需求分析与UML建模/5用例分析.html#应用题" class="sidebar-link">应用题</a></li></ul></li></ul></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/6面向对象的设计原则.html" class="sidebar-link">面向对象的设计原则</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/7面向对象的设计模式.html" class="sidebar-link">面向对象的设计模式</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/8架构设计.html" class="sidebar-link">架构设计</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/9构件设计.html" class="sidebar-link">构件设计</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/Mermaid实战.html" class="sidebar-link">Mermaid实战</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/UML建模图实战笔记.html" class="sidebar-link">UML建模图实战笔记</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/面向对象需求分析与UML建模/PlantUML实战/时序图" class="sidebar-heading clickable"><span>PlantUML实战</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/面向对象需求分析与UML建模/PlantUML实战/时序图.html" class="sidebar-link">时序图</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/PlantUML实战/用例图.html" class="sidebar-link">用例图</a></li><li><a href="/blog/开发基础/面向对象需求分析与UML建模/PlantUML实战/类图.html" class="sidebar-link">类图</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="用例分析"><a href="#用例分析" class="header-anchor">#</a> 用例分析</h1> <h2 id="本章目标"><a href="#本章目标" class="header-anchor">#</a> 本章目标</h2> <p>分析的目标是定义为了满足需求模型中所描述的功能，系统内部应该有什么样的业务核心机制。<br>
了解分析的基础概念，掌握利用用例分析方法进行面向对象分析的基本过程和实践技能，并能够动手完成某一给定系统的分析模型的创建工作。</p> <h2 id="主要内容"><a href="#主要内容" class="header-anchor">#</a> 主要内容</h2> <ul><li><p>了解分析和分析模型的基本概念。</p></li> <li><p>掌握从用例模型开始的迭代开发方法。</p></li> <li><p>了解架构分析的基本内容。</p></li> <li><p>掌握利用顺序图构造用例实现的基本方法和技能。</p></li> <li><p>掌握定义分析类图的细节。</p></li></ul> <h2 id="理解分析"><a href="#理解分析" class="header-anchor">#</a> 理解分析</h2> <p>分析阶段，则需要以开发团队的角度描述系统为了实现用户目标应该提供哪些核心业务元素和关系。<br>
在面向对象的方法中，这些业务核心机制表现为相应的对象（类）及它们的静态和动态关系。</p> <h3 id="从需求到分析"><a href="#从需求到分析" class="header-anchor">#</a> 从需求到分析</h3> <p>核心思想就是将以用户视角描述的需求模型转换为以开发团队视角描述的分析模型，然后在分析模型的基础上做进一步设计，从而获得设计模型，并最终实现软件系统。<br>
通过分析模型，可以有效地防止开发团队在彻底理解问题之前设计错误的解决方案，从而保证设计模型的正确性。</p> <p>分析模型应该是准确、完整、一致、可验证的系统模型。</p> <h3 id="分析模型"><a href="#分析模型" class="header-anchor">#</a> 分析模型</h3> <p><strong>两个层次</strong></p> <ul><li><code>架构分析</code>，架构分析是从宏观上考虑软件系统基本组织结构，定义系统的备选架构，并明确系统中的一些关键问题，从而为后续的用例分析和架构设计提供支持。</li> <li><code>用例分析</code>，用例分析是一种具体的分析技术，通过分析需求模型中的每一个用例获得分析类，并描述分析类之间的交互，从而实现并验证用例所要达到的目标。</li></ul> <p><strong>两类模型</strong></p> <ul><li><code>静态模型</code>静态模型关注系统组成的静态组织结构，又称结构模型，可以采用UML包图、类图、对象图等静态结构图来描述；</li> <li><code>动态模型</code>动态模型则关注系统组成的动态行为特征，重点描述系统运行期间对象和对象之间的交互过程，又称交互模型，可以采用UML顺序图、通信图等交互图来进行描述。</li></ul> <p>过在分析阶段，侧重于静态特征的建模。其动态特征则只是通过架构机制的方式记录下来，并不进行具体的建模操作</p> <h3 id="分析的基本原则"><a href="#分析的基本原则" class="header-anchor">#</a> 分析的基本原则</h3> <p>最重要的原则就是，当构造分析模型时，把整个活动限制在业务问题域词汇，而不考虑任何技术领域的实现策略，从而保持“分析模型是一个对系统结构和行为的精确和简单”的陈述。所有与实现技术相关的内容都留给设计和实现阶段来考虑。</p> <p><strong>分析原则</strong></p> <ul><li>分析模型应使用业务语言。分析模型中的类主要应该是业务领域的术语。</li> <li>分析模型中类的细节和关系等应该是业务中明确存在的，不要刻意去细化或封装这些细节。例如，只有在业务领域中，分析类之间存在明确的继承层次时才使用泛化关系；而不是考虑代码的复用或者是多态等特性而使用泛化关系。</li> <li>分析活动是对需求模型的重新表述，是一种以理想化的方式来实现用例所描述的行为，并不考虑具体的技术实现。</li> <li>分析侧重于系统的主要部分，关注核心的业务场景。对于那些支撑性行为、非功能需求等内容一般不做深入分析。</li> <li>所有的分析类应该都是为项目涉众产生价值的。</li></ul> <h2 id="从用例开始分析"><a href="#从用例开始分析" class="header-anchor">#</a> 从用例开始分析</h2> <p>分析的基础是需求，而需求的表现形式为用例，因此分析的过程完全是基于用例模型展开的，用例模型确定了分析模型的结构。<br>
用例模型确定了系统的外观，即对外部参与者提供哪些价值；<br>
而分析模型则描述系统的内部机理，即为了提供这些价值，系统内部应该有怎样的对象，进行怎样的交互。</p> <center>用例模型和分析模型的关系</center> <p><img src="/blog/assets/img/2021-03-22-12-00-48.3a59b836.png" alt=""></p> <h3 id="用例驱动的迭代开发"><a href="#用例驱动的迭代开发" class="header-anchor">#</a> 用例驱动的迭代开发</h3> <p>而迭代的基础就是需求，更确切地说就是用例模型。在迭代开发中，一般通过一次全面的用例建模迭代，获取并定义了系统的绝大多数需求后(7)，即可以开始分析设计的迭代工作。</p> <h4 id="用例与迭代开发"><a href="#用例与迭代开发" class="header-anchor">#</a> 用例与迭代开发</h4> <p><strong>早期的迭代主要关注以下内容</strong></p> <ul><li>对于用户来说，主要关注核心业务的主要部分。</li> <li>对系统架构有重要影响的部分。</li> <li>影响系统性能等其他关键非功能需求的部分。</li> <li>存在高风险的部分，如需要采用新技术、新产品的部分。</li></ul> <p>早期的迭代就是针对那些高优先级的用例，从而尽早地建立和稳定软件的架构。</p> <p><strong>需求评审活动</strong><br>
首先需要评估用例模型，以确保所要分析的用例图、用例文档等需求载体是可靠的、一致的。这就是在很多实际项目开发中所要经历的需求评审活动。<br> <center>基于用例的分级定义迭代周期</center></p> <p><img src="/blog/assets/img/2021-03-22-12-11-39.8062c0b7.png" alt=""></p> <h4 id="利用早期迭代建立软件架构"><a href="#利用早期迭代建立软件架构" class="header-anchor">#</a> 利用早期迭代建立软件架构</h4> <p>软件架构总共分为四层：<br> <code>Application</code> 、<br> <code>Business Components</code> 、<br> <code>Persistence Framework</code> 、<br> <code>Infrastructure</code> 。<br>
每个层次内部又分为若干个子包和子系统，如Infrastructure层中有User Interface Routines包和General Routines包及Event Handling Routines子系统和Communication Routines子系统。</p> <center>某系统软件架构</center> <p><img src="/blog/assets/img/2021-03-22-12-24-13.1db97abe.png" alt=""></p> <p>针对该系统而言，成功的早期迭代应该能够及时发现并定义系统的这4层结构，并尽可能地明确每个层次内部的包和子系统结构。</p> <center>通过早期迭代定义系统架构</center> <p><img src="/blog/assets/img/2021-03-22-12-25-03.d85a9dc9.png" alt=""></p> <p><strong>如何能够准确找到可定义系统架构的核心用例</strong></p> <p>通过一次系统的用例建模过程来获取系统60%~80%的需求后，从中找出5%~10%的重要用例，来定义系统的架构。<br>
对于中小规模系统来说，可能需要更多的用例（如40%~50%）才能定义架构。</p> <h4 id="旅店预订系统-的首次迭代"><a href="#旅店预订系统-的首次迭代" class="header-anchor">#</a> “旅店预订系统”的首次迭代</h4> <p><img src="/blog/assets/img/2021-03-22-12-43-10.a3d031d3.png" alt=""></p> <h4 id="旅游申请系统-的首次迭代"><a href="#旅游申请系统-的首次迭代" class="header-anchor">#</a> “旅游申请系统”的首次迭代</h4> <center>“旅游申请系统”首次迭代周期的用例图</center> <p><img src="/blog/assets/img/2021-03-22-12-52-44.b7165cb8.png" alt=""></p> <h3 id="用例实现"><a href="#用例实现" class="header-anchor">#</a> 用例实现</h3> <p><code>用例实现</code> 是分析（设计）模型中一个系统用例的表达式，它通过对象交互的方式描述了分析（设计）模型中指定的用例是如何实现的。通过用例实现，将用例模型中的用例和分析（设计）模型中的类及交互紧密联系起来，一个用例实现描述了一个用例需要哪些类来实现。</p> <p>实现关系采用带三角形箭头的虚线表示，其中箭头指向被实现方。<br> <img src="/blog/assets/img/2021-03-22-14-34-51.64989183.png" alt=""></p> <h3 id="建模指南"><a href="#建模指南" class="header-anchor">#</a> 建模指南</h3> <p>按照UML“4+1”视图的要求，分析模型是面向分析设计人员描述软件结构和行为的，属于逻辑视图。</p> <center>旅店预订系统”首次迭代的跟踪关系图</center> <p><img src="/blog/assets/img/2021-03-22-14-41-42.2e1ce3a8.png" alt=""></p> <center>“旅游申请系统”首次迭代的跟踪关系图</center> <p><img src="/blog/assets/img/2021-03-22-14-41-58.6918213d.png" alt=""></p> <h2 id="架构分析"><a href="#架构分析" class="header-anchor">#</a> 架构分析</h2> <p>架构分析的过程就是定义系统高层组织结构和核心架构机制的过程。</p> <p>架构分析主要包括以下4个方面内容。</p> <ul><li><p>定义系统的备选架构来描述系统的高层组织结构，以用例组织后续的分析模型。</p></li> <li><p>确定分析机制以记录系统中的通用问题。</p></li> <li><p>提取系统的关键抽象以揭示系统必须能够处理的核心概念。</p></li> <li><p>创建用例实现来启动用例分析。</p></li></ul> <h3 id="备选架构"><a href="#备选架构" class="header-anchor">#</a> 备选架构</h3> <p>在早期迭代中，架构分析的主要目标是建立系统的备选架构，以用于组织后续的用例分析所获得的分析模型；</p> <p><strong>备选架构模式</strong></p> <p>架构模式表示了对软件系统的一个基础结构组织形式。它提供了一套预定义子系统，详细说明它们的职责，并且包括组织它们之间的规则和指南。</p> <p><img src="/blog/assets/img/2021-03-22-15-01-10.b4786225.png" alt=""></p> <p>通过B-C-E这三层划分系统中的3类处理逻辑，其中：</p> <ul><li>边界层（Boundary Layer）负责系统与参与者之间的交互。</li> <li>控制层（Control Layer）处理系统的控制逻辑。</li> <li>实体层（Entity Layer）管理系统使用的信息。</li></ul> <h3 id="分析机制"><a href="#分析机制" class="header-anchor">#</a> 分析机制</h3> <p>在架构分析阶段，对系统的非功能需求及那些通用性问题也需要进行单独考虑。架构机制就是用来记录这类问题的一种策略。</p> <p><strong>架构机制</strong></p> <p>架构机制是对通用问题的决策、方针和实践，它描述了针对一个经常发生的问题的一种通用解决方案。<br>
通过有效地应用架构机制，可以使项目组内部以相同的方式对待这些问题，并复用相同的解决方案。<br>
作为系统架构的一部分，架构机制常常集中和定位在系统的非功能需求上。</p> <p><strong>架构机制分类</strong></p> <ul><li><code>分析机制</code>以与实现无关的方式捕获解决方案的关键部分。它们可能表示结构模式或行为模式，也可能同时表示这两者。它们主要用于在分析过程中向设计人员提供复杂行为的简短表示，从而减少分析的复杂性并提高分析的一致性。分析机制通常源于对一个（或多个）架构模式或分析模式的实例化。</li> <li><code>设计机制</code>是对相应分析机制的更具体的定义。设计机制为概念上的分析机制添加具体的细节，但它并不具体到需要特定的技术。与分析机制相同，设计机制可以实例化一种或多种模式，在这种情况下为架构模式或设计模式。</li> <li><code>实现机制</code>则是详细说明了机制的准确实现。它使用特定的编程语言及其他实现技术（如特定厂商的中间件产品）对相应设计机制进行改进。一个实现机制可以实例化一个（或多个）代码模式或实现模式。</li></ul> <center>架构机制示例</center> <p><img src="/blog/assets/img/2021-03-22-15-14-37.68430d4d.png" alt=""></p> <p>分析机制通常与具体业务无关，它属于“计算机科学”的范畴，是对与软件实现相关的关键技术的描述。</p> <p><strong>确定分析机制</strong></p> <p>对分析机制的处理主要包括3个方面的工作</p> <ul><li>需要抽取出系统中所有的分析机制</li> <li>建立分析机制和所关联的类之间的关系</li> <li>确定类所拥有的分析机制的相关特性</li></ul> <p>不同的角度来抽取分析机制</p> <ul><li><code>自顶向下</code>根据类似项目的经验来估计出领域内会有哪些问题，以及如何解决这些问题。在分析过程中，常见的架构问题（即机制）包括持久化、安全性、事务处理、异常处理、分布式访问等。</li> <li><code>自底向上</code>随分析过程的深入逐步确定，分析机制是最后生成的。在定义每一个分析类的过程中，如果发现相应的问题最初比较模糊，可以先将它们定义为与具体实现策略无关的分析机制，在后续迭代中再进行进一步细化。</li></ul> <center>“旅游申请系统”分析机制</center> <p><img src="/blog/assets/img/2021-03-22-15-42-03.9d3ba4f2.png" alt=""></p> <center>分析机制的特征</center> <p><img src="/blog/assets/img/2021-03-22-15-56-25.066ffb2e.png" alt=""></p> <p><img src="/blog/assets/img/2021-03-22-16-11-04.e302ed54.png" alt=""></p> <h3 id="关键抽象"><a href="#关键抽象" class="header-anchor">#</a> 关键抽象</h3> <p>业务建模阶段和需求阶段通常会揭示系统必须能够处理的核心概念，而这些核心概念也往往会作为系统设计和实现阶段的关键类，因此这些概念需要在分析阶段进一步明确，这就是关键抽象。</p> <p><strong>“旅游申请系统”关键抽象说明</strong></p> <p><img src="/blog/assets/img/2021-03-22-16-21-17.6ddeefdb.png" alt=""></p> <h3 id="完善用例文档"><a href="#完善用例文档" class="header-anchor">#</a> 完善用例文档</h3> <ul><li><code>用例</code>面向用户描述功能</li> <li><code>用例实现</code>则面向分析设计人员描述软件的内部结构</li></ul> <h3 id="识别分析类"><a href="#识别分析类" class="header-anchor">#</a> 识别分析类</h3> <p>在对象系统中，系统的所有功能都是通过相应的类来实现的。因此，首先需要从用例文档中找出这些可用的类，再将其所描述的系统行为分配到这些类中。</p> <p>边界类处于系统的最上层，它从那些系统和外界进行交互的对象中归纳和抽象出来，代表了系统与外部参与者交互的边界。存在两类边界类：用户界面类和系统/设备接口类。</p> <ul><li><code>用户界面类代表系统</code> 与外部用户进行交互的类，在分析期间并不关注界面的细节（如窗体或页面的个数、布局）及实现方案，而是侧重于为用户提供哪些操作（即用户通过界面能做什么，如录入特定信息等）。</li> <li><code>系统/设备接口类</code> 代表系统与外部系统或设备之间交互的接口类，在分析期间通过接口类主要关注交互的协议，而不关注协议实现的细节。</li></ul> <p><strong>边界类</strong></p> <center>边界类的3种表示方法</center> <p><img src="/blog/assets/img/2021-03-22-17-53-30.1df1416a.png" alt=""></p> <center>识别边界类</center> <p><img src="/blog/assets/img/2021-03-22-17-53-41.9a47e911.png" alt=""></p> <p>针对参与者和用例之间的每一个关联关系就可以定义一个边界类</p> <p><strong>控制类</strong></p> <p>控制类处于三层架构的中间层，它封装控制系统上层的边界类和下层的实体类之间的交互行为，是整个用例行为的协调器。控制类所提供的行为具有以下特点。</p> <ul><li>独立于外部环境，不依赖于环境的变更。</li> <li>定义用例中的控制逻辑和事务管理。</li> <li>在实体类的内部结构或行为发生变更的情况下，不会有大的变更。</li> <li>使用或修改若干实体类的内容，因此需要协调这些实体类的行为。</li> <li>并不是每次用例激活时都以同样的方式运行（因为事件流本身具有不同的状态）。</li></ul> <p>在用例分析阶段，对控制类识别的基本原则是，为每个用例确定一个控制类。</p> <center>控制类的3种表示方法</center> <p><img src="/blog/assets/img/2021-03-22-18-01-35.1248b807.png" alt=""></p> <center>识别控制类</center> <p><img src="/blog/assets/img/2021-03-22-18-02-17.5d55bbd8.png" alt=""></p> <p>由于并不存在一些具体的方法或原则来识别实体类，因此为了能够有效地识别，还需要采取其他的辅助手段。一种最常用的方法就是名词筛选法。</p> <p><strong>实体类</strong></p> <p>实体类代表了系统的核心概念，它来自对业务中的实体对象的归纳和抽象，用于记录系统所需要维护的数据和对这些数据的处理行为。实体类提供了另一个理解系统的观点，即从系统的逻辑数据结构来描述系统应该为用户提供哪些功能。</p> <center>实体类的3种表示方法</center> <p><img src="/blog/assets/img/2021-03-22-21-24-57.cccddaf3.png" alt=""></p> <p><img src="/blog/assets/img/2021-03-22-21-25-19.d0bff996.png" alt=""></p> <ul><li>将用例事件流作为输入，找出事件流中的名词或名词性短语（可采用下画线标注出来），这些名词形成了实体类的初始候选列表。</li> <li>合并那些含义相同的名词。因为事件流描述的可能不准确，所以相同的概念可能采用了不同的名词，需要将这些不同的名词进行统一定义，并重新确定合适的名称。</li> <li>删除那些系统不需要处理的名词。有些名词可能只是用例中的描述信息，并不需要处理，这些名词也不会作为实体类存在。</li> <li>删除作为参与者的名词。因为参与者是在系统范围外的，所以在当前用例中不作为实体类被定义。不过，由于大部分系统都会维护那些用户类型的参与者，因此这些用户信息将会在其他的用例（如登录、管理用户等用例）中被定义为实体类。</li> <li>删除与实现相关的名词。分析阶段不考虑系统实现方案，因此与实现相关的内容也不会作为实体类存在。</li> <li>删除那些作为其他实体类属性的名词。有些名词可能只简单地描述一个值，这些单一的值一般也不作为类存在，而会作为其他类的属性。</li> <li>对剩余的名词，综合考虑它们在当前用例及整个系统中的含义、作用和职责，并基于此确定合适的名称，从而将这些名词作为初始的实体类存在。</li></ul> <p><strong>总结分析类</strong><br>
识别分析类的过程就是对于每个用例实现，根据系统备选架构的约定，从中抽取出相应的边界类、控制类和实体类来填充系统架构。通过所识别的这些类，来达到该用例实现所实现的用例的业务价值。</p> <center>会员支付业务的用例模型和分析模型</center> <p><img src="/blog/assets/img/2021-03-22-21-30-44.6562860d.png" alt=""></p> <h3 id="识别分析类实践"><a href="#识别分析类实践" class="header-anchor">#</a> 识别分析类实践</h3> <p><strong>“旅游申请系统”全部分析类</strong></p> <center>“旅游申请系统”初始边界类</center> <p><img src="/blog/assets/img/2021-03-22-21-55-39.3d42e4c7.png" alt=""></p> <center>“旅游申请系统”初识控制类</center> <p><img src="/blog/assets/img/2021-03-22-21-56-23.25426b22.png" alt=""></p> <center>“旅游申请系统”初识实体类</center> <p><img src="/blog/assets/img/2021-03-22-21-57-18.c734fbaa.png" alt=""></p> <h3 id="分析交互"><a href="#分析交互" class="header-anchor">#</a> 分析交互</h3> <p>两种典型的交互图</p> <ul><li><p><code>顺序图</code> 顺序图是强调消息时间顺序的交互图</p></li> <li><p><code>通信图</code> 通信图则是强调接收和发送消息的对象间关系的交互图。</p></li></ul> <h4 id="顺序图"><a href="#顺序图" class="header-anchor">#</a> 顺序图</h4> <p>顺序图强调消息的时间顺序</p> <ul><li>对象和对象生命线</li></ul> <center>顺序图</center> <p><img src="/blog/assets/img/2021-03-23-09-36-42.1370e517.png" alt=""></p> <p>消息表示为从一条生命线到另一条生命线的箭头；箭头指向消息的接收者，表示对其操作的调用。</p> <ul><li>消息</li></ul> <center>顺序图中的消息</center> <p><img src="/blog/assets/img/2021-03-23-09-37-10.606bdbe9.png" alt=""></p> <center>消息的顺序编号和层级编号</center> <p><img src="/blog/assets/img/2021-03-23-09-40-40.86a2f75e.png" alt=""></p> <ul><li>执行发生</li></ul> <h4 id="利用顺序图描述交互"><a href="#利用顺序图描述交互" class="header-anchor">#</a> 利用顺序图描述交互</h4> <ul><li><code>放置对象</code>：从已识别的参与用例的分析类中构造相应的对象放置到顺序图中。</li> <li><code>描述交互</code>：从参与者开始，按照用例事件流（或场景）的叙述，将系统行为转换为对象间的消息。</li> <li><code>验证行为</code>：从后往前，验证对象的行为序列，确保每一个对象能够实现该行为序列。</li></ul> <p><strong>“旅店预订系统”中“预订房间—用例实现”的基本场景为例</strong></p> <p><strong>放置对象</strong></p> <p>放置对象的基本顺序是ABCE（Actor、Boundary、Control、Entity），表示“首先在顺序图中放置该用例的外部参与者，然后放入边界对象，接着放入控制对象，最后放入实体对象。”</p> <p><img src="/blog/assets/img/1616478940.drawio.13063338.svg" alt=""></p> <p><strong>描述交互</strong></p> <p>具体职责分配过程中，还可以从以下两个方面来考虑职责分配问题。</p> <p><code>以分析类的构造型</code> 作为职责分配的基本依据：</p> <ul><li>边界类承担与参与者进行通信的职责。</li> <li>控制类承担协调用例参与者与内部数据操作之间交互的职责。</li> <li>实体类承担对被封装的内部数据进行操作的职责。</li></ul> <p><code>专家模式</code> 将职责分配给具有当前职责所需要的数据的类：</p> <ul><li><p>如果一个类有这个数据，就将职责分配给这个类。</p></li> <li><p>如果多个类有这个数据，则</p> <p>方案1是将职责分配给其中的一个类，并对其他类增加一个关系。<br>
方案2是将职责放在控制类中，并对需要该职责的类增加关系。<br>
方案3是创建一个新类，将职责分配给该类，并对需要该职责的类增加关系。</p></li></ul> <p><img src="/blog/assets/img/2021-03-23-10-22-19.bfe1b311.png" alt=""></p> <center>分析交互实践</center> <ul><li><p>建模指南</p></li> <li><p>办理申请手续—用例实现</p></li></ul> <p><img src="/blog/assets/img/1616479573.drawio.0f2990b2.svg" alt=""></p> <center>增加参加人—用例实现</center> <p><img src="/blog/assets/img/1616486662.drawio.8ba740a7.svg" alt=""></p> <center>完成支付—用例实现</center> <p><img src="/blog/assets/img/1616496116.drawio.b0bfefd6.svg" alt=""></p> <center>导出财务信息—用例实现</center> <img src="http://172.18.0.3:8080/png/ZP91IyCm68Rltwy8k-yFx213Jplx2-8MeR0cqgP2ZnxK8b8zR6mNAQiKZrKSEnZ1FxCasxymMpj9IS4Tm_S-t_U-B-c770SyyiU08yxma7lNc1F4A81vi01rUcgssiwM7OH3n3sVm0MBw0W7iHd9yblUVssMkNnOh7yMwgRKqyVjIwu_n5xlCqhY0RrafpK3GqPvmCQjh4hVPB9osBCA0KAvntTNrQHSYxcQfrhSxQLNk26q35RhzQVG8bDf8PzU6-lFu_3FsI6kZJIK0Blug7lYna8zLBKaatS0TsmpjKk3k0rOx47MZggis9Jv_sYp6GFgIQQIvoDlMlNKTcyBknvmL1RPJa2Vq97vRhy0" alt="uml diagram"> <ul><li>顺序图中的交互片段</li></ul> <p>操作符包括可选（opt）、选择（alt）、循环（loop）、并行（par）等</p> <ol><li>可选片段</li></ol> <p>操作符为 <code>opt</code> ，类似于C++语言中的if-then控制结构，表示该片段只有在守卫条件成立时才能够执行，否则跳过该片段往后执行。守卫条件是一个用方括号括起来的布尔表达式，它可能出现在片段内部任何一条生命线的顶端，还可以引用该对象的属性。</p> <ol start="2"><li>选择片段</li></ol> <p>操作符为 <code>alt</code> ，类似于C++语言中的switch控制结构。。该片段的主体用水平虚线分割成几个分区（类似于switch语句的case子句）。每个分区都有一个守卫条件，表示当守卫条件为真时执行该分区。此外，每次最多只能执行一个分区，如果有多于一个守卫条件为“真”，那么选择哪个分区是不确定的（这一点与C++不同，C++中是执行第一个为“真”的case子句），而且每次执行的选择可能不同。如果所有的守卫条件都不为真，那么该片段将不被执行。此外，还可以定义一个else分区，该分区的守卫条件为[else]，如果其他所有的分区都不为真，则执行该分区（类似于switch语句中的default子句）。</p> <ol start="3"><li>循环片段</li></ol> <p>操作符为 <code>loop</code> ，类似于C++语句中的while控制结构（也可利用loop后面的参数模拟for循环），表示该片段在守卫条件为“真”的情况下循环执行；一旦守卫条件为“假”，则跳过该片段往后执行。</p> <ol start="4"><li>并行片段</li></ol> <p>操作符为 <code>par</code> ，该片段的主体也被水平虚线分割成几个分区，不同的分区可能覆盖不同的生命线，表示当进入该片段后，这几个分区要并行（或并发）执行。每个分区内的消息是顺序执行的，但是并行分区之间消息的相对次序则是任意的（即不同并行分区内的消息可以并发地执行）。在多核环境下，并行（或并发）程序正日益普及，而该操作符将在这类应用程序的设计中被广泛应用。</p> <ul><li>顺序图的分拆和引用</li></ul> <p>交互片段的基本思想就是将那些非顺序执行的部分封装为一个片段，针对该片段实施各种不同的操作，从而表达各种非顺序的执行。这个片段采用 <code>sd</code> （sequence diagram）操作符（事实上，这不能算操作符，因为并不实施任何操作；只是用一个标签来说明该片段为一个完整的顺序图），操作符后面可以写上该顺序图的名称。</p> <center>顺序图的纵向分拆和引用</center> <p><img src="/blog/assets/img/2021-03-23-17-48-05.8180ece0.png" alt=""></p> <ol><li>纵向分拆和引用</li></ol> <p>纵向分拆是沿着顺序图的纵轴（即时间序列）的方向，将某一段时间段内的若干对象之间传递的一组消息拆分出去，同时在当前顺序图中给出相应的引用标识，指向另一个展现被拆分出来的内部消息传递过程的顺序图。通过这种方式允许不同顺序图引用相同的消息交互片段，避免了无谓的重复描述，提升了模型内容的可维护性。</p> <ol start="2"><li>横向分拆和引用</li></ol> <p>横向分拆是沿着顺序图的横轴（即对象序列）的方向，在全时间范围内，将一组对象及其相互之间的消息封装为一个与其他对象交互的“组合结构”，该“组合结构”指向相应的具体消息传递情形。</p> <p><img src="/blog/assets/img/2021-03-23-17-57-22.5502fd0e.png" alt=""></p> <h3 id="完成参与类类图"><a href="#完成参与类类图" class="header-anchor">#</a> 完成参与类类图</h3> <p>分析交互的过程主要关注用例实现的交互行为特征，是用例实现的动态视图。</p> <center>“办理申请手续—用例实现”的VOPC类图</center> <p><img src="/blog/assets/img/2021-03-23-19-27-30.7e852c71.png" alt=""></p> <h3 id="处理用例间的关系"><a href="#处理用例间的关系" class="header-anchor">#</a> 处理用例间的关系</h3> <p>1． 包含关系<br>
包含关系表达了基用例对子用例（即被包含用例）的直接引用，而这种引用在分析阶段即表现为基用例实现对子用例实现的交互的引用。这类引用可以采用UML 2所提供的ref片段来表达，即在基用例实现的顺序图中通过ref引用子用例的顺序图片段，以包含子用例实现的行为。而对于子用例实现来说，基用例实现就是它的外部用户，来使用它所定义的行为。包含关系的具体分析过程如下所示。</p> <ul><li>为子用例定义一个边界类，可以将该边界类看成是基用例对子用例的调用界面，由基用例的控制类来启动该边界类。</li> <li>基用例实现通过横向分拆或纵向分拆的方式引用子用例实现的交互。</li></ul> <center>“查询申请信息—用例实现”基本场景的顺序图</center> <ol start="2"><li><p>扩展关系</p></li> <li><p>泛化关系</p></li></ol> <h3 id="总结-构造用例实现"><a href="#总结-构造用例实现" class="header-anchor">#</a> 总结：构造用例实现</h3> <p>构造用例实现是整个用例分析最核心的工作，其最终目标是获得实现用例行为所必需的分析类，并利用这些分析类来描述其实现逻辑。具体的分析过程是针对每一个用例实现，完成下面4个步骤。</p> <ul><li>完善用例文档。结合分析目标和分析策略，完善待分析的用例文档。</li> <li>识别分析类。从完善后的用例文档中识别分析类，包括边界类、控制类和实体类三类分析类。其中的重点是实体类，要结合架构分析中的关键抽象和名词筛选法来识别实体类。</li> <li>分析交互。利用识别的分析类，采用交互图来分析用例实现的交互过程。早期的迭代重点在基本场景，后期的迭代可能需要针对不同的场景绘制更多的交互图。</li> <li>完成参与类类图。根据交互图中的消息和实体类内在的关系来绘制参与当前用例实现的类的类图。</li></ul> <p>一般情况下，上面4个步骤是针对每一个用例实现独立完成的；而对于存在关系的两个用例实现，则需要采用特定的技术将分析结果联系起来。</p> <h2 id="定义分析类"><a href="#定义分析类" class="header-anchor">#</a> 定义分析类</h2> <p>定义分析类的最终目标就是，从系统的角度，明确说明每一个分析类的职责和属性及类之间的关系，从而构造系统的分析类视图；根据这些视图来描述和理解目标系统，从而为后续的设计提供基本的素材。</p> <h3 id="定义职责"><a href="#定义职责" class="header-anchor">#</a> 定义职责</h3> <p>职责（Responsibility）是要求某个类的对象所要履行的行为契约，它说明了该对象能够对外提供哪些行为。构造用例实现的过程实际上就是进行类的职责分配的过程</p> <p>从职责所履行的功能来划分，有两种类型的职责。</p> <ul><li><code>做型</code>职责：对象能够完成某些动作的职责，包括某个具体的业务操作、发起其他对象执行动作或者控制和协调其他对象内部的活动。</li> <li><code>知道型</code>职责：对象提供自己所知道信息的职责，包括提供或修改自身的私有的数据、获取与其关联的对象信息或自己派生（或计算）出来的事物。</li></ul> <p>做型职责则反映了对象的行为特征。<br>
知道型职责取决于对象自身的属性和关系。</p> <h4 id="分析操作"><a href="#分析操作" class="header-anchor">#</a> 分析操作</h4> <h4 id="文本描述"><a href="#文本描述" class="header-anchor">#</a> 文本描述</h4> <p>CRC卡（Class-Responsibility-Collaborator cards，类—职责—协作卡）虽然不是UML的组成部分，但是在定义类的职责和描述与对象之间的协作方面（与UML类图相比）有它自己的特点，因此在对象分析和设计中被广泛地采用。<br>
CRC卡是由一系列卡片组成，每张卡对应一个类。卡中包括类名、类的职责和一系列完成这些职责的协作对象（即参与该职责的对象）<br> <img src="/blog/assets/img/2021-03-24-08-28-43.e6d96ca6.png" alt=""><br> <img src="/blog/assets/img/2021-03-24-08-29-06.6d3ae54a.png" alt=""></p> <h4 id="保持类职责的一致性"><a href="#保持类职责的一致性" class="header-anchor">#</a> 保持类职责的一致性</h4> <p><strong>从以下几个方面着手来保持类职责的一致性</strong></p> <ul><li>当一个类的职责互不相干时，可以将这些不相干的职责分成不同的类，并更新交互图。</li> <li>当两个（甚至更多个）不同的类有相似的职责时，合并这些相似的职责形成新的类，并更新交互图。</li> <li>当在分析另一个用例实现时，发现一种更好的职责分配方案，此时可以返回之前的交互图并采用新的分配方案来重新分配职责。</li> <li>只有一个职责的类虽然没有什么问题，但对它存在的必要性是值得质疑的。此情况下，可以考虑把这仅有的职责合并到其他类中。当然，没有职责的类就更没有存在的必要了。</li></ul> <p>虽然在分析阶段可以就类职责的一致性进行评估，但这并不是分析的重点。只要适当注意上面所提到的这些问题并进行相应的处理即可，没有必要在保持类职责一致性方面浪费更多的时间，这些工作将会在设计中结合相关的设计理论和原则去重点考虑。</p> <h3 id="定义属性"><a href="#定义属性" class="header-anchor">#</a> 定义属性</h3> <h3 id="定义关系"><a href="#定义关系" class="header-anchor">#</a> 定义关系</h3> <ul><li><p>对象间的链接</p></li> <li><p>旅游团和路线：根据业务场景和相关用例文档的描述，每一个旅游团都是在已经规划好的路线上开设的，因此路线是对旅游团中相关信息的描述，它们之间也构成了一种关联关系。</p></li> <li><p>申请和旅游团：每个旅游申请都需要指定并维护所申请的旅游团信息，它们之间显然也构成了一种关联关系。</p></li> <li><p>申请和参加人：一个申请中存在若干个参加人，即申请需要维护其参加人信息，它们之间也构成了一种关联关系。</p></li> <li><p>申请和支付明细：一个申请包括所需的费用、定金等支付信息，这种关系也构成了一种关联关系。</p></li> <li><p>参加人和联系人：每个申请的参加人都需要指定其紧急情况下的联系人，这也构成了一种关联关系。</p></li></ul> <h4 id="定义多重性"><a href="#定义多重性" class="header-anchor">#</a> 定义多重性</h4> <p>关联表示了对象间的结构关系，然而一个类可以生成多个对象，这也意味着由一个关联可能生成若干个链接实例，或者说一个类的对象可能链接到所关联的类的多个对象上，这种“多少”即为关联角色的多重性，它表示一个整数的范围，通过多重性表达式来指名一组相关对象的可能个数。<br>
多重性表达式可用逗号分隔为多个区间，每个区间为“min..max”的形式，其中该区间的min表示最小值，max表示最大值，即该对象的个数可以取从min到max的个数</p> <p>典型的多重性表达式:</p> <p><img src="/blog/assets/img/2021-03-24-12-49-40.959ea6c4.png" alt=""></p> <h4 id="聚合关系"><a href="#聚合关系" class="header-anchor">#</a> 聚合关系</h4> <p><code>聚合关系</code> 是一种特殊的关联关系，除了拥有关联关系所有的基本特征外，两个关联的类还分别代表“整体”和“部分”，意味着整体包含部分。对于聚合关系的识别，可以在已有的关联关系基础上，通过分析两个关联的类之间是否存在“A（整体）由B（部分）构成”“B（部分）是A（整体）的一部分”等整体和部分的语义来完成。</p> <h4 id="泛化关系"><a href="#泛化关系" class="header-anchor">#</a> 泛化关系</h4> <h3 id="限定分析机制"><a href="#限定分析机制" class="header-anchor">#</a> 限定分析机制</h3> <p><img src="/blog/assets/img/2021-03-24-13-05-45.d4f50c40.png" alt=""></p> <p><strong>几个类的典型分析机制特征值</strong><br> <img src="/blog/assets/img/2021-03-24-13-06-39.7956fcb2.png" alt=""></p> <h3 id="统一分析类"><a href="#统一分析类" class="header-anchor">#</a> 统一分析类</h3> <p>统一分析类工作的主要内容是评估已定义的分析类和用例实现，从而确保每个分析类表示一个单一的、明确定义的概念，并且不会出现职责重叠。要从系统全局角度确保创建了最小数量的分析类。通过统一分析类的过程，要达到以下两个目标。</p> <ul><li>验证分析类满足系统的功能需求。</li> <li>验证分析类及其职责与它们支持的协作是一致的。</li></ul> <p>以下几个角度来评估分析类</p> <ul><li>每个类的名称都清楚地反映了其所扮演的角色。</li> <li>类表示了一个单一的、明确定义的抽象。</li> <li>所有属性和职责在功能上都是与类联系在一起的。</li> <li>类提供了必要的行为支持用例实现。</li> <li>类的所有需求都已经满足。</li> <li>所有的属性和关系是必要的，并且用例实现需要它们的支持。</li></ul> <h2 id="练习"><a href="#练习" class="header-anchor">#</a> 练习</h2> <h3 id="选择题"><a href="#选择题" class="header-anchor">#</a> 选择题</h3> <p>1．下列有关分析机制的论述中，错误的是（　B　）。</p> <ul><li>A．分析机制是构架机制的一种</li> <li>B．分析机制是对设计机制的具体描述</li> <li>C．分析机制常用于建模非功能需求</li> <li>D．不同的分析机制一般具有不同的特征</li></ul> <p>2．关于用例实现，下列说法错误的是（　C　）。</p> <ul><li>A．一个用例实现是设计模型中一个系统用例的表达式</li> <li>B．一个用例实现可以使用一个类图来表示</li> <li>C．用例实现提供了从分析和设计到需求的可追踪性</li> <li>D．用例实现与其关联的用例之间存在实现关系</li></ul> <p>3．下图是某系统首次迭代的用例图（隐去了具体的参与者和用例名）。根据用例分析规则，在首次迭代的用例分析过程中，可能产生的边界类、实体类、控制类的数目不应该为（　A　）。</p> <p><img src="/blog/assets/img/2021-03-24-14-31-32.f488c9bf.png" alt=""></p> <ul><li>A．3、3、3</li> <li>B．4、3、2</li> <li>C．4、4、2</li> <li>D．4、5、2</li></ul> <p>4．已知某一个用例实现的VOPC图如下，下列4个选项中的顺序图片段（图中省略了消息编号、名称和返回消息），（　C　）肯定不是该用例实现的一条路径。</p> <p><img src="/blog/assets/img/2021-03-24-14-31-55.c0d3942a.png" alt=""></p> <p>5．现要建立一个对淘汰赛的比赛结果进行跟踪的模型，其中比赛的场数取决于参赛队伍的数量，不考虑种子队伍和双淘汰赛等特殊赛制要求。下图给出了部分模型，而下列的4个选项则给出了针对该部分模型进一步完善的思路，其中（　B　）完善思路是错误的。</p> <p><img src="/blog/assets/img/2021-03-24-14-32-16.940d0f53.png" alt=""></p> <ul><li>A．比赛的得分可以在比赛类中定义正分、负分的属性</li> <li>B．比赛的得分可以在参赛队伍中定义得分的属性</li> <li>C．比赛中获胜队伍与战败队伍的区别用与比赛类的关联及其角色名来表现</li> <li>D．某次比赛与其前后比赛的关系，可以用比赛类的自反关联来表现</li></ul> <p>6．某电影院在保留原有售票系统基础上，要开发新的在线订票系统。普通观众需要在系统中注册，并领取会员卡，才可成为会员。会员可通过该系统在线购买电影票。会员通过电影名称、日期等查询指定场次的电影，如果该场次有空座，则可购买该场次电影票，并通过信用卡结算系统支付票款，从而完成购票过程。购票完成后，会员最晚可以在电影开始前10分钟到电影院指定的售票窗口领取电影票；售票员根据会员提供的会员卡利用该系统打印出所购的电影票。会员也可以在电影开始前2个小时通过该系统退掉已经预订的电影票，退票会收取10%的手续费。未办理退票手续，也没有按时领票入场的情况下系统按自动放弃处理，相关的票款不再退回。系统会在每天晚上10点处理当天的退票申请，并将需要返还的费用通过信用卡结算系统返还给退票的会员。按照该场景描述，完成下列第（1）~ （4）题。</p> <p>（1）下列有关该系统参与者和用例的描述中，错误的是（　B　）。</p> <ul><li>A．会员作为参与者，可以通过该系统在线购票</li> <li>B．售票员作为参与者，可以通过该系统为普通观众售票</li> <li>C．时间作为参与者，会定期启动系统，结算需返还的费用</li> <li>D．信用卡结算系统作为一个外部系统，也是本系统的一个参与者</li></ul> <p>（2）考虑用户购票和退票过程中都需要通过信用卡结算系统进行费用结算，因此可以把与信用卡结算系统交互的功能封装在一个单独的用例“信用卡结算”中。此时，用例“购票”与用例“信用卡计算”之间存在（　A　）关系。</p> <ul><li>A．包含</li> <li>B．扩展</li> <li>C．泛化</li> <li>D．关联</li></ul> <p>（3）下列选项中，（　D　）实体类需要同时引入持久化和遗留接口两个分析机制。</p> <ul><li>A．会员</li> <li>B．场次信息</li> <li>C．购票信息</li> <li>D．支付信息</li></ul> <p>（4）下图展示了实体类“场次信息”（某部电影的一次放映）和“购票信息”（某个会员的一次购票请求）之间是关联关系。下列有关该图所展示的关联关系的论述中，正确的是（D）。</p> <ul><li>A．一个购票信息对应0到多个场次信息</li> <li>B．一个场次信息对应1到多个购票信息</li> <li>C．该关联关系没有任何方向的导航性</li> <li>D．可以添加一个关联类描述该关联关系</li></ul> <p>7．某快递公司为提高服务效率，需要建立一个基于Web的服务系统。客户可以通过该系统委托上门提货或再次配送。其中上门提货是指让快递公司配送人员上门取客户需要邮寄的物品；而再次配送则是指将由于某些原因未能收到的物品进行再度配送。当货物配送完成后，配送人员需要将结果记录到系统中，并通过系统给顾客发送电子邮件告知配送完成。系统每天晚上24点自动将当天所有已经完成的客户配送情况导出到公司内部的办公系统中，公司领导第二天早上就可以通过办公系统查看到前一天配送情况的统计报表。<br>
根据上面所描述的场景，完成下列第（1）~（3）题。<br>
（1）下列有关该系统参与者和用例的描述中，错误的是（　D　）。</p> <ul><li>A．客户作为参与者，可以通过该系统请求再次配送</li> <li>B．配送人员作为参与者，可以记录配送结果</li> <li>C．时间作为参与者，会定期启动系统，将配送情况导出到办公系统</li> <li>D．公司领导作为参与者，可以查看配送情况的统计报表</li></ul> <p>（2）在需求建模期间，系统分析师发现“上门提货”和“再次配送”两个用例之间存在一些相同的步骤，把这些相同的步骤提取出来作为一个单独的用例，此时这两个用例和新提取出来的用例之间是（　A　）关系。</p> <ul><li>A．包含</li> <li>B．扩展</li> <li>C．关联</li> <li>D．实现</li></ul> <p>（3）在将配送情况导入办公系统这项业务的用例分析流程中，下列选项中（　D　）不是所抽取出的分析类。</p> <ul><li>A．导出配送情况控制类</li> <li>B．办公系统接口类</li> <li>C．配送情况实体类</li> <li>D．公司领导查看统计报表界面类</li></ul> <p>8．某销售公司以扩大销售对象、提高客户满意度为目标，决定在现有店面销售业务的基础上开展网上订购业务，为此需要开发一套网上订购系统。目前正在研究的系统需求包括：①系统规定只能由注册为会员的人使用，未注册用户通过系统注册为会员；②会员连接到系统网站后，可以通过该系统下订单订购商品；③会员可以查询商品，这时显示商品的详情和库存信息。除本次开发的系统外，还需要专门开发一套货物配送系统完成送货流程的管理，本系统会将送货信息定期导入到货物配送系统中，送货员通过货物配送系统进行送货。<br>
根据上面所描述的场景，完成下列第（1）~（2）题。<br>
（1）在用例建模阶段，下列选项中（　C　）不是系统的参与者。</p> <ul><li>A．未注册用户</li> <li>B．会员</li> <li>C．送货员</li> <li>D．货物配送系统</li></ul> <p>（2）在用例分析阶段，下列选项中（　A　）不是该系统的实体类。</p> <ul><li>A．未注册用户</li> <li>B．会员</li> <li>C．订单</li> <li>D．商品</li></ul> <h3 id="简答题"><a href="#简答题" class="header-anchor">#</a> 简答题</h3> <p>1．分析模型主要包括什么内容？</p> <blockquote><p>分析模型是对分析所形成目标制品的总称；具体来说，分析模型包含两个层次的两类模型。两个层次是指架构分析和用例分析。两类模型是指静态模型和动态模型</p></blockquote> <p>2．什么是用例实现？它和用例之间有什么区别和联系？</p> <blockquote><p>用例实现是分析（设计）模型中一个系统用例的表达式，它通过对象交互的方式描述了分析（设计）模型中指定的用例是如何实现的。<br>
通过用例实现将用例模型中的用例和分析（设计）模型中的类以及交互紧密联系起来，一个用例实现描述了一个用例需要哪些类来实现，两者之间存在实现关系：即“用例实现”实现“用例”</p></blockquote> <p>3．什么是架构模式，有哪些典型的架构模式？</p> <blockquote><p>架构模式是那些在开发过程中积累下来，并经过实践验证之有效的、可复用的软件架构。它表示了对软件系统的一个基础结构组织形式。它提供了一套预定义子系统，详细说明他的职责，并且包括组织它们之间的规则和指南。<br>
针对不同的软件类别，存在诸多架构模式，如针对系统软件的层、管道和过滤器、黑板，针对交互式软件的模型视图控制器模式等等</p></blockquote> <p>4．什么是B-C-E三层架构？</p> <blockquote><p>B-C-E 三层架构是对MVC架构的另一种表述，将系统划分为三层，分别处理3类业务逻辑。其中B表示边界层，负责处理系统与参与者的交互；C为控制层，处理系统的控制逻辑，E为实体层，负责管理系统使用的信息</p></blockquote> <p>5．什么是架构机制，什么是分析机制，有哪些典型的分析机制？</p> <blockquote><p>架构机制是对通用问题的决策、方针和实践，它描述了针对一个经常发生的问题的一种通用解决方案。通过解决方案。通过有效地应用架构机制，可以使项目组内部以相同的方式对待这些问题，并复用相同的解决方案来实现复用<br>
分析机制是架构机制在分析阶段的表述，它以与实现无关的方式捕获解决方案的关键部分。它们可能表示结构模式或行为模式，也可能表示这两者。它们主要用于在分析过程中向设计人员提供复杂行为的简短表示，从而减少分析的复杂性并提高分析的一致性。<br>
典型的分析机制包括持久性、分布、安全性等</p></blockquote> <p>6．什么是关键抽象，如何识别关键抽象？</p> <blockquote><p>关键抽象是一个通常在需求上被揭示的概念，系统必须能够对其处理。它来源业务，体现了业务的核心价值，即业务需要处理哪些信息；这些信息所构成的实体即可作为初步的实体分析类<br>
关键抽象来自业务领域，领域专家可以很清楚地提供业务系统的初始关键抽象候选集合，在此基础上，再结合业务对象模型、需求和词汇表等业务文档资料补充和完善</p></blockquote> <p>7．什么是边界类，什么是控制类，如何识别这两种分析类？</p> <blockquote><p>边界类是那些系统和外界进行交互的对象中归纳和抽象出来，代表了系统与外部参与这交互的边界<br>
控制类封装控制系统上层的边界类和下层的实体类之间的交互行为，是整个用例行为的协调器<br>
在用例分析阶段，对边界类识别的基本原则是，为每一个参与者/用例确定一个边界类。对控制类识别的基础原则是，为每一个用例确定一个控制类。</p></blockquote> <p>8．什么是实体类，如何有效地识别实体类？</p> <blockquote><p>实体类代表了系统的核心概念，来自于业务中的实体对象的归纳和抽象，用于记录系统所需要维护的数据和对这些数据的处理行为<br>
实体类是要用于表示业务信息的名称，因此识别实体类的基本思路是分析用例事件流中的名词、名称短语，找到所需的实体信息，架构分析中的关键抽象更是识别实体类最重要的来源，而更多的实体类还需要从用例事件流、业务模型、词汇表等业务和需求的载体中获得。</p></blockquote> <p>9．顺序图中主要有哪些元素，绘制顺序图的基本过程是什么？</p> <blockquote><p>顺序图是一种UML交互图，表示对象的交互，由一组对象和它们之间的消息传递组成，强调消息的时间顺序。主要包括对象、对象生命线、消息、执行发生等元素<br>
一般针对用例的每个场景，均可绘制相应的顺序图，按照3个步骤进行。</p> <ol><li>放置对象：已从识别的参与用例的分析类中构造相应的对象放置到顺序图中</li> <li>描述交互：从参与者开始，按照用例事件流（或场景）的叙述，将系统行为转化为对象间的消息</li> <li>验证行为：从后往前，验证对象的行为序列，确保每一个对象能够实现该行为序列</li></ol></blockquote> <p>10．顺序图中的交互片段有什么作用，有哪些典型的交互片段？</p> <blockquote><p>交互片段将顺序图中的若干消息和对象的封装为一个片段，针对这个片段可以实施不同的操作，从而来表示这个片段是选择、循环还是并行等各种非顺序执行。<br>
交互片段支持不同类型的操作符，从而实现不同的控制结构，典型的操作符有可选（opt）、选择（alt）、循环（loop）和并行（par）等。</p></blockquote> <p>11．什么是用例实现的参与类类图？</p> <blockquote><p>参与类类图是指与某个特定用例实现相关的类以及类之间的静态关系，表示为支持该用例实现行为所需要的分析类以及关系</p></blockquote> <p>12．什么是类的职责，如何定义职责？</p> <blockquote><p>职责是要求某个类的对象所要履行的行为契约，它说明了该对象能够对外提供哪些行为，在设计中将演化为类的一个或多个操作。可以从两个方面来定义类的职责。</p> <ol><li>从交互图中的消息获取职责；对于每一条消息，接收该消息的对象需要提供相应的职责来响应</li> <li>从非功能需求中获得其它职责</li></ol></blockquote> <p>13．对象间的链接和类间的关联关系有什么区别和联系？</p> <blockquote><p>链接是两个对象之间的语义联系，它允许消息从一个对象发送到另一个对象；关联关系则是类之间的一种结构化关系，是类之间的语义联系，表明类的对象之间存在着链接<br>
对象是由特定的类生成的，是类之间的链接也需要类之间的关系来生成</p></blockquote> <p>14．什么是多重性，如何理解类间的多重性定义？</p> <blockquote><p>多重性表示一个类的对象可能链接到所关联的类的多个对象上，这种“多少”即为关联角色的多重性，它表示一个整数的范围，通过多重性表达式来指明一组相关对象的可能个数<br>
需要从关联的另一端来理解多重性的定义，即表明另一端的一个对象可以与本方的多少个对象相链接</p></blockquote> <p>15．什么是关联类，它起到什么作用？</p> <blockquote><p>关联类是一种被附加到关联关系上的类，用来描述该关联关系自身所拥有的一些属性和行为<br>
当某些属于关联关系自身的特征信息无法被附加到关联两端的类时，就需要为该关联关系定义关联类</p></blockquote> <p>16．什么是聚合关系，聚合关系与关联关系、泛化关系有什么不同？</p> <blockquote><p>聚合关系是一种特殊的关联关系，除了拥有关联关系所有的基本特征外，两个关联的类还分别代表“整体”和“部分”，意味着整体包含部分<br>
与普通的关联关系相比，关联两端的类要多一层整体和部分的含义，而普通的关联关系并没有这层含义<br>
与泛化关系相比，关联是一种包含或拥有的关系，即整体包含或拥有部分；而泛化则是“是一种”的一般和特殊的关系，子类是一种特殊的父类</p></blockquote> <h3 id="应用题"><a href="#应用题" class="header-anchor">#</a> 应用题</h3> <p>1．某进行二手房交易的中介机构，拟开发一套辅助中介房屋销售系统，通过该系统实现以下业务。<br>
需要出售房屋的卖主与中介公司联系，公司会指定一名中介人帮助卖主建立房屋档案，房屋档案包括户型、价格、位置、入住时间、装修情况和照片等信息。该房屋档案和卖主的个人信息都会被长期保存起来。中介公司还可以协助卖主请专门的评估机构来评估房屋的实际价值，评估人利用该系统提供的房屋信息记录评估结论，评估结论包括参考报价、房屋特点、价格趋势等分析数据。<br>
需要购买房屋的买主可以与中介公司联系，由中介人帮助填写“购房需求”；也可以由自己通过该系统直接填写“购房需求”，购房需求包括户型、价格、位置等信息。中介人将会定期为这些买主发现满足大部分或者所有需求的房产，并将这些房产信息发送给潜在的买主，这些房产信息可能包括房屋的户型、大小、位置、报价和照片等数据。<br>
当买主选中了一处房产时，他可以通过系统对该房产进行报价。报价信息可以通过中介人手动传递给卖主，也可以由卖主主动通过该系统获得报价信息。卖主得到报价后可以进行还价或接受报价。当某处房产成交后，中介人需要通过该系统将交易信息导出到“财务应用系统”（该机构内部已有系统），财务经理可以通过财务应用系统获得相关的财务记录。<br>
请根据该系统的业务背景陈述，抽取系统中的实体类，以及类的属性和关系，并构造实体类类图。</p> <p><img src="/blog/assets/img/2021-03-24-17-05-20.54791d2e.png" alt=""></p> <p>2．[综合案例：员工考勤系统]在第4章已经完成的该系统用例模型基础上，完成分析过程。<br>
（1）简单描述系统的备选构架，并将分析过程所发现的类放入到相应的层次结构中。<br>
（2）针对系统的核心用例，完成用例分析工作，每个用例实现模型至少应包括：<br>
（2.1）描述基本路径的交互<br>
（2.2）用例实现的参与类类图<br>
（3）构造系统完整的实体类类图。<br>
3．[综合案例：医院预约挂号系统]在第4章已经完成的该系统用例模型基础上，完成分析过程。<br>
（1）简单描述系统的备选构架，并将分析过程所发现的类放入到相应的层次结构中。<br>
（2）针对系统的核心用例，完成用例分析工作，每个用例实现模型至少应包括：<br>
（2.1）描述基本路径的交互<br>
（2.2）用例实现的参与类类图<br>
（3）构造系统完整的实体类类图。<br>
(1)　典型方法如Coad/Yourdon的OOA和OOD方法、Booch方法、OMT方法、OOSE方法等。这些面向对象的方法是UML前身，采用了一些特定的建模语言和工具。感兴趣的读者可以参阅相关的软件工程书籍。<br>
(2)　 MSF（Microsoft Solution Framework，微软解决方案框架）是微软公司提出的一种产品开发方法，该方法将软件开发分为构思、计划、开发、稳定和部署5个阶段。其中计划阶段分为概念设计、逻辑设计和物理设计，分别对应需求、分析和设计过程；其需求阶段也推荐使用用例建模，分析设计也推荐使用UML模型。(3)　动态建模过程也称为行为建模，但其目标模型被称为交互模型更恰当。因为主要采用的是UML的顺序图和通信图等交互图来建模，而不是采用诸如活动图、状态图等的行为图建模。<br>
(4)　对于类似本书案例中的小规模系统，其分析类大约为10~30个，甚至更少。<br>
(5)　目前模式主要用于设计领域，有关设计模式的研究也比较成熟，读者也可以参考本书第7章的内容。分析模式的概念主要来自Martin Flowler的著作Analysis Patterns：Reusable Object Models，该书提出了一些典型的可复用的分析模式。此处有关分析模式的介绍也源自该著作，读者可以参阅该著作以了解更多细节。<br>
(6)　这里体现了为什么在用例建模时反复强调用例自身的完整性，只有相对独立且完整的用例，才能分析其内部机理，也才能够顺利地开展后续的分析设计工作。如果在前期过分细化用例，实际上是对用例内部的分析过程，而这个分析本身又不是面向对象的分析，而是功能分解式的分析。<br>
(7)　一般至少获取60%~80%的需求，而剩下的部分主要是那些支撑性需求，这些需求会在后续迭代中定义。当然，在这次需求迭代中也会进行一些简单的分析、设计，甚至实现系统原型等工作。<br>
(8)　如果定义了一个需要半年才能完成的迭代周期，而当该迭代周期完成后，发现所迭代的内容无法在后续迭代中得到有效的复用，那么这半年的工作可能都需要返工。这显然是不能接受的。因此，一般的迭代周期都不会太长，有些甚至只需要1周的时间。这样可以使得项目组及时评估自己的工作，从而可以对出现的问题做出快速反应。相对来说，策划一系列的小胜利和接受一些小的失误总要好一点；而策划一个巨大的胜利经常会导致灾难性的失败。<br>
(9)　为了保证图形的清晰，我们省略了多数架构层和内部包之间的依赖关系，以及相关子系统接口的定义。<br>
(10)　分析和设计阶段都需要定义用例实现，其含义相同，只是内部处理细节不同。<br>
(11)　Rational Rose虽然不支持UML 2建模，却支持≪use-case realization≫构造型，并可提供正确的图符。<br>
(12)　有关利用包图进行架构设计的细节，可以进一步参阅本书第8.2节的内容。(13)　可以采用某种对象访问技术，此处并未具体给出。如可以是XQuery、XPath等XML访问技术。<br>
(14)　参阅第8.4节，相关内容详细说明了定义设计机制的过程。<br>
(15)　本书中分析阶段类的名称都采用中文标注，以便于用户理解。在实际项目开发时，可根据项目组相关的命名规范来进行命名。此外，在实际项目中，类的名称一般也不会有“类”字这个后缀。<br>
(16)　控制类也可以采用其他后缀，如“××管理类”；或不采用后缀，如直接命名为“支付”类；从这个动词性质的类名（其他类基本上是名词，控制类一般是动名词）就可以看出该类是对支付业务处理的控制类。<br>
(17)　由于边界类和控制类比较容易确定，因此，对实体类的识别才是整个分析阶段的重点和难点，遗漏了实体类则意味着丢失了系统的数据和处理行为，不能满足需求。事实上，存在一些面向对象的方法在分析阶段就只关注实体类，而不考虑边界类和控制类。<br>
(18)　EA中使用new和delete两个单独的选项来表示创建和删除消息，与前文提到的create和destroy两个构造型的作用相同。<br>
(19)　在消息类型的可视化方面，Rose中某些消息的图示与UML 2的标准并不一致，其异步消息为半枝状箭头（即只有上面的斜线，没有下面的斜线箭头）。创建消息也没有单独的表示符号。<br>
(20)　严格来说，在分析交互期间所涉及的都是类的对象，而不是类；本书为了便于读者理解，仍采用类的概念，表明该类的所有对象均适用，而不特指某个具体对象。<br>
(21)　一种职责分配模式，将在第7章中再展开介绍，这种模式在设计时用得更多。<br>
(22)　方案1和方案2相对比较简单，在分析阶段经常选择这两种方案。编者更倾向于方案2，可便于设计阶段统一处理这类问题。而在设计阶段则需要考虑控制类的内聚性及类之间的耦合关系，因而选择方案3。<br>
(23)　实际实现时是服务员在主界面上选择“预订房间”功能。因此可以考虑定义一个主界面的边界类，服务员向该边界类发送预订房间的消息，再由主界面创建预订房间界面类（ReservationUI）。本书中的所有案例都没有考虑这一个主界面类，因此，基本流的第一句话都没有在顺序图中体现。<br>
(24)　由于图5-38较宽，为了图形的整体效果，图中最上面一排对象并没有放在一个水平线上，而是交错放置，以便能够完整地显示对象名和类名。<br>
(25)　本书如此处理的目的是屏蔽用例关系给分析过程带来的复杂性，以便于集中讲解用例分析的基本方法和技巧；实际项目中可以在保留这些关系的基础上定义迭代，并进行分析。而有关这些关系的处理则在本节单独讲解，读者也可根据本节所描述的方法在保留用例关系的基础上重新完成“旅游申请系统”的分析过程。<br>
(26)　有关通信图的相关细节和进一步的使用方法可参见第6.6.3小节。<br>
(27)　注意是同一个类的不同对象，而不是同一个对象之间存在链接。要和通信图中的自反消息（是同一个对象自己给自己发消息，这个对象自身存在自反链接）区分开，如图5-56中“申请界面类”存在自反链接，但该类并不存在自反关联。因为对象自身是可以发消息给自己的，而不需要关联关系的支持；但是不同的对象就不能直接发消息，必须要有关系的支持。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/21/2021, 1:25:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/开发基础/面向对象需求分析与UML建模/4用例建模.html" class="prev">
        用例建模
      </a></span> <span class="next"><a href="/blog/开发基础/面向对象需求分析与UML建模/6面向对象的设计原则.html">
        面向对象的设计原则
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.5a38db11.js" defer></script><script src="/blog/assets/js/3.21e2e031.js" defer></script><script src="/blog/assets/js/5.0760b076.js" defer></script>
  </body>
</html>
