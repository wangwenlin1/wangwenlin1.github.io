<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>方法 | 一名GO+PHP工程师</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b3aba94c.css" as="style"><link rel="preload" href="/blog/assets/js/app.5a38db11.js" as="script"><link rel="preload" href="/blog/assets/js/3.21e2e031.js" as="script"><link rel="preload" href="/blog/assets/js/92.4093acc4.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.cc3bb372.js"><link rel="prefetch" href="/blog/assets/js/100.35b5db36.js"><link rel="prefetch" href="/blog/assets/js/101.a70b97e2.js"><link rel="prefetch" href="/blog/assets/js/102.30af4d63.js"><link rel="prefetch" href="/blog/assets/js/103.c5c5130e.js"><link rel="prefetch" href="/blog/assets/js/104.161b590d.js"><link rel="prefetch" href="/blog/assets/js/105.eaae1ece.js"><link rel="prefetch" href="/blog/assets/js/106.028ce766.js"><link rel="prefetch" href="/blog/assets/js/107.c9b230ac.js"><link rel="prefetch" href="/blog/assets/js/108.a5880443.js"><link rel="prefetch" href="/blog/assets/js/109.bab44539.js"><link rel="prefetch" href="/blog/assets/js/11.ef5dbacc.js"><link rel="prefetch" href="/blog/assets/js/110.7ba602f1.js"><link rel="prefetch" href="/blog/assets/js/111.2b0b0a78.js"><link rel="prefetch" href="/blog/assets/js/112.6b9220f5.js"><link rel="prefetch" href="/blog/assets/js/113.6a2724aa.js"><link rel="prefetch" href="/blog/assets/js/114.ac347ea2.js"><link rel="prefetch" href="/blog/assets/js/115.17c6c526.js"><link rel="prefetch" href="/blog/assets/js/116.1fd8cdf3.js"><link rel="prefetch" href="/blog/assets/js/117.193b54e8.js"><link rel="prefetch" href="/blog/assets/js/118.8a3e18a9.js"><link rel="prefetch" href="/blog/assets/js/119.2a5bb73a.js"><link rel="prefetch" href="/blog/assets/js/12.2003a6c5.js"><link rel="prefetch" href="/blog/assets/js/120.edb5435e.js"><link rel="prefetch" href="/blog/assets/js/121.6e61cfa4.js"><link rel="prefetch" href="/blog/assets/js/122.8ce24886.js"><link rel="prefetch" href="/blog/assets/js/123.beccf42c.js"><link rel="prefetch" href="/blog/assets/js/124.416ddc09.js"><link rel="prefetch" href="/blog/assets/js/125.7be39e4f.js"><link rel="prefetch" href="/blog/assets/js/126.49439b56.js"><link rel="prefetch" href="/blog/assets/js/127.7d06eb7f.js"><link rel="prefetch" href="/blog/assets/js/128.9b247099.js"><link rel="prefetch" href="/blog/assets/js/129.6503c09f.js"><link rel="prefetch" href="/blog/assets/js/13.93951a43.js"><link rel="prefetch" href="/blog/assets/js/130.3fa988b7.js"><link rel="prefetch" href="/blog/assets/js/131.f93ef260.js"><link rel="prefetch" href="/blog/assets/js/132.7dca0041.js"><link rel="prefetch" href="/blog/assets/js/133.286b95ad.js"><link rel="prefetch" href="/blog/assets/js/134.88627057.js"><link rel="prefetch" href="/blog/assets/js/135.a28b714b.js"><link rel="prefetch" href="/blog/assets/js/136.fba0a306.js"><link rel="prefetch" href="/blog/assets/js/137.5540419d.js"><link rel="prefetch" href="/blog/assets/js/138.82fb7775.js"><link rel="prefetch" href="/blog/assets/js/139.787b1320.js"><link rel="prefetch" href="/blog/assets/js/14.379e0027.js"><link rel="prefetch" href="/blog/assets/js/140.b68497e2.js"><link rel="prefetch" href="/blog/assets/js/141.cd76190b.js"><link rel="prefetch" href="/blog/assets/js/142.8e56d4f0.js"><link rel="prefetch" href="/blog/assets/js/143.23971a8d.js"><link rel="prefetch" href="/blog/assets/js/144.8c41b407.js"><link rel="prefetch" href="/blog/assets/js/145.95b58ec4.js"><link rel="prefetch" href="/blog/assets/js/146.18132cf9.js"><link rel="prefetch" href="/blog/assets/js/147.8275026a.js"><link rel="prefetch" href="/blog/assets/js/148.cc2257d6.js"><link rel="prefetch" href="/blog/assets/js/149.a98d647c.js"><link rel="prefetch" href="/blog/assets/js/15.5376294f.js"><link rel="prefetch" href="/blog/assets/js/150.7360f0a5.js"><link rel="prefetch" href="/blog/assets/js/151.0cf39bd7.js"><link rel="prefetch" href="/blog/assets/js/152.6f7d01ad.js"><link rel="prefetch" href="/blog/assets/js/153.f6075040.js"><link rel="prefetch" href="/blog/assets/js/154.12eeb9b2.js"><link rel="prefetch" href="/blog/assets/js/155.65f03a29.js"><link rel="prefetch" href="/blog/assets/js/156.d2f6d50d.js"><link rel="prefetch" href="/blog/assets/js/157.f4384a9b.js"><link rel="prefetch" href="/blog/assets/js/158.34747ec7.js"><link rel="prefetch" href="/blog/assets/js/159.410bff01.js"><link rel="prefetch" href="/blog/assets/js/16.abdf559d.js"><link rel="prefetch" href="/blog/assets/js/160.53124933.js"><link rel="prefetch" href="/blog/assets/js/161.0ab0763e.js"><link rel="prefetch" href="/blog/assets/js/162.39021ec7.js"><link rel="prefetch" href="/blog/assets/js/163.596b82cf.js"><link rel="prefetch" href="/blog/assets/js/164.cbd2db78.js"><link rel="prefetch" href="/blog/assets/js/165.6e6c3d3a.js"><link rel="prefetch" href="/blog/assets/js/166.5bcaa3dd.js"><link rel="prefetch" href="/blog/assets/js/167.b4296d08.js"><link rel="prefetch" href="/blog/assets/js/168.27dc81ce.js"><link rel="prefetch" href="/blog/assets/js/169.661c763c.js"><link rel="prefetch" href="/blog/assets/js/17.8b47c823.js"><link rel="prefetch" href="/blog/assets/js/170.e41001f5.js"><link rel="prefetch" href="/blog/assets/js/171.0724bbd4.js"><link rel="prefetch" href="/blog/assets/js/172.2d5b541f.js"><link rel="prefetch" href="/blog/assets/js/173.41d6e737.js"><link rel="prefetch" href="/blog/assets/js/174.bccb9fa6.js"><link rel="prefetch" href="/blog/assets/js/175.b1a13486.js"><link rel="prefetch" href="/blog/assets/js/176.6e26a58e.js"><link rel="prefetch" href="/blog/assets/js/177.67fa30a9.js"><link rel="prefetch" href="/blog/assets/js/178.7f4bf5e6.js"><link rel="prefetch" href="/blog/assets/js/18.6a619898.js"><link rel="prefetch" href="/blog/assets/js/19.ea80b1e1.js"><link rel="prefetch" href="/blog/assets/js/2.04feeb4a.js"><link rel="prefetch" href="/blog/assets/js/20.77762601.js"><link rel="prefetch" href="/blog/assets/js/21.656ab41e.js"><link rel="prefetch" href="/blog/assets/js/22.5922a16f.js"><link rel="prefetch" href="/blog/assets/js/23.41929ef9.js"><link rel="prefetch" href="/blog/assets/js/24.3b850e15.js"><link rel="prefetch" href="/blog/assets/js/25.aade9e50.js"><link rel="prefetch" href="/blog/assets/js/26.36c6a527.js"><link rel="prefetch" href="/blog/assets/js/27.907a8228.js"><link rel="prefetch" href="/blog/assets/js/28.cc2bee0d.js"><link rel="prefetch" href="/blog/assets/js/29.52c7bfa4.js"><link rel="prefetch" href="/blog/assets/js/30.f034dd77.js"><link rel="prefetch" href="/blog/assets/js/31.edcef4fa.js"><link rel="prefetch" href="/blog/assets/js/32.6735d3e7.js"><link rel="prefetch" href="/blog/assets/js/33.28f8dc69.js"><link rel="prefetch" href="/blog/assets/js/34.8a729d66.js"><link rel="prefetch" href="/blog/assets/js/35.920cdf75.js"><link rel="prefetch" href="/blog/assets/js/36.15f2a36b.js"><link rel="prefetch" href="/blog/assets/js/37.5b03bd21.js"><link rel="prefetch" href="/blog/assets/js/38.fed1555d.js"><link rel="prefetch" href="/blog/assets/js/39.68d965cd.js"><link rel="prefetch" href="/blog/assets/js/4.644e7959.js"><link rel="prefetch" href="/blog/assets/js/40.069924f4.js"><link rel="prefetch" href="/blog/assets/js/41.a44d976c.js"><link rel="prefetch" href="/blog/assets/js/42.47caadd3.js"><link rel="prefetch" href="/blog/assets/js/43.b1eb7b31.js"><link rel="prefetch" href="/blog/assets/js/44.96773f8a.js"><link rel="prefetch" href="/blog/assets/js/45.328fda2a.js"><link rel="prefetch" href="/blog/assets/js/46.24f71020.js"><link rel="prefetch" href="/blog/assets/js/47.96df34c4.js"><link rel="prefetch" href="/blog/assets/js/48.b0bfea08.js"><link rel="prefetch" href="/blog/assets/js/49.3dac2a21.js"><link rel="prefetch" href="/blog/assets/js/5.0760b076.js"><link rel="prefetch" href="/blog/assets/js/50.97f9d2b0.js"><link rel="prefetch" href="/blog/assets/js/51.29fb5c68.js"><link rel="prefetch" href="/blog/assets/js/52.d2042f8d.js"><link rel="prefetch" href="/blog/assets/js/53.02c82b26.js"><link rel="prefetch" href="/blog/assets/js/54.667f483f.js"><link rel="prefetch" href="/blog/assets/js/55.b6b1e0e7.js"><link rel="prefetch" href="/blog/assets/js/56.bd954c20.js"><link rel="prefetch" href="/blog/assets/js/57.45722d8c.js"><link rel="prefetch" href="/blog/assets/js/58.17cd106d.js"><link rel="prefetch" href="/blog/assets/js/59.51661424.js"><link rel="prefetch" href="/blog/assets/js/6.d309aec3.js"><link rel="prefetch" href="/blog/assets/js/60.18a9a452.js"><link rel="prefetch" href="/blog/assets/js/61.819ab903.js"><link rel="prefetch" href="/blog/assets/js/62.24bf6999.js"><link rel="prefetch" href="/blog/assets/js/63.2f87f55d.js"><link rel="prefetch" href="/blog/assets/js/64.68cd3b45.js"><link rel="prefetch" href="/blog/assets/js/65.7fe0d182.js"><link rel="prefetch" href="/blog/assets/js/66.948be4c4.js"><link rel="prefetch" href="/blog/assets/js/67.2522194c.js"><link rel="prefetch" href="/blog/assets/js/68.0a66e8af.js"><link rel="prefetch" href="/blog/assets/js/69.07a744c4.js"><link rel="prefetch" href="/blog/assets/js/7.073a2745.js"><link rel="prefetch" href="/blog/assets/js/70.c0e92ba6.js"><link rel="prefetch" href="/blog/assets/js/71.97a4d551.js"><link rel="prefetch" href="/blog/assets/js/72.78fc6941.js"><link rel="prefetch" href="/blog/assets/js/73.3e3efdc5.js"><link rel="prefetch" href="/blog/assets/js/74.cff95a30.js"><link rel="prefetch" href="/blog/assets/js/75.6c4af1f1.js"><link rel="prefetch" href="/blog/assets/js/76.96c205c1.js"><link rel="prefetch" href="/blog/assets/js/77.31c8dd27.js"><link rel="prefetch" href="/blog/assets/js/78.41729cec.js"><link rel="prefetch" href="/blog/assets/js/79.12735350.js"><link rel="prefetch" href="/blog/assets/js/8.5e05a8d5.js"><link rel="prefetch" href="/blog/assets/js/80.e5005d72.js"><link rel="prefetch" href="/blog/assets/js/81.04f50a1e.js"><link rel="prefetch" href="/blog/assets/js/82.db879ca5.js"><link rel="prefetch" href="/blog/assets/js/83.e89b8863.js"><link rel="prefetch" href="/blog/assets/js/84.07410b58.js"><link rel="prefetch" href="/blog/assets/js/85.d46c8682.js"><link rel="prefetch" href="/blog/assets/js/86.3869d59e.js"><link rel="prefetch" href="/blog/assets/js/87.e7860b15.js"><link rel="prefetch" href="/blog/assets/js/88.2b183553.js"><link rel="prefetch" href="/blog/assets/js/89.36e67a82.js"><link rel="prefetch" href="/blog/assets/js/9.8a6a0670.js"><link rel="prefetch" href="/blog/assets/js/90.acd5023c.js"><link rel="prefetch" href="/blog/assets/js/91.d1662d38.js"><link rel="prefetch" href="/blog/assets/js/93.f09d7ba1.js"><link rel="prefetch" href="/blog/assets/js/94.1e2891fe.js"><link rel="prefetch" href="/blog/assets/js/95.83afadb6.js"><link rel="prefetch" href="/blog/assets/js/96.85084d66.js"><link rel="prefetch" href="/blog/assets/js/97.16a7a60a.js"><link rel="prefetch" href="/blog/assets/js/98.a84fee2e.js"><link rel="prefetch" href="/blog/assets/js/99.f9452cba.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b3aba94c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">一名GO+PHP工程师</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述" class="sidebar-heading clickable open"><span>Go类型系统</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述.html" class="sidebar-link">Go类型系统概述</a></li><li><a href="/blog/开发基础/GO/Go类型系统/2指针.html" class="sidebar-link">指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/3结构体.html" class="sidebar-link">结构体</a></li><li><a href="/blog/开发基础/GO/Go类型系统/4值部.html" class="sidebar-link">值部</a></li><li><a href="/blog/开发基础/GO/Go类型系统/5数组、切片和映射.html" class="sidebar-link">数组、切片和映射</a></li><li><a href="/blog/开发基础/GO/Go类型系统/6通道.html" class="sidebar-link">通道</a></li><li><a href="/blog/开发基础/GO/Go类型系统/7方法.html" class="active sidebar-link">方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/7方法.html#方法声明" class="sidebar-link">方法声明</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/7方法.html#每个方法对应着一个隐式声明的函数" class="sidebar-link">每个方法对应着一个隐式声明的函数</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/7方法.html#为指针类型属主隐式声明的方法" class="sidebar-link">为指针类型属主隐式声明的方法</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/7方法.html#方法原型-method-prototype-和方法集-method-set" class="sidebar-link">方法原型（method prototype）和方法集（method set）</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/7方法.html#方法值和方法调用" class="sidebar-link">方法值和方法调用</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/7方法.html#属主参数的传参是一个值复制过程" class="sidebar-link">属主参数的传参是一个值复制过程</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/7方法.html#如何决定一个方法声明使用值类型属主还是指针类型属主" class="sidebar-link">如何决定一个方法声明使用值类型属主还是指针类型属主？</a></li></ul></li><li><a href="/blog/开发基础/GO/Go类型系统/8接口.html" class="sidebar-link">接口</a></li><li><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html" class="sidebar-link">类型内嵌</a></li><li><a href="/blog/开发基础/GO/Go类型系统/10非类型安全指针.html" class="sidebar-link">非类型安全指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/11泛型.html" class="sidebar-link">泛型</a></li><li><a href="/blog/开发基础/GO/Go类型系统/12反射.html" class="sidebar-link">反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍" class="sidebar-heading clickable"><span>Go编程入门</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍.html" class="sidebar-link">程序源代码基本元素介绍</a></li><li><a href="/blog/开发基础/GO/Go编程入门/2关键字和标识符.html" class="sidebar-link">关键字和标识符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/3基本类型和它们的字面量表示.html" class="sidebar-link">基本类型和它们的字面量表示</a></li><li><a href="/blog/开发基础/GO/Go编程入门/4常量和变量.html" class="sidebar-link">常量和变量</a></li><li><a href="/blog/开发基础/GO/Go编程入门/5运算操作符.html" class="sidebar-link">运算操作符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/6函数声明和调用.html" class="sidebar-link">函数声明和调用</a></li><li><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html" class="sidebar-link">代码包和包引入</a></li><li><a href="/blog/开发基础/GO/Go编程入门/8表达式、语句和简单语句.html" class="sidebar-link">表达式、语句和简单语句</a></li><li><a href="/blog/开发基础/GO/Go编程入门/9基本流程控制语法.html" class="sidebar-link">基本流程控制语法</a></li><li><a href="/blog/开发基础/GO/Go编程入门/10协程、延迟函数调用、以及恐慌和恢复.html" class="sidebar-link">协程、延迟函数调用、以及恐慌和恢复</a></li><li><a href="/blog/开发基础/GO/Go编程入门/GO官方链接工具.html" class="sidebar-link">GO官方链接工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/其他文章/Go技巧" class="sidebar-heading clickable"><span>其他文章</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/其他文章/Go技巧.html" class="sidebar-link">Go技巧</a></li><li><a href="/blog/开发基础/GO/其他文章/Go细节.html" class="sidebar-link">Go细节</a></li><li><a href="/blog/开发基础/GO/其他文章/Go问答.html" class="sidebar-link">Go问答</a></li><li><a href="/blog/开发基础/GO/其他文章/命令-mod.html" class="sidebar-link">命令-mod</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Golang的time.NewTimer单次定时器使用案例.html" class="sidebar-link">基础-Golang的time. NewTimer单次定时器使用案例</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go中的nil.html" class="sidebar-link">Go中的 nil</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go代码断行规则.html" class="sidebar-link">Go代码断行规则</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-表达式估值顺序规则.html" class="sidebar-link">表达式估值顺序规则</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/学习资料" class="sidebar-heading clickable"><span>GO</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/学习资料.html" class="sidebar-link">教学书籍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/并发编程/1并发同步概述" class="sidebar-heading clickable"><span>并发编程</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/并发编程/1并发同步概述.html" class="sidebar-link">并发同步概述</a></li><li><a href="/blog/开发基础/GO/并发编程/2通道用例大全.html" class="sidebar-link">通道用例大全</a></li><li><a href="/blog/开发基础/GO/并发编程/3如何优雅地关闭通道.html" class="sidebar-link">如何优雅地关闭通道</a></li><li><a href="/blog/开发基础/GO/并发编程/4其它并发同步技术.html" class="sidebar-link">sync 标准库包中提供的并发同步技术</a></li><li><a href="/blog/开发基础/GO/并发编程/5原子操作 .html" class="sidebar-link">sync/atomic 标准库包中提供的原子操作</a></li><li><a href="/blog/开发基础/GO/并发编程/6Go中的内存顺序保证.html" class="sidebar-link">Go中的内存顺序保证</a></li><li><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html" class="sidebar-link">一些常见并发编程错误</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境" class="sidebar-heading clickable"><span>开发环境搭建</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境.html" class="sidebar-link">Docker和VS Code的Go开发环境</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h1> <p>Go支持一些面向对象编程特性，方法是这些所支持的特性之一。 本篇文章将介绍在Go中和方法相关的各种概念。</p> <h2 id="方法声明"><a href="#方法声明" class="header-anchor">#</a> 方法声明</h2> <p>在Go中，我们可以为类型 <code>T</code> 和 <code>*T</code> 显式地声明一个方法，其中类型 <code>T</code> 必须满足四个条件：</p> <ol><li><code>T</code>必须是一个<a href="https://gfw.go101.org/article/type-system-overview.html#non-defined-type" target="_blank" rel="noopener noreferrer">定义类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>；</li> <li><code>T</code>必须和此方法声明定义在同一个代码包中；</li> <li><code>T</code>不能是一个指针类型；</li> <li><code>T</code>不能是一个接口类型。接口类型将在<a href="https://gfw.go101.org/article/interface.html" target="_blank" rel="noopener noreferrer">下一篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中讲解。</li></ol> <p>类型 <code>T</code> 和 <code>*T</code> 称为它们各自的方法的属主类型（receiver type）。 类型 <code>T</code> 被称作为类型 <code>T</code> 和 <code>*T</code> 声明的所有方法的属主基类型（receiver base type）。</p> <p>注意：我们也可以为满足上列条件的类型 <code>T</code> 和 <code>*T</code> 的<a href="https://gfw.go101.org/article/type-system-overview.html#type-alias" target="_blank" rel="noopener noreferrer">别名<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>声明方法。 这样做的效果和直接为类型 <code>T</code> 和 <code>*T</code> 声明方法是一样的。</p> <p>如果我们为某个类型声明了一个方法，以后我们可以说此类型拥有此方法。</p> <p>从上面列出的条件，我们得知我们不能为下列类型（显式地）声明方法：</p> <ul><li>内置基本类型。比如<code>int</code>和<code>string</code>。 因为这些类型声明在内置<code>builtin</code>标准包中，而我们不能在标准包中声明方法。</li> <li>接口类型。但是接口类型可以拥有方法。详见<a href="https://gfw.go101.org/article/interface.html" target="_blank" rel="noopener noreferrer">下一篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li>除了满足上面条件的形如<code>*T</code>的指针类型之外的非定义组合类型。</li></ul> <p>一个方法声明和一个函数声明很相似，但是比函数声明多了一个额外的参数声明部分。 此额外的参数声明部分只能含有一个类型为此方法的属主类型的参数，此参数称为此方法声明的属主参数（receiver parameter）。 此属主参数声明必须包裹在一对小括号 <code>()</code> 之中。 此属主参数声明部分必须处于 <code>func</code> 关键字和方法名之间。</p> <p>下面是一个方法声明的例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token comment">// Age和int是两个不同的类型。我们不能为int和*int</span>
<span class="token comment">// 类型声明方法，但是可以为Age和*Age类型声明方法。</span>
<span class="token keyword">type</span> Age <span class="token builtin">int</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>age Age<span class="token punctuation">)</span> <span class="token function">LargerThan</span><span class="token punctuation">(</span>a Age<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> age <span class="token operator">&gt;</span> a
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>age <span class="token operator">*</span>Age<span class="token punctuation">)</span> <span class="token function">Increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">*</span>age<span class="token operator">++</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为自定义的函数类型FilterFunc声明方法。</span>
<span class="token keyword">type</span> FilterFunc <span class="token keyword">func</span><span class="token punctuation">(</span>in <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ff FilterFunc<span class="token punctuation">)</span> <span class="token function">Filte</span><span class="token punctuation">(</span>in <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">ff</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为自定义的映射类型StringSet声明方法。</span>
<span class="token keyword">type</span> StringSet <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ss StringSet<span class="token punctuation">)</span> <span class="token function">Has</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token boolean">_</span><span class="token punctuation">,</span> present <span class="token operator">:=</span> ss<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
	<span class="token keyword">return</span> present
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ss StringSet<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	ss<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ss StringSet<span class="token punctuation">)</span> <span class="token function">Remove</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">delete</span><span class="token punctuation">(</span>ss<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为自定义的结构体类型Book和它的指针类型*Book声明方法。</span>
<span class="token keyword">type</span> Book <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	pages <span class="token builtin">int</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b Book<span class="token punctuation">)</span> <span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> b<span class="token punctuation">.</span>pages
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token function">SetPages</span><span class="token punctuation">(</span>pages <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b<span class="token punctuation">.</span>pages <span class="token operator">=</span> pages
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的例子可以看出，我们可以为各种种类（kind）的类型声明方法，而不仅仅是结构体类型。</p> <p>在很多其它面向对象的编程语言中，属主参数名总是为隐式声明的 <code>this</code> 或者 <code>self</code> 。这样的名称不推荐在Go编程中使用。</p> <p>指针类型的属主参数称为*<strong>指针类型属主*</strong>，非指针类型的属主参数称为*<strong>值类型属主*</strong>。 在大多数情况下，我个人非常反对将***指针*<strong>和</strong>*值***这两个术语用做对立面，但是在这里，我并不反对这么用，原因将在下面谈及。</p> <p>方法名可以是空标识符 <code>_</code> 。一个类型可以拥有若干名可以是空标识符的方法，但是这些方法无法被调用。 只有导出的方法才可以在其它代码包中调用。 方法调用将在后面的一节中介绍。</p> <h2 id="每个方法对应着一个隐式声明的函数"><a href="#每个方法对应着一个隐式声明的函数" class="header-anchor">#</a> 每个方法对应着一个隐式声明的函数</h2> <p>对每个方法声明，编译器将自动隐式声明一个相对应的函数。 比如对于上一节的例子中为类型 <code>Book</code> 和 <code>*Book</code> 声明的两个方法，编译器将自动声明下面的两个函数：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> Book<span class="token punctuation">.</span><span class="token function">Pages</span><span class="token punctuation">(</span>b Book<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> b<span class="token punctuation">.</span>pages <span class="token comment">// 此函数体和Book类型的Pages方法体一样</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>Book<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetPages</span><span class="token punctuation">(</span>b <span class="token operator">*</span>Book<span class="token punctuation">,</span> pages <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b<span class="token punctuation">.</span>pages <span class="token operator">=</span> pages <span class="token comment">// 此函数体和*Book类型的SetPages方法体一样</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的两个隐式函数声明中，它们各自对应的方法声明的属主参数声明被插入到了普通参数声明的第一位。 它们的函数体和各自对应的显式方法的方法体是一样的。</p> <p>两个隐式函数名 <code>Book. Pages</code> 和 <code>(*Book). SetPages</code> 都是 <code>aType. MethodName</code> 这种形式的。 我们不能显式声明名称为这种形式的函数，因为这种形式不属于合法标识符。这样的函数只能由编译器隐式声明。 但是我们可以在代码中调用这些隐式声明的函数：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> Book <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	pages <span class="token builtin">int</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b Book<span class="token punctuation">)</span> <span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> b<span class="token punctuation">.</span>pages
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token function">SetPages</span><span class="token punctuation">(</span>pages <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b<span class="token punctuation">.</span>pages <span class="token operator">=</span> pages
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> book Book
	<span class="token comment">// 调用这两个隐式声明的函数。</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>Book<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetPages</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Book<span class="token punctuation">.</span><span class="token function">Pages</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123</span>
<span class="token punctuation">}</span>
</code></pre></div><p>事实上，在隐式声明上述两个函数的同时，编译器也将改写这两个函数对应的显式方法（至少，我们可以这样认为），让这两个方法在体内直接调用这两个隐式函数：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>b Book<span class="token punctuation">)</span> <span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> Book<span class="token punctuation">.</span><span class="token function">pages</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token function">SetPages</span><span class="token punctuation">(</span>pages <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>Book<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetPages</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> pages<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="为指针类型属主隐式声明的方法"><a href="#为指针类型属主隐式声明的方法" class="header-anchor">#</a> 为指针类型属主隐式声明的方法</h2> <p>对每一个为值类型属主 <code>T</code> 声明的方法，编译器将自动隐式地为其对应的指针类型属主 <code>*T</code> 声明一个相应的同名方法。 以上面的为类型 <code>Book</code> 声明的 <code>Pages</code> 方法为例，编译器将自动为类型 <code>*Book</code> 声明一个同名方法：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> Book<span class="token punctuation">.</span><span class="token function">Pages</span><span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token comment">// 调用上节中隐式声明的函数</span>
<span class="token punctuation">}</span>
</code></pre></div><p>正因为如此，我并不排斥使用值类型属主这个术语做为指针类型属主这个术语的对立面。 毕竟，当我们为一个非指针类型显式声明一个方法的时候，事实上两个方法被声明了。 一个方法是为非指针类型显式声明的，另一个是为指针类型隐式声明的。</p> <p>上一节已经提到了，每一个方法对应着一个编译器隐式声明的函数。 所以对于刚提到的隐式方法，编译器也将隐式声明一个相应的函数：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>Book<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Pages</span><span class="token punctuation">(</span>b <span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> Book<span class="token punctuation">.</span><span class="token function">Pages</span><span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>换句话说，对于每一个为值类型属主显式声明的方法，同时将有一个隐式方法和两个隐式函数被自动声明。</p> <h2 id="方法原型-method-prototype-和方法集-method-set"><a href="#方法原型-method-prototype-和方法集-method-set" class="header-anchor">#</a> 方法原型（method prototype）和方法集（method set）</h2> <p>一个方法原型可以看作是一个不带 <code>func</code> 关键字的<a href="https://gfw.go101.org/article/function.html#prototype" target="_blank" rel="noopener noreferrer">函数原型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。 我们可以把每个方法声明看作是由一个 <code>func</code> 关键字、一个属主参数声明部分、一个方法原型和一个方法体组成。</p> <p>比如，上面的例子中的 <code>Pages</code> 和 <code>SetPages</code> 的原型如下：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token function">SetPages</span><span class="token punctuation">(</span>pages <span class="token builtin">int</span><span class="token punctuation">)</span>
</code></pre></div><p>每个类型都有个方法集。一个非接口类型的方法集由所有为它声明的（不管是显式的还是隐式的，但不包含方法名为空标识符的）方法的原型组成。 接口类型将在<a href="https://gfw.go101.org/article/interface.html" target="_blank" rel="noopener noreferrer">下一篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>详述。</p> <p>比如，在上面的例子中， <code>Book</code> 类型的方法集为：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
</code></pre></div><p>而 <code>*Book</code> 类型的方法集为：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token function">SetPages</span><span class="token punctuation">(</span>pages <span class="token builtin">int</span><span class="token punctuation">)</span>
</code></pre></div><p>方法集中的方法原型的次序并不重要。</p> <p>对于一个方法集，如果其中的每个方法原型都处于另一个方法集中，则我们说前者方法集为后者（即另一个）方法集的子集，后者为前者的超集。 如果两个方法集互为子集（或超集），则这两个方法集必等价。</p> <p>给定一个类型 <code>T</code> ，假设它既不是一个指针类型也不是一个接口类型，因为上一节中提到的原因，类型 <code>T</code> 的方法集总是类型 <code>*T</code> 的方法集的子集。 比如，在上面的例子中， <code>Book</code> 类型的方法集为 <code>*Book</code> 类型的方法集的子集。</p> <p>请注意：<strong>不同代码包中的同名非导出方法将总被认为是不同名的。</strong></p> <p>方法集在Go中的多态特性中扮演着重要的角色。多态将在<a href="https://gfw.go101.org/article/interface.html" target="_blank" rel="noopener noreferrer">下一篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中讲解。</p> <p>下列类型的方法集总为空：</p> <ul><li>内置基本类型；</li> <li>定义的指针类型；</li> <li>基类型为指针类型或者接口类型的指针类型；</li> <li>非定义的数组/切片/映射/函数/通道类型。</li></ul> <h2 id="方法值和方法调用"><a href="#方法值和方法调用" class="header-anchor">#</a> 方法值和方法调用</h2> <p>方法事实上是特殊的函数。方法也常被称为成员函数。 当一个类型拥有一个方法，则此类型的每个值将拥有一个不可修改的函数类型的成员（类似于结构体的字段）。 此成员的名称为此方法名，它的类型和此方法的声明中不包括属主部分的函数声明的类型一致。 一个值的成员函数也可以称为此值的方法。</p> <p>一个方法调用其实是调用了一个值的成员函数。假设一个值 <code>v</code> 有一个名为 <code>m</code> 的方法，则此方法可以用选择器语法形式 <code>v.m</code> 来表示。</p> <p>下面这个例子展示了如何调用为 <code>Book</code> 和 <code>*Book</code> 类型声明的方法：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> Book <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	pages <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b Book<span class="token punctuation">)</span> <span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> b<span class="token punctuation">.</span>pages
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b <span class="token operator">*</span>Book<span class="token punctuation">)</span> <span class="token function">SetPages</span><span class="token punctuation">(</span>pages <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b<span class="token punctuation">.</span>pages <span class="token operator">=</span> pages
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> book Book

	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%T \n&quot;</span><span class="token punctuation">,</span> book<span class="token punctuation">.</span>Pages<span class="token punctuation">)</span>       <span class="token comment">// func() int</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%T \n&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">)</span><span class="token punctuation">.</span>SetPages<span class="token punctuation">)</span> <span class="token comment">// func(int)</span>
	<span class="token comment">// &amp;book值有一个隐式方法Pages。</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%T \n&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">)</span><span class="token punctuation">.</span>Pages<span class="token punctuation">)</span>    <span class="token comment">// func() int</span>

	<span class="token comment">// 调用这三个方法。</span>
	<span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetPages</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
	book<span class="token punctuation">.</span><span class="token function">SetPages</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>           <span class="token comment">// 等价于上一行</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span><span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 123</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>book<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Pages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 123</span>
<span class="token punctuation">}</span>
</code></pre></div><p><em>（和C语言不同，Go中没有 <code>-&gt;</code> 操作符用来通过指针属主值来调用方法。 <code>(&amp;book)-&gt;SetPages(123)</code> 在Go中是非法的。）</em></p> <p>等一下，上例中的 <code>(&amp;book). SetPages(123)</code> 一行为什么可以被简化为 <code>book. SetPages(123)</code> 呢？ 毕竟，类型 <code>Book</code> 并不拥有一个 <code>SetPages</code> 方法。 啊哈，这可以看作是Go中为了让代码看上去更简洁而特别设计的语法糖。此语法糖只对可寻址的值类型的属主有效。 编译器会自动将 <code>book. SetPages(123)</code> 改写为 <code>(&amp;book). SetPages(123)</code> 。 但另一方面，我们应该总是认为 <code>aBookExpression. SetPages</code> 是一个合法的选择器（从语法层面讲），即使表达式 <code>aBookExpression</code> 被估值为一个不可寻址的 <code>Book</code> 值（在这种情况下， <code>aBookExpression. SetPages</code> 是一个无效但合法的选择器）。</p> <p>如上面刚提到的，当为一个类型声明了一个方法后，每个此类型的值将拥有一个和此方法同名的成员函数。 此类型的零值也不例外，不论此类型的零值是否用 <code>nil</code> 来表示。</p> <p>一个例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> StringSet <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ss StringSet<span class="token punctuation">)</span> <span class="token function">Has</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token boolean">_</span><span class="token punctuation">,</span> present <span class="token operator">:=</span> ss<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment">// 永不会产生恐慌，即使ss为nil。</span>
	<span class="token keyword">return</span> present
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Age <span class="token builtin">int</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>age <span class="token operator">*</span>Age<span class="token punctuation">)</span> <span class="token function">IsNil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> age <span class="token operator">==</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>age <span class="token operator">*</span>Age<span class="token punctuation">)</span> <span class="token function">Increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">*</span>age<span class="token operator">++</span> <span class="token comment">// 如果age是一个空指针，则此行将产生一个恐慌。</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">StringSet</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Has   <span class="token comment">// 不会产生恐慌</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>Age<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>IsNil    <span class="token comment">// 不会产生恐慌</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>Age<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Increase <span class="token comment">// 不会产生恐慌</span>

	<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">StringSet</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Has</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 不会产生恐慌</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>Age<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsNil</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">// 不会产生恐慌</span>

	<span class="token comment">// 下面这行将产生一个恐慌，但是此恐慌不是在调用方法的时</span>
	<span class="token comment">// 候产生的，而是在此方法体内解引用空指针的时候产生的。</span>
	<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>Age<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="属主参数的传参是一个值复制过程"><a href="#属主参数的传参是一个值复制过程" class="header-anchor">#</a> 属主参数的传参是一个值复制过程</h2> <p>和普通参数传参一样，属主参数的传参也是一个值复制过程。 所以，在方法体内对属主参数的<a href="https://gfw.go101.org/article/value-part.html" target="_blank" rel="noopener noreferrer">直接部分<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的修改将不会反映到方法体外。</p> <p>一个例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> Book <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	pages <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b Book<span class="token punctuation">)</span> <span class="token function">SetPages</span><span class="token punctuation">(</span>pages <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	b<span class="token punctuation">.</span>pages <span class="token operator">=</span> pages
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> b Book
	b<span class="token punctuation">.</span><span class="token function">SetPages</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>pages<span class="token punctuation">)</span> <span class="token comment">// 0</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另一个例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> Book <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	pages <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Books <span class="token punctuation">[</span><span class="token punctuation">]</span>Book

<span class="token keyword">func</span> <span class="token punctuation">(</span>books Books<span class="token punctuation">)</span> <span class="token function">Modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 对属主参数的间接部分的修改将反映到方法之外。</span>
	books<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pages <span class="token operator">=</span> <span class="token number">500</span>
	<span class="token comment">// 对属主参数的直接部分的修改不会反映到方法之外。</span>
	books <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>books<span class="token punctuation">,</span> Book<span class="token punctuation">{</span><span class="token number">789</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> books <span class="token operator">=</span> Books<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">456</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
	books<span class="token punctuation">.</span><span class="token function">Modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span> <span class="token comment">// [{500} {456}]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有点题外话，如果将上例中 <code>Modify</code> 方法中的两行代码次序调换，那么此方法中的两处修改都不能反映到此方法之外。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>books Books<span class="token punctuation">)</span> <span class="token function">Modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	books <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>books<span class="token punctuation">,</span> Book<span class="token punctuation">{</span><span class="token number">789</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	books<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pages <span class="token operator">=</span> <span class="token number">500</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> books <span class="token operator">=</span> Books<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">456</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
	books<span class="token punctuation">.</span><span class="token function">Modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span> <span class="token comment">// [{123} {456}]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这两处修改都不能反映到 <code>Modify</code> 方法之外的原因是 <code>append</code> 函数调用将开辟一块新的内存来存储它返回的结果切片的元素。 而此结果切片的前两个元素是属主参数切片的元素的副本。对此副本所做的修改不会反映到 <code>Modify</code> 方法之外。</p> <p>为了将此两处修改反映到 <code>Modify</code> 方法之外， <code>Modify</code> 方法的属主类型应该改为指针类型：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>books <span class="token operator">*</span>Books<span class="token punctuation">)</span> <span class="token function">Modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">*</span>books <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token operator">*</span>books<span class="token punctuation">,</span> Book<span class="token punctuation">{</span><span class="token number">789</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>books<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pages <span class="token operator">=</span> <span class="token number">500</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> books <span class="token operator">=</span> Books<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">123</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">456</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
	books<span class="token punctuation">.</span><span class="token function">Modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span> <span class="token comment">// [{500} {456} {789}]</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="如何决定一个方法声明使用值类型属主还是指针类型属主"><a href="#如何决定一个方法声明使用值类型属主还是指针类型属主" class="header-anchor">#</a> 如何决定一个方法声明使用值类型属主还是指针类型属主？</h2> <p>首先，从上一节中的例子，我们可以得知有时候我们必须在某些方法声明中使用指针类型属主。</p> <p>事实上，我们总可以在方法声明中使用指针类型属主而不会产生任何逻辑问题。 我们仅仅是为了程序效率考虑有时候才会在函数声明中使用值类型属主。</p> <p>对于值类型属主还是指针类型属主都可以接受的方法声明，下面列出了一些考虑因素：</p> <ul><li>太多的指针可能会增加垃圾回收器的负担。</li> <li>如果一个值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略。 指针类型都是小尺寸类型。 关于各种不同类型的尺寸，请阅读<a href="https://gfw.go101.org/article/value-copy-cost.html" target="_blank" rel="noopener noreferrer">值复制代价<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文。</li> <li>在并发场合下，同时调用值类型属主和指针类型属主方法比较易于产生数据竞争。</li> <li><code>sync</code>标准库包中的类型的值不应该被复制，所以如果一个结构体类型<a href="https://gfw.go101.org/article/type-embedding.html" target="_blank" rel="noopener noreferrer">内嵌<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>了这些类型，则不应该为这个结构体类型声明值类型属主的方法。</li></ul> <p>如果实在拿不定主意在一个方法声明中应该使用值类型属主还是指针类型属主，那么请使用指针类型属主。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/21/2021, 1:25:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/开发基础/GO/Go类型系统/6通道.html" class="prev">
        通道
      </a></span> <span class="next"><a href="/blog/开发基础/GO/Go类型系统/8接口.html">
        接口
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.5a38db11.js" defer></script><script src="/blog/assets/js/3.21e2e031.js" defer></script><script src="/blog/assets/js/92.4093acc4.js" defer></script>
  </body>
</html>
