<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一些常见并发编程错误 | 一名GO+PHP工程师</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/blog/assets/css/0.styles.e16ad0a6.css" as="style"><link rel="preload" href="/blog/assets/js/app.b472f60d.js" as="script"><link rel="preload" href="/blog/assets/js/3.21e2e031.js" as="script"><link rel="preload" href="/blog/assets/js/118.a54057c2.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.414eb148.js"><link rel="prefetch" href="/blog/assets/js/100.35b5db36.js"><link rel="prefetch" href="/blog/assets/js/101.a70b97e2.js"><link rel="prefetch" href="/blog/assets/js/102.30af4d63.js"><link rel="prefetch" href="/blog/assets/js/103.a362f49e.js"><link rel="prefetch" href="/blog/assets/js/104.a207d395.js"><link rel="prefetch" href="/blog/assets/js/105.eaae1ece.js"><link rel="prefetch" href="/blog/assets/js/106.9b961ba0.js"><link rel="prefetch" href="/blog/assets/js/107.df9ba599.js"><link rel="prefetch" href="/blog/assets/js/108.a5880443.js"><link rel="prefetch" href="/blog/assets/js/109.538edbe1.js"><link rel="prefetch" href="/blog/assets/js/11.ef37454d.js"><link rel="prefetch" href="/blog/assets/js/110.91c6d5de.js"><link rel="prefetch" href="/blog/assets/js/111.2211f82c.js"><link rel="prefetch" href="/blog/assets/js/112.6b9220f5.js"><link rel="prefetch" href="/blog/assets/js/113.9b314292.js"><link rel="prefetch" href="/blog/assets/js/114.b05dc902.js"><link rel="prefetch" href="/blog/assets/js/115.6a21a21a.js"><link rel="prefetch" href="/blog/assets/js/116.f4969b27.js"><link rel="prefetch" href="/blog/assets/js/117.c6601199.js"><link rel="prefetch" href="/blog/assets/js/119.f0742def.js"><link rel="prefetch" href="/blog/assets/js/12.2003a6c5.js"><link rel="prefetch" href="/blog/assets/js/120.a3d456af.js"><link rel="prefetch" href="/blog/assets/js/121.afee83c8.js"><link rel="prefetch" href="/blog/assets/js/122.ffc358e4.js"><link rel="prefetch" href="/blog/assets/js/123.b7cb0f42.js"><link rel="prefetch" href="/blog/assets/js/124.ca59f8f6.js"><link rel="prefetch" href="/blog/assets/js/125.7be39e4f.js"><link rel="prefetch" href="/blog/assets/js/126.8b8a9b2d.js"><link rel="prefetch" href="/blog/assets/js/127.3d53f72f.js"><link rel="prefetch" href="/blog/assets/js/128.ebd5e805.js"><link rel="prefetch" href="/blog/assets/js/129.c960281b.js"><link rel="prefetch" href="/blog/assets/js/13.4a08f423.js"><link rel="prefetch" href="/blog/assets/js/130.9ee2fb72.js"><link rel="prefetch" href="/blog/assets/js/131.1155be64.js"><link rel="prefetch" href="/blog/assets/js/132.866a7ce5.js"><link rel="prefetch" href="/blog/assets/js/133.ea694d5c.js"><link rel="prefetch" href="/blog/assets/js/134.d585508a.js"><link rel="prefetch" href="/blog/assets/js/135.1132a9d3.js"><link rel="prefetch" href="/blog/assets/js/136.fe9832ed.js"><link rel="prefetch" href="/blog/assets/js/137.574e5c35.js"><link rel="prefetch" href="/blog/assets/js/138.87124965.js"><link rel="prefetch" href="/blog/assets/js/139.e394567e.js"><link rel="prefetch" href="/blog/assets/js/14.0ee281ea.js"><link rel="prefetch" href="/blog/assets/js/140.c2741475.js"><link rel="prefetch" href="/blog/assets/js/141.cd76190b.js"><link rel="prefetch" href="/blog/assets/js/142.bc1d599e.js"><link rel="prefetch" href="/blog/assets/js/143.e16816e7.js"><link rel="prefetch" href="/blog/assets/js/144.c91db5db.js"><link rel="prefetch" href="/blog/assets/js/145.95b58ec4.js"><link rel="prefetch" href="/blog/assets/js/146.c5ff12f5.js"><link rel="prefetch" href="/blog/assets/js/147.ef38cae8.js"><link rel="prefetch" href="/blog/assets/js/148.b0a6ba25.js"><link rel="prefetch" href="/blog/assets/js/149.f0a6fc97.js"><link rel="prefetch" href="/blog/assets/js/15.de9db6ca.js"><link rel="prefetch" href="/blog/assets/js/150.6514db42.js"><link rel="prefetch" href="/blog/assets/js/151.dcf981a0.js"><link rel="prefetch" href="/blog/assets/js/152.6a733b47.js"><link rel="prefetch" href="/blog/assets/js/153.1a5b425b.js"><link rel="prefetch" href="/blog/assets/js/154.59a5cdd0.js"><link rel="prefetch" href="/blog/assets/js/155.1ecb4821.js"><link rel="prefetch" href="/blog/assets/js/156.e514afd4.js"><link rel="prefetch" href="/blog/assets/js/157.c01cdccb.js"><link rel="prefetch" href="/blog/assets/js/158.71dda3a8.js"><link rel="prefetch" href="/blog/assets/js/159.33fa138a.js"><link rel="prefetch" href="/blog/assets/js/16.03e830ed.js"><link rel="prefetch" href="/blog/assets/js/160.41012461.js"><link rel="prefetch" href="/blog/assets/js/161.93be8033.js"><link rel="prefetch" href="/blog/assets/js/162.d1adee89.js"><link rel="prefetch" href="/blog/assets/js/163.35e7409e.js"><link rel="prefetch" href="/blog/assets/js/164.b5140f57.js"><link rel="prefetch" href="/blog/assets/js/165.f7cbff8f.js"><link rel="prefetch" href="/blog/assets/js/166.e5008cd5.js"><link rel="prefetch" href="/blog/assets/js/167.56eb9dbd.js"><link rel="prefetch" href="/blog/assets/js/168.27dc81ce.js"><link rel="prefetch" href="/blog/assets/js/169.2b833606.js"><link rel="prefetch" href="/blog/assets/js/17.997071ba.js"><link rel="prefetch" href="/blog/assets/js/170.4469c187.js"><link rel="prefetch" href="/blog/assets/js/171.ff778380.js"><link rel="prefetch" href="/blog/assets/js/172.ed65c8c1.js"><link rel="prefetch" href="/blog/assets/js/173.41d6e737.js"><link rel="prefetch" href="/blog/assets/js/174.bccb9fa6.js"><link rel="prefetch" href="/blog/assets/js/175.deb32fb8.js"><link rel="prefetch" href="/blog/assets/js/176.2380b0cf.js"><link rel="prefetch" href="/blog/assets/js/177.67fa30a9.js"><link rel="prefetch" href="/blog/assets/js/178.7f4bf5e6.js"><link rel="prefetch" href="/blog/assets/js/18.c000b794.js"><link rel="prefetch" href="/blog/assets/js/19.d0523809.js"><link rel="prefetch" href="/blog/assets/js/2.43a980f2.js"><link rel="prefetch" href="/blog/assets/js/20.e9165d7c.js"><link rel="prefetch" href="/blog/assets/js/21.e0c3e1c3.js"><link rel="prefetch" href="/blog/assets/js/22.87f8326f.js"><link rel="prefetch" href="/blog/assets/js/23.6f53a063.js"><link rel="prefetch" href="/blog/assets/js/24.1249f968.js"><link rel="prefetch" href="/blog/assets/js/25.a976dac8.js"><link rel="prefetch" href="/blog/assets/js/26.54c900ef.js"><link rel="prefetch" href="/blog/assets/js/27.7621a087.js"><link rel="prefetch" href="/blog/assets/js/28.ec739e1d.js"><link rel="prefetch" href="/blog/assets/js/29.76ea8050.js"><link rel="prefetch" href="/blog/assets/js/30.6417632a.js"><link rel="prefetch" href="/blog/assets/js/31.3f4523df.js"><link rel="prefetch" href="/blog/assets/js/32.666cd74a.js"><link rel="prefetch" href="/blog/assets/js/33.a689a6fc.js"><link rel="prefetch" href="/blog/assets/js/34.6cc2c586.js"><link rel="prefetch" href="/blog/assets/js/35.86d13f87.js"><link rel="prefetch" href="/blog/assets/js/36.20e014f1.js"><link rel="prefetch" href="/blog/assets/js/37.8b69cd99.js"><link rel="prefetch" href="/blog/assets/js/38.f1cc6c40.js"><link rel="prefetch" href="/blog/assets/js/39.5664b0d3.js"><link rel="prefetch" href="/blog/assets/js/4.60804666.js"><link rel="prefetch" href="/blog/assets/js/40.2943fb88.js"><link rel="prefetch" href="/blog/assets/js/41.6201f829.js"><link rel="prefetch" href="/blog/assets/js/42.2e1b7a5b.js"><link rel="prefetch" href="/blog/assets/js/43.9c1b7439.js"><link rel="prefetch" href="/blog/assets/js/44.68f63f99.js"><link rel="prefetch" href="/blog/assets/js/45.328fda2a.js"><link rel="prefetch" href="/blog/assets/js/46.0bd04509.js"><link rel="prefetch" href="/blog/assets/js/47.b8cfe094.js"><link rel="prefetch" href="/blog/assets/js/48.59825d73.js"><link rel="prefetch" href="/blog/assets/js/49.cffe09bd.js"><link rel="prefetch" href="/blog/assets/js/5.548a74f6.js"><link rel="prefetch" href="/blog/assets/js/50.97f9d2b0.js"><link rel="prefetch" href="/blog/assets/js/51.564cf3e9.js"><link rel="prefetch" href="/blog/assets/js/52.d2042f8d.js"><link rel="prefetch" href="/blog/assets/js/53.a70a48c8.js"><link rel="prefetch" href="/blog/assets/js/54.9a93718c.js"><link rel="prefetch" href="/blog/assets/js/55.bd9a7852.js"><link rel="prefetch" href="/blog/assets/js/56.c2bf89f1.js"><link rel="prefetch" href="/blog/assets/js/57.a8ad91e4.js"><link rel="prefetch" href="/blog/assets/js/58.51d02d31.js"><link rel="prefetch" href="/blog/assets/js/59.bd516f75.js"><link rel="prefetch" href="/blog/assets/js/6.2a5a1504.js"><link rel="prefetch" href="/blog/assets/js/60.b70f4aa5.js"><link rel="prefetch" href="/blog/assets/js/61.0ce9673a.js"><link rel="prefetch" href="/blog/assets/js/62.24bf6999.js"><link rel="prefetch" href="/blog/assets/js/63.6b1d0cdc.js"><link rel="prefetch" href="/blog/assets/js/64.0a87210f.js"><link rel="prefetch" href="/blog/assets/js/65.255d0e52.js"><link rel="prefetch" href="/blog/assets/js/66.34889547.js"><link rel="prefetch" href="/blog/assets/js/67.d5b053a1.js"><link rel="prefetch" href="/blog/assets/js/68.24775a0c.js"><link rel="prefetch" href="/blog/assets/js/69.6b6ae34e.js"><link rel="prefetch" href="/blog/assets/js/7.e088d63d.js"><link rel="prefetch" href="/blog/assets/js/70.49ff7561.js"><link rel="prefetch" href="/blog/assets/js/71.97a4d551.js"><link rel="prefetch" href="/blog/assets/js/72.49706859.js"><link rel="prefetch" href="/blog/assets/js/73.d2f96422.js"><link rel="prefetch" href="/blog/assets/js/74.3c8755ec.js"><link rel="prefetch" href="/blog/assets/js/75.5800081d.js"><link rel="prefetch" href="/blog/assets/js/76.a63525d6.js"><link rel="prefetch" href="/blog/assets/js/77.da3a7d1d.js"><link rel="prefetch" href="/blog/assets/js/78.d8480922.js"><link rel="prefetch" href="/blog/assets/js/79.64a09aa3.js"><link rel="prefetch" href="/blog/assets/js/8.f3bc1f32.js"><link rel="prefetch" href="/blog/assets/js/80.932971cd.js"><link rel="prefetch" href="/blog/assets/js/81.04f50a1e.js"><link rel="prefetch" href="/blog/assets/js/82.db879ca5.js"><link rel="prefetch" href="/blog/assets/js/83.e89b8863.js"><link rel="prefetch" href="/blog/assets/js/84.07410b58.js"><link rel="prefetch" href="/blog/assets/js/85.d46c8682.js"><link rel="prefetch" href="/blog/assets/js/86.3869d59e.js"><link rel="prefetch" href="/blog/assets/js/87.e7860b15.js"><link rel="prefetch" href="/blog/assets/js/88.09fc332a.js"><link rel="prefetch" href="/blog/assets/js/89.8b302469.js"><link rel="prefetch" href="/blog/assets/js/9.da864c6e.js"><link rel="prefetch" href="/blog/assets/js/90.fab1b0e1.js"><link rel="prefetch" href="/blog/assets/js/91.d1662d38.js"><link rel="prefetch" href="/blog/assets/js/92.4093acc4.js"><link rel="prefetch" href="/blog/assets/js/93.d4c601c1.js"><link rel="prefetch" href="/blog/assets/js/94.1e2891fe.js"><link rel="prefetch" href="/blog/assets/js/95.758d874c.js"><link rel="prefetch" href="/blog/assets/js/96.85084d66.js"><link rel="prefetch" href="/blog/assets/js/97.16a7a60a.js"><link rel="prefetch" href="/blog/assets/js/98.a84fee2e.js"><link rel="prefetch" href="/blog/assets/js/99.f9452cba.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.e16ad0a6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">一名GO+PHP工程师</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述" class="sidebar-heading clickable"><span>Go类型系统</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述.html" class="sidebar-link">Go类型系统概述</a></li><li><a href="/blog/开发基础/GO/Go类型系统/2指针.html" class="sidebar-link">指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/3结构体.html" class="sidebar-link">结构体</a></li><li><a href="/blog/开发基础/GO/Go类型系统/4值部.html" class="sidebar-link">值部</a></li><li><a href="/blog/开发基础/GO/Go类型系统/5数组、切片和映射.html" class="sidebar-link">数组、切片和映射</a></li><li><a href="/blog/开发基础/GO/Go类型系统/6通道.html" class="sidebar-link">通道</a></li><li><a href="/blog/开发基础/GO/Go类型系统/7方法.html" class="sidebar-link">方法</a></li><li><a href="/blog/开发基础/GO/Go类型系统/8接口.html" class="sidebar-link">接口</a></li><li><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html" class="sidebar-link">类型内嵌</a></li><li><a href="/blog/开发基础/GO/Go类型系统/10非类型安全指针.html" class="sidebar-link">非类型安全指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/11泛型.html" class="sidebar-link">泛型</a></li><li><a href="/blog/开发基础/GO/Go类型系统/12反射.html" class="sidebar-link">反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍" class="sidebar-heading clickable"><span>Go编程入门</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍.html" class="sidebar-link">程序源代码基本元素介绍</a></li><li><a href="/blog/开发基础/GO/Go编程入门/2关键字和标识符.html" class="sidebar-link">关键字和标识符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/3基本类型和它们的字面量表示.html" class="sidebar-link">基本类型和它们的字面量表示</a></li><li><a href="/blog/开发基础/GO/Go编程入门/4常量和变量.html" class="sidebar-link">常量和变量</a></li><li><a href="/blog/开发基础/GO/Go编程入门/5运算操作符.html" class="sidebar-link">运算操作符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/6函数声明和调用.html" class="sidebar-link">函数声明和调用</a></li><li><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html" class="sidebar-link">代码包和包引入</a></li><li><a href="/blog/开发基础/GO/Go编程入门/8表达式、语句和简单语句.html" class="sidebar-link">表达式、语句和简单语句</a></li><li><a href="/blog/开发基础/GO/Go编程入门/9基本流程控制语法.html" class="sidebar-link">基本流程控制语法</a></li><li><a href="/blog/开发基础/GO/Go编程入门/10协程、延迟函数调用、以及恐慌和恢复.html" class="sidebar-link">协程、延迟函数调用、以及恐慌和恢复</a></li><li><a href="/blog/开发基础/GO/Go编程入门/GO官方链接工具.html" class="sidebar-link">GO官方链接工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/其他文章/Go技巧" class="sidebar-heading clickable"><span>其他文章</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/其他文章/Go技巧.html" class="sidebar-link">Go技巧</a></li><li><a href="/blog/开发基础/GO/其他文章/Go细节.html" class="sidebar-link">Go细节</a></li><li><a href="/blog/开发基础/GO/其他文章/Go问答.html" class="sidebar-link">Go问答</a></li><li><a href="/blog/开发基础/GO/其他文章/命令-mod.html" class="sidebar-link">命令-mod</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Golang的time.NewTimer单次定时器使用案例.html" class="sidebar-link">基础-Golang的time. NewTimer单次定时器使用案例</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go中的nil.html" class="sidebar-link">Go中的 nil</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go代码断行规则.html" class="sidebar-link">Go代码断行规则</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-表达式估值顺序规则.html" class="sidebar-link">表达式估值顺序规则</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/学习资料" class="sidebar-heading clickable"><span>GO</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/学习资料.html" class="sidebar-link">教学书籍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/并发编程/1并发同步概述" class="sidebar-heading clickable open"><span>并发编程</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/并发编程/1并发同步概述.html" class="sidebar-link">并发同步概述</a></li><li><a href="/blog/开发基础/GO/并发编程/2通道用例大全.html" class="sidebar-link">通道用例大全</a></li><li><a href="/blog/开发基础/GO/并发编程/3如何优雅地关闭通道.html" class="sidebar-link">如何优雅地关闭通道</a></li><li><a href="/blog/开发基础/GO/并发编程/4其它并发同步技术.html" class="sidebar-link">sync 标准库包中提供的并发同步技术</a></li><li><a href="/blog/开发基础/GO/并发编程/5原子操作 .html" class="sidebar-link">sync/atomic 标准库包中提供的原子操作</a></li><li><a href="/blog/开发基础/GO/并发编程/6Go中的内存顺序保证.html" class="sidebar-link">Go中的内存顺序保证</a></li><li><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html" class="active sidebar-link">一些常见并发编程错误</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#当需要同步的时候没有同步" class="sidebar-link">当需要同步的时候没有同步</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#使用-time-sleep-调用来做同步" class="sidebar-link">使用 time. Sleep 调用来做同步</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#使一些协程永久处于阻塞状态" class="sidebar-link">使一些协程永久处于阻塞状态</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#复制-sync-标准库包中的类型的值" class="sidebar-link">复制 sync 标准库包中的类型的值</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#在错误的地方调用-sync-waitgroup-add-方法" class="sidebar-link">在错误的地方调用 sync. WaitGroup. Add 方法</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#不当地使用用做future-promise的通道" class="sidebar-link">不当地使用用做Future/Promise的通道</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#没有让最后一个活跃的发送者关闭通道" class="sidebar-link">没有让最后一个活跃的发送者关闭通道</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#对地址不保证为8字节对齐的值执行64位原子操作" class="sidebar-link">对地址不保证为8字节对齐的值执行64位原子操作</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#没留意过多的-time-after-函数调用消耗了大量资源" class="sidebar-link">没留意过多的 time. After 函数调用消耗了大量资源</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html#不正确地使用-time-timer-值" class="sidebar-link">不正确地使用 time. Timer 值</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境" class="sidebar-heading clickable"><span>开发环境搭建</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境.html" class="sidebar-link">Docker和VS Code的Go开发环境</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一些常见并发编程错误"><a href="#一些常见并发编程错误" class="header-anchor">#</a> 一些常见并发编程错误</h1> <p>Go语言是一门天然支持并发的编程语言。 通过使用 <code>go</code> 关键字，我们可以很轻松地创建协程；通过<a href="https://gfw.go101.org/article/channel-use-cases.html" target="_blank" rel="noopener noreferrer">使用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><a href="https://gfw.go101.org/article/channel.html" target="_blank" rel="noopener noreferrer">通道<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://gfw.go101.org/article/concurrent-atomic-operation.html" target="_blank" rel="noopener noreferrer">Go中提供的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>其它<a href="https://gfw.go101.org/article/concurrent-synchronization-more.html" target="_blank" rel="noopener noreferrer">各种同步技术<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，并发编程变得简单、轻松和有趣。</p> <p>另一方面，Go并不阻止程序员在并发编程中因为粗心或者经验不足而犯错。 本文的余下部分将展示一些常见的并发错误，来帮助Go程序员在实践中避免这些错误。</p> <h2 id="当需要同步的时候没有同步"><a href="#当需要同步的时候没有同步" class="header-anchor">#</a> 当需要同步的时候没有同步</h2> <p>我们已经知道，源文件中的代码行在运行时刻<a href="https://gfw.go101.org/article/memory-model.html" target="_blank" rel="noopener noreferrer">并非总是按照它们的出现次序被执行<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>下面这个示例程序犯了两个错误：</p> <ul><li>首先，主协程中对变量<code>b</code>的读取和匿名协程中的对变量<code>b</code>的写入可能会产生数据竞争；</li> <li>其次，在主协程中，条件<code>b == true</code>成立并不能确保条件<code>a != nil</code>也成立。 编译器和CPU可能会对<a href="https://gfw.go101.org/article/memory-model.html" target="_blank" rel="noopener noreferrer">调整此程序中匿名协程中的某些指令的顺序<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>已获取更快的执行速度。 所以，站在主协程的视角看，对变量<code>b</code>的赋值可能会发生在对变量<code>a</code>的赋值之前，这将造成在修改<code>a</code>的元素时<code>a</code>依然为一个nil切片。</li></ul> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;time&quot;</span>
	<span class="token string">&quot;runtime&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// nil</span>
	<span class="token keyword">var</span> b <span class="token builtin">bool</span>  <span class="token comment">// false</span>

	<span class="token comment">// 一个匿名协程。</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		a <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
		b <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 写入b</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token operator">!</span>b <span class="token punctuation">{</span> <span class="token comment">// 读取b</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		runtime<span class="token punctuation">.</span><span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment">// 可能会发生恐慌</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面这个程序可能在很多计算机上运行良好，但是可能会在某些计算机上因为恐慌而崩溃退出；或者使用某些编译器编译的时候运行良好，但使用另外的某个编译器编译的时候将造成程序运行时崩溃退出。</p> <p>我们应该使用通道或者 <code>sync</code> 标准库包中的同步技术来确保内存顺序。比如：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		a <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
		c <span class="token operator">&lt;-</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token operator">&lt;-</span>c
	a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token comment">// 绝不会造成恐慌</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="使用-time-sleep-调用来做同步"><a href="#使用-time-sleep-调用来做同步" class="header-anchor">#</a> 使用 <code>time. Sleep</code> 调用来做同步</h2> <p>让我们看一个简单的例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">123</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		x <span class="token operator">=</span> <span class="token number">789</span> <span class="token comment">// 写入x</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// 读取x</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们期望着此程序打印出 <code>789</code> 。 事实上，则其运行结果常常正如我们所期待的。 但是，此程序中的同步处理实现的正确吗？否！原因很简单，Go运行时并不能保证对 <code>x</code> 的写入一定发生在对 <code>x</code> 的读取之前。 在某些特定的情形下，比如CPU资源被很一些其它计算密集的程序所占用，则对 <code>x</code> 的写入有可能发生在对 <code>x</code> 的读取之后。 因此，我们不应该在正式的项目中使用 <code>time. Sleep</code> 调用来做同步。</p> <p>让我们看另一个简单的例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">123</span>
	<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>num

	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		c <span class="token operator">&lt;-</span> <span class="token operator">*</span>p <span class="token operator">+</span> x
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	num <span class="token operator">=</span> <span class="token number">789</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>c<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你觉得此程序会输出什么？ <code>123</code> 还是 <code>789</code> ？ 事实上，它的输出是和具体使用的编译器相关的。 对于标准编译器1.16版本来说，它很可能输出 <code>123</code> 。 但是从理论上说，它输出 <code>789</code> 或者另外一个预想不到的值也是有可能的。</p> <p>让我们将此例中的 <code>c &lt;- *p + x</code> 一行换成 <code>c &lt;- *p</code> ，然后重新运行它，你将会发现它的输出变成了 <code>789</code> （如果它使用标准编译器1.16版本编译的话）。 重申一次，此结果是和具体使用的编译器和编译器的版本相关的。</p> <p>是的，此程序中存在数据竞争。表达式 <code>*p</code> 的估值可能发生在赋值 <code>num = 789</code> 之前、之后、或者同时。 <code>time. Sleep</code> 调用并不能保证 <code>*p</code> 的估值发生在此赋值之后。</p> <p>对于这个特定的例子，我们应该将欲发送的值在开启新协程之前存储在一个临时变量中来避免数据竞争。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token operator">...</span>
	tmp <span class="token operator">:=</span> <span class="token operator">*</span>p
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		c <span class="token operator">&lt;-</span> tmp
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">...</span>
</code></pre></div><h2 id="使一些协程永久处于阻塞状态"><a href="#使一些协程永久处于阻塞状态" class="header-anchor">#</a> 使一些协程永久处于阻塞状态</h2> <p>有很多原因导致某个协程永久阻塞，比如：</p> <ul><li>从一个永远不会有其它协程向其发送数据的通道接收数据；</li> <li>向一个永远不会有其它协程从中读取数据的通道发送数据；</li> <li>被自己死锁了；</li> <li>和其它协程相互死锁了；</li> <li>等等。</li></ul> <p>除了有时我们故意地将主协程永久阻塞以防止程序退出外，其它大多数造成协程永久阻塞的情况都不是我们所期待的。 Go运行时很难分辨出一个处于阻塞状态的协程是否将永久阻塞下去，所以Go运行时不会释放永久处于阻塞状态的协程占用的资源。</p> <p>在<a href="https://gfw.go101.org/article/channel-use-cases.html#first-response-wins" target="_blank" rel="noopener noreferrer">采用最快回应<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>通道用例中，如果被当作future/promise来用的通道的容量不足够大，则较慢回应的协程在准备发送回应结果时将永久阻塞。 比如，下面的例子中，每个请求将导致4个协程永久阻塞。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		i <span class="token operator">:=</span> i
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			c <span class="token operator">&lt;-</span> i <span class="token comment">// 4个协程将永久阻塞在这里</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">&lt;-</span>c
<span class="token punctuation">}</span>
</code></pre></div><p>为了防止有4个协程永久阻塞，被当作future/promise使用的通道的容量必须至少为 <code>4</code> .</p> <p>在<a href="https://gfw.go101.org/article/channel-use-cases.html#first-response-wins-2" target="_blank" rel="noopener noreferrer">第二种“采用最快回应”实现方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，如果被当作future/promise使用的通道是一个非缓冲通道（如下面的代码所示），则有可能导致其通道的接收者可能会错过所有的回应而导致处于永久阻塞状态。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		i <span class="token operator">:=</span> i
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">select</span> <span class="token punctuation">{</span>
			<span class="token keyword">case</span> c <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span>
			<span class="token keyword">default</span><span class="token punctuation">:</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">&lt;-</span>c <span class="token comment">// 有可能永久阻塞在此</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接收者协程可能会永久阻塞的原因是如果5个尝试发送操作都发生在接收操作 <code>&lt;-c</code> 准备好之前，亦即5个个尝试发送操作都失败了，则接收者协程将永远无值可接收（从而将处于永久阻塞状态）。</p> <p>将通道 <code>c</code> 改为一个缓冲通道，则至少会有一个尝试发送将成功，从而接收者协程肯定不会永久阻塞。</p> <h2 id="复制-sync-标准库包中的类型的值"><a href="#复制-sync-标准库包中的类型的值" class="header-anchor">#</a> 复制 <code>sync</code> 标准库包中的类型的值</h2> <p>在实践中， <code>sync</code> 标准库包中的类型（除了 <code>Locker</code> 接口类型）的值不应该被复制。 我们只应该复制它们的指针值。</p> <p>下面是一个有问题的并发编程的例子。 在此例子中，当 <code>Counter. Value</code> 方法被调用时，一个 <code>Counter</code> 属主值将被复制，此属主值的字段 <code>Mutex</code> 也将被一同复制。 此复制并没有被同步保护，因此复制结果可能是不完整的，并非被复制的属主值的一个快照。 即使此 <code>Mutex</code> 字段得以侥幸完整复制，它的副本所保护的是对字段 <code>n</code> 的一个副本的访问，因此一般是没有意义的。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">import</span> <span class="token string">&quot;sync&quot;</span>

<span class="token keyword">type</span> Counter <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	sync<span class="token punctuation">.</span>Mutex
	n <span class="token builtin">int64</span>
<span class="token punctuation">}</span>

<span class="token comment">// 此方法实现是没问题的。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token function">Increase</span><span class="token punctuation">(</span>d <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	c<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>n <span class="token operator">+=</span> d
	r <span class="token operator">=</span> c<span class="token punctuation">.</span>n
	c<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment">// 此方法的实现是有问题的。当它被调用时，</span>
<span class="token comment">// 一个Counter属主值将被复制。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c Counter<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>r <span class="token builtin">int64</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	c<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	r <span class="token operator">=</span> c<span class="token punctuation">.</span>n
	c<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们应该将 <code>Value</code> 方法的属主参数类型更改为指针类型 <code>*Counter</code> 来避免复制 <code>sync. Mutex</code> 值。</p> <p>Go官方工具链中提供的 <code>go vet</code> 命令将提示此例中的 <code>Value</code> 方法的声明可能是一个潜在的逻辑错误。</p> <h2 id="在错误的地方调用-sync-waitgroup-add-方法"><a href="#在错误的地方调用-sync-waitgroup-add-方法" class="header-anchor">#</a> 在错误的地方调用 <code>sync. WaitGroup. Add</code> 方法</h2> <p>每个 <code>sync. WaitGroup</code> 值内部维护着一个计数。此计数的初始值为0。 如果一个 <code>sync. WaitGroup</code> 值的 <code>Wait</code> 方法在此计数为0的时候被调用，则此调用不会阻塞，否则此调用将一直阻塞到此计数变为0为止。</p> <p>为了让一个 <code>WaitGroup</code> 值的使用有意义，在此值的计数为0的情况下，对它的下一次 <code>Add</code> 方法的调用必须出现在对它的下一次 <code>Wait</code> 方法的调用之前。</p> <p>比如，在下面的例子中， <code>Add</code> 方法的调用位置是不合适的。 此例子程序的打印结果并不总是 <code>100</code> ，而可能是 <code>0</code> 到 <code>100</code> 间的任何一个值。 原因是没有任何一个 <code>Add</code> 方法调用可以确保发生在唯一的 <code>Wait</code> 方法调用之前，结果导致没有任何一个 <code>Done</code> 方法调用可以确保发生在唯一的 <code>Wait</code> 方法调用返回之前。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;sync&quot;</span>
	<span class="token string">&quot;sync/atomic&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
	<span class="token keyword">var</span> x <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
			atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
			wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;等待片刻...&quot;</span><span class="token punctuation">)</span>
	wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">LoadInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们应该将对 <code>Add</code> 方法的调用移出匿名协程之外，像下面这样，使得任何一个 <code>Done</code> 方法调用都确保发生在唯一的 <code>Wait</code> 方法调用返回之前。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token operator">...</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
			wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token operator">...</span>
</code></pre></div><h2 id="不当地使用用做future-promise的通道"><a href="#不当地使用用做future-promise的通道" class="header-anchor">#</a> 不当地使用用做Future/Promise的通道</h2> <p>从<a href="https://gfw.go101.org/article/channel-use-cases.html#future-promise" target="_blank" rel="noopener noreferrer">通道用例大全<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中，我们了解到一些函数可以返回用做future/promise的通道结果。 假设 <code>fa</code> 和 <code>fb</code> 是这样的两个函数，则下面的调用方式并没有体现出这两个函数的真正价值。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token function">doSomethingWithFutureArguments</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span><span class="token function">fa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&lt;-</span><span class="token function">fb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>在上面这行调用中，两个实参值（promise回应结果）的生成实际上是串行进行的，future/promise的价值没有体现出来。</p> <p>我们应该像下面这样调用这两个函数来并发生成两个回应结果：</p> <div class="language-go extra-class"><pre class="language-go"><code>ca<span class="token punctuation">,</span> cb <span class="token operator">:=</span> <span class="token function">fa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fb</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">doSomethingWithFutureArguments</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ca<span class="token punctuation">,</span> <span class="token operator">&lt;-</span>cb<span class="token punctuation">)</span>
</code></pre></div><h2 id="没有让最后一个活跃的发送者关闭通道"><a href="#没有让最后一个活跃的发送者关闭通道" class="header-anchor">#</a> 没有让最后一个活跃的发送者关闭通道</h2> <p>Go程序员常犯的一个错误是关闭一个后续可能还会有协程向其发送数据的通道。 当向一个已关闭的通道发送数据的时候，一个恐慌将产生。</p> <p>这样的错误曾经发生在一些很有名的项目中，比如Kubernetes项目中的<a href="https://github.com/kubernetes/kubernetes/pull/45291/files?diff=split" target="_blank" rel="noopener noreferrer">这个bug<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://github.com/kubernetes/kubernetes/pull/39479/files?diff=split" target="_blank" rel="noopener noreferrer">这个bug<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>请阅读<a href="https://gfw.go101.org/article/channel-closing.html" target="_blank" rel="noopener noreferrer">此篇文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来了解如何安全和优雅地关闭通道。</p> <h2 id="对地址不保证为8字节对齐的值执行64位原子操作"><a href="#对地址不保证为8字节对齐的值执行64位原子操作" class="header-anchor">#</a> 对地址不保证为8字节对齐的值执行64位原子操作</h2> <p>截至目前（Go 1.16），64位原子操作中涉及到的实参地址必须为8字节对齐的。不满足此条件的64位原子操作将造成一个恐慌。 对于标准编译器，这样的情形只<a href="https://golang.google.cn/pkg/sync/atomic/#pkg-note-BUG" target="_blank" rel="noopener noreferrer">可能发生在32位的架构中<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。 请阅读<a href="https://gfw.go101.org/article/memory-layout.html" target="_blank" rel="noopener noreferrer">内存布局一文<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来获知如何确保让64位的整数值的地址在32位的架构中8字节对齐。</p> <h2 id="没留意过多的-time-after-函数调用消耗了大量资源"><a href="#没留意过多的-time-after-函数调用消耗了大量资源" class="header-anchor">#</a> 没留意过多的 <code>time. After</code> 函数调用消耗了大量资源</h2> <p><code>time</code> 标准库包中的 <code>After</code> 函数返回<a href="https://gfw.go101.org/article/channel-use-cases.html#timer" target="_blank" rel="noopener noreferrer">一个用做延迟通知的通道<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。 此函数给并发编程带来了很多便利，但是它的每个调用都需要创建一个 <code>time. Timer</code> 值，此新创建的 <code>Timer</code> 值在传递给 <code>After</code> 函数调用的时长（实参）内肯定不会被垃圾回收。 如果此函数在某个时段内被多次频繁调用，则可能导致积累很多尚未过期的 <code>Timer</code> 值从而造成大量的内存和计算消耗。</p> <p>比如在下面这个例子中，如果 <code>longRunning</code> 函数被调用并且在一分钟内有一百万条消息到达， 那么在某个特定的很小时间段（大概若干秒）内将存在一百万个活跃的 <code>Timer</code> 值，即使其中只有一个是真正有用的。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// 如果某两个连续的消息的间隔大于一分钟，此函数将返回。</span>
<span class="token keyword">func</span> <span class="token function">longRunning</span><span class="token punctuation">(</span>messages <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token keyword">select</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Minute<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token keyword">return</span>
		<span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>messages<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了避免太多的 <code>Timer</code> 值被创建，我们应该只使用（并复用）一个 <code>Timer</code> 值，像下面这样：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">longRunning</span><span class="token punctuation">(</span>messages <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	timer <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Minute<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> timer<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		<span class="token keyword">select</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> <span class="token operator">&lt;-</span>timer<span class="token punctuation">.</span>C<span class="token punctuation">:</span> <span class="token comment">// 过期了</span>
			<span class="token keyword">return</span>
		<span class="token keyword">case</span> msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>messages<span class="token punctuation">:</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>

			<span class="token comment">// 此if代码块很重要。</span>
			<span class="token keyword">if</span> <span class="token operator">!</span>timer<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token operator">&lt;-</span>timer<span class="token punctuation">.</span>C
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 必须重置以复用。</span>
		timer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Minute<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意，此示例中的 <code>if</code> 代码块用来舍弃一个可能在执行第二个分支代码块的时候发送过来的超时通知。</p> <h2 id="不正确地使用-time-timer-值"><a href="#不正确地使用-time-timer-值" class="header-anchor">#</a> 不正确地使用 <code>time. Timer</code> 值</h2> <p>一个典型的 <code>time. Timer</code> 的使用已经在上一节中展示了。一些解释：</p> <ul><li>如果一个<code>Timer</code>值已经过期或者已经被终止（stopped），则相应的<code>Stop</code>方法调用返回<code>false</code>。 在此<code>Timer</code>值尚未终止的时候，<code>Stop</code>方法调用返回<code>false</code>只能意味着此<code>Timer</code>值已经过期。</li> <li>一个<code>Timer</code>值被终止之后，它的通道字段<code>C</code>最多只能含有一个过期的通知。</li> <li>在一个<code>Timer</code>终止（stopped）之后并且在重置和重用此<code>Timer</code>值之前，我们应该确保此<code>Timer</code>值中肯定不存在过期的通知。 这就是上一节中的例子中的<code>if</code>代码块的意义所在。</li></ul> <p>一个 <code>*Timer</code> 值的 <code>Reset</code> 方法必须在对应 <code>Timer</code> 值过期或者终止之后才能被调用； 否则，此 <code>Reset</code> 方法调用和一个可能的向此 <code>Timer</code> 值的 <code>C</code> 通道字段的发送通知操作产生数据竞争。</p> <p>如果上一节中的例子中的 <code>select</code> 流程控制代码块中的第一个分支被选中，则这表示相应的 <code>Timer</code> 值已经过期，所以我们不必终止它。 但是我们必须在第二个分支中通过终止此 <code>Timer</code> 以检查此 <code>Timer</code> 中是否存在一个过期的通知。 如果确实有一个过期的通知，我们必须在重用这个 <code>Timer</code> 之前将此过期的通知取出；否则，此过期的通知将下一个循环步导致在第一个分支立即被选中。</p> <p>比如，下面这个程序将在运行后大概一秒钟（而不是十秒钟）后退出。 而且此程序存在着潜在的数据竞争。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	timer <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token keyword">select</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token operator">&lt;-</span>timer<span class="token punctuation">.</span>C<span class="token punctuation">:</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">// 此分支被选中的可能性较大</span>
	<span class="token punctuation">}</span>
	timer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 可能数据竞争</span>
	<span class="token operator">&lt;-</span>timer<span class="token punctuation">.</span>C
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 大约1s</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当一个 <code>time. Timer</code> 值不再被使用后，我们不必（但是推荐）终止之。</p> <p>在多个协程中使用同一个 <code>time. Timer</code> 值比较容易写出不当的并发代码，所以尽量不要跨协程使用一个 <code>Timer</code> 值。</p> <p>我们不应该依赖于 <code>time. Timer</code> 的 <code>Reset</code> 方法的返回值。此返回值只要是为了历史兼容性而存在的。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/21/2021, 1:25:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/开发基础/GO/并发编程/6Go中的内存顺序保证.html" class="prev">
        Go中的内存顺序保证
      </a></span> <span class="next"><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境.html">
        Docker和VS Code的Go开发环境
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.b472f60d.js" defer></script><script src="/blog/assets/js/3.21e2e031.js" defer></script><script src="/blog/assets/js/118.a54057c2.js" defer></script>
  </body>
</html>
