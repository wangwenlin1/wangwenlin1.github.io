<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>代码包和包引入 | 一名GO+PHP工程师</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b3aba94c.css" as="style"><link rel="preload" href="/blog/assets/js/app.3a2a0635.js" as="script"><link rel="preload" href="/blog/assets/js/3.21e2e031.js" as="script"><link rel="preload" href="/blog/assets/js/101.6bbce255.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.d053698b.js"><link rel="prefetch" href="/blog/assets/js/100.d5cb88cb.js"><link rel="prefetch" href="/blog/assets/js/102.968ea43c.js"><link rel="prefetch" href="/blog/assets/js/103.c5c5130e.js"><link rel="prefetch" href="/blog/assets/js/104.161b590d.js"><link rel="prefetch" href="/blog/assets/js/105.eaae1ece.js"><link rel="prefetch" href="/blog/assets/js/106.8bdfd9bf.js"><link rel="prefetch" href="/blog/assets/js/107.c9b230ac.js"><link rel="prefetch" href="/blog/assets/js/108.a5880443.js"><link rel="prefetch" href="/blog/assets/js/109.bab44539.js"><link rel="prefetch" href="/blog/assets/js/11.bc7d0bf1.js"><link rel="prefetch" href="/blog/assets/js/110.7ba602f1.js"><link rel="prefetch" href="/blog/assets/js/111.a11c7d35.js"><link rel="prefetch" href="/blog/assets/js/112.bb76db96.js"><link rel="prefetch" href="/blog/assets/js/113.9b314292.js"><link rel="prefetch" href="/blog/assets/js/114.f28a4d47.js"><link rel="prefetch" href="/blog/assets/js/115.6a21a21a.js"><link rel="prefetch" href="/blog/assets/js/116.1fd8cdf3.js"><link rel="prefetch" href="/blog/assets/js/117.193b54e8.js"><link rel="prefetch" href="/blog/assets/js/118.d91f7ec2.js"><link rel="prefetch" href="/blog/assets/js/119.857d484f.js"><link rel="prefetch" href="/blog/assets/js/12.2003a6c5.js"><link rel="prefetch" href="/blog/assets/js/120.c2fc1bab.js"><link rel="prefetch" href="/blog/assets/js/121.e93dfc27.js"><link rel="prefetch" href="/blog/assets/js/122.0ea0246a.js"><link rel="prefetch" href="/blog/assets/js/123.31436cd9.js"><link rel="prefetch" href="/blog/assets/js/124.6b522c49.js"><link rel="prefetch" href="/blog/assets/js/125.7be39e4f.js"><link rel="prefetch" href="/blog/assets/js/126.8b8a9b2d.js"><link rel="prefetch" href="/blog/assets/js/127.7d06eb7f.js"><link rel="prefetch" href="/blog/assets/js/128.3498b329.js"><link rel="prefetch" href="/blog/assets/js/129.b4fdbe4d.js"><link rel="prefetch" href="/blog/assets/js/13.d2837ebd.js"><link rel="prefetch" href="/blog/assets/js/130.4acdc8e4.js"><link rel="prefetch" href="/blog/assets/js/131.ef9fa33c.js"><link rel="prefetch" href="/blog/assets/js/132.1f9b4bbb.js"><link rel="prefetch" href="/blog/assets/js/133.a417b118.js"><link rel="prefetch" href="/blog/assets/js/134.6a6cf86d.js"><link rel="prefetch" href="/blog/assets/js/135.313b60a3.js"><link rel="prefetch" href="/blog/assets/js/136.2c3aff88.js"><link rel="prefetch" href="/blog/assets/js/137.50106a44.js"><link rel="prefetch" href="/blog/assets/js/138.87124965.js"><link rel="prefetch" href="/blog/assets/js/139.cb5c4cb6.js"><link rel="prefetch" href="/blog/assets/js/14.48fb5c32.js"><link rel="prefetch" href="/blog/assets/js/140.9719663d.js"><link rel="prefetch" href="/blog/assets/js/141.b0090c83.js"><link rel="prefetch" href="/blog/assets/js/142.e385a422.js"><link rel="prefetch" href="/blog/assets/js/143.9d960553.js"><link rel="prefetch" href="/blog/assets/js/144.e3ef5a71.js"><link rel="prefetch" href="/blog/assets/js/145.95b58ec4.js"><link rel="prefetch" href="/blog/assets/js/146.92cd1d56.js"><link rel="prefetch" href="/blog/assets/js/147.1aad7186.js"><link rel="prefetch" href="/blog/assets/js/148.b0a6ba25.js"><link rel="prefetch" href="/blog/assets/js/149.cf51c7a4.js"><link rel="prefetch" href="/blog/assets/js/15.977c5e43.js"><link rel="prefetch" href="/blog/assets/js/150.8961d634.js"><link rel="prefetch" href="/blog/assets/js/151.d4337140.js"><link rel="prefetch" href="/blog/assets/js/152.d4fcbdac.js"><link rel="prefetch" href="/blog/assets/js/153.8f0df288.js"><link rel="prefetch" href="/blog/assets/js/154.3108e3fe.js"><link rel="prefetch" href="/blog/assets/js/155.1c76998b.js"><link rel="prefetch" href="/blog/assets/js/156.14a1e6f8.js"><link rel="prefetch" href="/blog/assets/js/157.2a90db8a.js"><link rel="prefetch" href="/blog/assets/js/158.f649eaa4.js"><link rel="prefetch" href="/blog/assets/js/159.bde474db.js"><link rel="prefetch" href="/blog/assets/js/16.cc3bb18b.js"><link rel="prefetch" href="/blog/assets/js/160.da7deb2a.js"><link rel="prefetch" href="/blog/assets/js/161.5124a074.js"><link rel="prefetch" href="/blog/assets/js/162.7f4358a0.js"><link rel="prefetch" href="/blog/assets/js/163.76da1c99.js"><link rel="prefetch" href="/blog/assets/js/164.ebc9b6a7.js"><link rel="prefetch" href="/blog/assets/js/165.f7cbff8f.js"><link rel="prefetch" href="/blog/assets/js/166.5bcaa3dd.js"><link rel="prefetch" href="/blog/assets/js/167.b4296d08.js"><link rel="prefetch" href="/blog/assets/js/168.27dc81ce.js"><link rel="prefetch" href="/blog/assets/js/169.4614ac4e.js"><link rel="prefetch" href="/blog/assets/js/17.180fd8e8.js"><link rel="prefetch" href="/blog/assets/js/170.e41001f5.js"><link rel="prefetch" href="/blog/assets/js/171.0724bbd4.js"><link rel="prefetch" href="/blog/assets/js/172.2d5b541f.js"><link rel="prefetch" href="/blog/assets/js/173.f03b20a0.js"><link rel="prefetch" href="/blog/assets/js/174.092074fb.js"><link rel="prefetch" href="/blog/assets/js/175.bbae3a5c.js"><link rel="prefetch" href="/blog/assets/js/176.2380b0cf.js"><link rel="prefetch" href="/blog/assets/js/177.67fa30a9.js"><link rel="prefetch" href="/blog/assets/js/178.7f4bf5e6.js"><link rel="prefetch" href="/blog/assets/js/18.fa5bec70.js"><link rel="prefetch" href="/blog/assets/js/19.82d0b6cb.js"><link rel="prefetch" href="/blog/assets/js/2.cf693890.js"><link rel="prefetch" href="/blog/assets/js/20.8d88eb5f.js"><link rel="prefetch" href="/blog/assets/js/21.04aa936c.js"><link rel="prefetch" href="/blog/assets/js/22.6f38dceb.js"><link rel="prefetch" href="/blog/assets/js/23.00b0c454.js"><link rel="prefetch" href="/blog/assets/js/24.4949647c.js"><link rel="prefetch" href="/blog/assets/js/25.f090d9de.js"><link rel="prefetch" href="/blog/assets/js/26.64e9b11e.js"><link rel="prefetch" href="/blog/assets/js/27.f6f1b280.js"><link rel="prefetch" href="/blog/assets/js/28.ba46dc32.js"><link rel="prefetch" href="/blog/assets/js/29.08dd160e.js"><link rel="prefetch" href="/blog/assets/js/30.1f6b9a8b.js"><link rel="prefetch" href="/blog/assets/js/31.edcef4fa.js"><link rel="prefetch" href="/blog/assets/js/32.763b7b98.js"><link rel="prefetch" href="/blog/assets/js/33.10fa82ac.js"><link rel="prefetch" href="/blog/assets/js/34.783e6db1.js"><link rel="prefetch" href="/blog/assets/js/35.86d13f87.js"><link rel="prefetch" href="/blog/assets/js/36.c81ca450.js"><link rel="prefetch" href="/blog/assets/js/37.6c8b6e4d.js"><link rel="prefetch" href="/blog/assets/js/38.fed1555d.js"><link rel="prefetch" href="/blog/assets/js/39.d8367356.js"><link rel="prefetch" href="/blog/assets/js/4.33e3eeff.js"><link rel="prefetch" href="/blog/assets/js/40.890bdfe6.js"><link rel="prefetch" href="/blog/assets/js/41.351a2bb7.js"><link rel="prefetch" href="/blog/assets/js/42.7dc0997f.js"><link rel="prefetch" href="/blog/assets/js/43.b1eb7b31.js"><link rel="prefetch" href="/blog/assets/js/44.96773f8a.js"><link rel="prefetch" href="/blog/assets/js/45.14984c3f.js"><link rel="prefetch" href="/blog/assets/js/46.360c94b5.js"><link rel="prefetch" href="/blog/assets/js/47.6ba6e036.js"><link rel="prefetch" href="/blog/assets/js/48.7e30092c.js"><link rel="prefetch" href="/blog/assets/js/49.cffe09bd.js"><link rel="prefetch" href="/blog/assets/js/5.93c02369.js"><link rel="prefetch" href="/blog/assets/js/50.10849ea7.js"><link rel="prefetch" href="/blog/assets/js/51.29fb5c68.js"><link rel="prefetch" href="/blog/assets/js/52.c183fd4d.js"><link rel="prefetch" href="/blog/assets/js/53.2102d53f.js"><link rel="prefetch" href="/blog/assets/js/54.a7def65b.js"><link rel="prefetch" href="/blog/assets/js/55.e1462b05.js"><link rel="prefetch" href="/blog/assets/js/56.d35a7dec.js"><link rel="prefetch" href="/blog/assets/js/57.f908b76a.js"><link rel="prefetch" href="/blog/assets/js/58.8c699c1a.js"><link rel="prefetch" href="/blog/assets/js/59.013048e6.js"><link rel="prefetch" href="/blog/assets/js/6.bf46d9ef.js"><link rel="prefetch" href="/blog/assets/js/60.96011719.js"><link rel="prefetch" href="/blog/assets/js/61.c57dc954.js"><link rel="prefetch" href="/blog/assets/js/62.24bf6999.js"><link rel="prefetch" href="/blog/assets/js/63.2f87f55d.js"><link rel="prefetch" href="/blog/assets/js/64.68cd3b45.js"><link rel="prefetch" href="/blog/assets/js/65.d1a0e0c0.js"><link rel="prefetch" href="/blog/assets/js/66.d694b5d5.js"><link rel="prefetch" href="/blog/assets/js/67.1d93ad03.js"><link rel="prefetch" href="/blog/assets/js/68.7a922734.js"><link rel="prefetch" href="/blog/assets/js/69.e8dc5f21.js"><link rel="prefetch" href="/blog/assets/js/7.965a7048.js"><link rel="prefetch" href="/blog/assets/js/70.0ab39b68.js"><link rel="prefetch" href="/blog/assets/js/71.32fb9ba8.js"><link rel="prefetch" href="/blog/assets/js/72.d7621fb4.js"><link rel="prefetch" href="/blog/assets/js/73.f0b18643.js"><link rel="prefetch" href="/blog/assets/js/74.f4b27305.js"><link rel="prefetch" href="/blog/assets/js/75.d52134dd.js"><link rel="prefetch" href="/blog/assets/js/76.af8a1eb5.js"><link rel="prefetch" href="/blog/assets/js/77.be15b0d2.js"><link rel="prefetch" href="/blog/assets/js/78.d456dcce.js"><link rel="prefetch" href="/blog/assets/js/79.12735350.js"><link rel="prefetch" href="/blog/assets/js/8.78eeb959.js"><link rel="prefetch" href="/blog/assets/js/80.2120e0e9.js"><link rel="prefetch" href="/blog/assets/js/81.04f50a1e.js"><link rel="prefetch" href="/blog/assets/js/82.db879ca5.js"><link rel="prefetch" href="/blog/assets/js/83.e89b8863.js"><link rel="prefetch" href="/blog/assets/js/84.07410b58.js"><link rel="prefetch" href="/blog/assets/js/85.d3e35fad.js"><link rel="prefetch" href="/blog/assets/js/86.f855e246.js"><link rel="prefetch" href="/blog/assets/js/87.bf22bce7.js"><link rel="prefetch" href="/blog/assets/js/88.6ed1a43d.js"><link rel="prefetch" href="/blog/assets/js/89.50e298db.js"><link rel="prefetch" href="/blog/assets/js/9.009d1183.js"><link rel="prefetch" href="/blog/assets/js/90.391f76ed.js"><link rel="prefetch" href="/blog/assets/js/91.d1662d38.js"><link rel="prefetch" href="/blog/assets/js/92.a65aa479.js"><link rel="prefetch" href="/blog/assets/js/93.bc850b53.js"><link rel="prefetch" href="/blog/assets/js/94.7dc858d7.js"><link rel="prefetch" href="/blog/assets/js/95.fce3d2c0.js"><link rel="prefetch" href="/blog/assets/js/96.7e3abf55.js"><link rel="prefetch" href="/blog/assets/js/97.64d3b035.js"><link rel="prefetch" href="/blog/assets/js/98.fdb7d67a.js"><link rel="prefetch" href="/blog/assets/js/99.9a416d3b.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b3aba94c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">一名GO+PHP工程师</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述" class="sidebar-heading clickable"><span>Go类型系统</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述.html" class="sidebar-link">Go类型系统概述</a></li><li><a href="/blog/开发基础/GO/Go类型系统/2指针.html" class="sidebar-link">指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/3结构体.html" class="sidebar-link">结构体</a></li><li><a href="/blog/开发基础/GO/Go类型系统/4值部.html" class="sidebar-link">值部</a></li><li><a href="/blog/开发基础/GO/Go类型系统/5数组、切片和映射.html" class="sidebar-link">数组、切片和映射</a></li><li><a href="/blog/开发基础/GO/Go类型系统/6通道.html" class="sidebar-link">通道</a></li><li><a href="/blog/开发基础/GO/Go类型系统/7方法.html" class="sidebar-link">方法</a></li><li><a href="/blog/开发基础/GO/Go类型系统/8接口.html" class="sidebar-link">接口</a></li><li><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html" class="sidebar-link">类型内嵌</a></li><li><a href="/blog/开发基础/GO/Go类型系统/10非类型安全指针.html" class="sidebar-link">非类型安全指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/11泛型.html" class="sidebar-link">泛型</a></li><li><a href="/blog/开发基础/GO/Go类型系统/12反射.html" class="sidebar-link">反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍" class="sidebar-heading clickable open"><span>Go编程入门</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍.html" class="sidebar-link">程序源代码基本元素介绍</a></li><li><a href="/blog/开发基础/GO/Go编程入门/2关键字和标识符.html" class="sidebar-link">关键字和标识符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/3基本类型和它们的字面量表示.html" class="sidebar-link">基本类型和它们的字面量表示</a></li><li><a href="/blog/开发基础/GO/Go编程入门/4常量和变量.html" class="sidebar-link">常量和变量</a></li><li><a href="/blog/开发基础/GO/Go编程入门/5运算操作符.html" class="sidebar-link">运算操作符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/6函数声明和调用.html" class="sidebar-link">函数声明和调用</a></li><li><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html" class="active sidebar-link">代码包和包引入</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html#包引入" class="sidebar-link">包引入</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html#更多关于-fmt-printf-函数调用的输出格式" class="sidebar-link">更多关于 fmt.Printf 函数调用的输出格式</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html#代码包目录、代码包引入路径和代码包依赖关系" class="sidebar-link">代码包目录、代码包引入路径和代码包依赖关系</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html#init-函数" class="sidebar-link">init 函数</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html#程序资源初始化顺序" class="sidebar-link">程序资源初始化顺序</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html#完整的引入声明语句形式" class="sidebar-link">完整的引入声明语句形式</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html#每个非匿名引入必须至少被使用一次" class="sidebar-link">每个非匿名引入必须至少被使用一次</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html#模块" class="sidebar-link">模块</a></li></ul></li><li><a href="/blog/开发基础/GO/Go编程入门/8表达式、语句和简单语句.html" class="sidebar-link">表达式、语句和简单语句</a></li><li><a href="/blog/开发基础/GO/Go编程入门/9基本流程控制语法.html" class="sidebar-link">基本流程控制语法</a></li><li><a href="/blog/开发基础/GO/Go编程入门/10协程、延迟函数调用、以及恐慌和恢复.html" class="sidebar-link">协程、延迟函数调用、以及恐慌和恢复</a></li><li><a href="/blog/开发基础/GO/Go编程入门/GO官方链接工具.html" class="sidebar-link">GO官方链接工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/其他文章/Go技巧" class="sidebar-heading clickable"><span>其他文章</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/其他文章/Go技巧.html" class="sidebar-link">Go技巧</a></li><li><a href="/blog/开发基础/GO/其他文章/Go细节.html" class="sidebar-link">Go细节</a></li><li><a href="/blog/开发基础/GO/其他文章/Go问答.html" class="sidebar-link">Go问答</a></li><li><a href="/blog/开发基础/GO/其他文章/命令-mod.html" class="sidebar-link">命令-mod</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Golang的time.NewTimer单次定时器使用案例.html" class="sidebar-link">基础-Golang的time. NewTimer单次定时器使用案例</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go中的nil.html" class="sidebar-link">Go中的 nil</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go代码断行规则.html" class="sidebar-link">Go代码断行规则</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-表达式估值顺序规则.html" class="sidebar-link">表达式估值顺序规则</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/学习资料" class="sidebar-heading clickable"><span>GO</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/学习资料.html" class="sidebar-link">教学书籍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/并发编程/1并发同步概述" class="sidebar-heading clickable"><span>并发编程</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/并发编程/1并发同步概述.html" class="sidebar-link">并发同步概述</a></li><li><a href="/blog/开发基础/GO/并发编程/2通道用例大全.html" class="sidebar-link">通道用例大全</a></li><li><a href="/blog/开发基础/GO/并发编程/3如何优雅地关闭通道.html" class="sidebar-link">如何优雅地关闭通道</a></li><li><a href="/blog/开发基础/GO/并发编程/4其它并发同步技术.html" class="sidebar-link">sync 标准库包中提供的并发同步技术</a></li><li><a href="/blog/开发基础/GO/并发编程/5原子操作 .html" class="sidebar-link">sync/atomic 标准库包中提供的原子操作</a></li><li><a href="/blog/开发基础/GO/并发编程/6Go中的内存顺序保证.html" class="sidebar-link">Go中的内存顺序保证</a></li><li><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html" class="sidebar-link">一些常见并发编程错误</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境" class="sidebar-heading clickable"><span>开发环境搭建</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境.html" class="sidebar-link">Docker和VS Code的Go开发环境</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="代码包和包引入"><a href="#代码包和包引入" class="header-anchor">#</a> 代码包和包引入</h1> <p>和很多现代编程语言一样，Go代码包（package）来组织管理代码。 我们必须先引入一个代码包（除了 <code>builtin</code> 标准库包）才能使用其中导出的资源（比如函数、类型、变量和有名常量等）。 此篇文章将讲解Go代码包和代码包引入（import）。</p> <h2 id="包引入"><a href="#包引入" class="header-anchor">#</a> 包引入</h2> <p>下面这个简短的程序（假设它存在一个名为 <code>simple-import-demo.go</code> 的源文件中）引入了一个标准库包。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Go has&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">&quot;keywords.&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对此程序的一些解释：</p> <ul><li>第一行指定了源文件<code>simple-import-demo.go</code>所处的包名为<code>main</code>。 程序入口<code>main</code>函数必须处于一个名为<code>main</code>的代码包中。</li> <li>第三行通过使用<code>import</code>关键字引入了<code>fmt</code>标准库包。 在此源文件中，<code>fmt</code>标准库包将用<code>fmt</code>标识符来表示。 标识符<code>fmt</code>称为<code>fmt</code>标准库包的引入名称。（后续某节将详述代码包的引入名称）。</li> <li><code>fmt</code>标准库包中声明了很多终端打印函数供其它代码包使用。 <code>Println</code>函数是其中之一。 它可以将不定数量参数的字符串表示形式输出到标准输出中。 第六行调用了此<code>Println</code>函数。 注意在此调用中，函数名之前需要带上前缀<code>fmt.</code>，其中<code>fmt</code>是<code>Println</code>函数所处的代码包的引入名称。 <code>aImportName. AnExportedIdentifier</code>这种形式称为一个限定标识符（<a href="https://golang.google.cn/ref/spec#Qualified_identifiers" target="_blank" rel="noopener noreferrer">qualified identifier<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）。</li> <li><code>fmt. Println</code>函数调用接受任意数量的实参并且对实参的类型没有任何限制。 所以此程序中的此函数调用的三个实参的类型将被推断为它们各自的默认类型：<code>string</code>、<code>int</code>和<code>string</code>。</li> <li>对于一个<code>fmt. Println</code>函数调用，任何两个相邻的实参的输出之间将被插入一个空格字符，并且在最后将输出一个空行字符。</li></ul> <p>下面是上面这个程序的运行结果：</p> <div class="language- extra-class"><pre class="language-text"><code>
$ go run simple-import-demo.go
Go has 25 keywords.
</code></pre></div><p>当一个代码包被引入一个Go源文件时，只有此代码包中的<a href="https://gfw.go101.org/article/keywords-and-identifiers.html#identifier" target="_blank" rel="noopener noreferrer">导出<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>资源（名称为大写字母的变量、常量、函数、定义类型和类型别名等）可以在此源文件被使用。 比如上例中的 <code>Println</code> 函数即为一个导出资源，所以它可以在上面的程序源文件中使用。</p> <p>前面几篇文章中使用的内置函数 <code>print</code> 和 <code>println</code> 提供了和 <code>fmt</code> 标准库包中的对应函数相似的功能。 内置函数可以不用引入任何代码包而直接使用。</p> <p>注意： <code>print</code> 和 <code>println</code> 这两个内置函数不推荐使用在生产环境，因为它们不保证一定会出现在以后的Go版本中。</p> <p>我们可以访问<a href="https://golang.org/pkg/" target="_blank" rel="noopener noreferrer">Go官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（<a href="https://golang.google.cn/pkg/" target="_blank" rel="noopener noreferrer">墙内版<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）来查看各个标准库包的文档， 我们也可以<a href="https://gfw.go101.org/article/go-toolchain.html#doc" target="_blank" rel="noopener noreferrer">开启一个本地文档服务器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来查看这些文档。</p> <p>一个包引入也可称为一个包声明。一个包声明只在当前包含此声明的源文件内可见。</p> <p>另外一个例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>
<span class="token keyword">import</span> <span class="token string">&quot;math/rand&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;下一个伪随机数总是%v。\n&quot;</span><span class="token punctuation">,</span> rand<span class="token punctuation">.</span><span class="token function">Uint32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个例子多引入了一个 <code>math/rand</code> 标准库包。 此包是 <code>math</code> 标准库包中的一个子包。 此包提供了一些函数来产生伪随机数序列。</p> <p>一些解释：</p> <ul><li>在此例中，<code>math/rand</code>标准库包的引入名是<code>rand</code>。 <code>rand. Uint32()</code>函数调用将返回一个<code>uint32</code>类型的随机数。</li> <li><code>Printf</code>函数是<code>fmt</code>标准库包中提供的另外一个常用终端打印函数。 一个<code>Printf</code>函数调用必须带有至少一个实参，并且第一个实参的类型必须为<code>string</code>。 此第一个实参指定了此调用的打印格式。此格式中的<code>%v</code>在打印结果将被对应的后续实参的字符串表示形式所取代。 比如上列中的<code>%v</code>在打印结果中将被<code>rand. Uint32()</code>函数调用所返回的随机数所取代。 打印格式中的<code>\n</code>表示一个换行符，这在<a href="https://gfw.go101.org/article/basic-types-and-value-literals.html" target="_blank" rel="noopener noreferrer">基本类型和它们的字面量表示<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中已经解释过。</li></ul> <p>上面这个程序的输出如下：</p> <div class="language- extra-class"><pre class="language-text"><code>
下一个伪随机数总是2596996162。
</code></pre></div><p>如果我们希望上面的程序每次运行的时候输出一个不同的随机数，我们需要在程序启动的时候使用调用 <code>rand.Seed</code> 函数来设置一个不同的随机数种子。</p> <p>多个包引入语句可以用一对小括号来合并成一个包引入语句。比如下面这例。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token comment">// 一条包引入语句引入了三个代码包。</span>
<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;math/rand&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 设置随机数种子</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;下一个伪随机数总是%v。\n&quot;</span><span class="token punctuation">,</span> rand<span class="token punctuation">.</span><span class="token function">Uint32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一些解释：</p> <ul><li>此例多引入了一个<code>time</code>标准库包。 此包提供了很多和时间相关的函数和类型。 其中<code>time. Time</code>和<code>time. Duration</code>是两个最常用的类型。</li> <li>函数调用<code>time. Now()</code>将返回一个表示当前时间的类型为<code>time. Time</code>的值。</li> <li><code>UnixNano</code>是类型<code>time. Time</code>的一个方法。 我们可以把方法看作是特殊的函数。方法将在<a href="https://gfw.go101.org/article/method.html" target="_blank" rel="noopener noreferrer">Go中的方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中详述。 方法调用<code>aTime. UnixNano()</code>将返回从UTC时间的1970年一月一日到<code>aTime</code>所表示的时间之间的纳秒数。 返回结果的类型为<code>int64</code>。 在上例中，此方法调用的结果用来设置随机数种子。</li></ul> <h2 id="更多关于-fmt-printf-函数调用的输出格式"><a href="#更多关于-fmt-printf-函数调用的输出格式" class="header-anchor">#</a> 更多关于 <code>fmt.Printf</code> 函数调用的输出格式</h2> <p>从上面的例子中，我们已经了解到 <code>fmt.Printf</code> 函数调用的第一个实参中的 <code>%v</code> 在输出中将替换为后续的实参的字符串表示形式。 实际上，这种百分号开头的占位字符组合还有很多。下面是一些常用的占位字符组合：</p> <ul><li><code>%v</code>：将被替换为对应实参字符串表示形式。</li> <li><code>%T</code>：将替换为对应实参的类型的字符串表示形式。</li> <li><code>%x</code>：将替换为对应实参的十六进制表示。实参的类型可以为字符串、整数、整数数组（array）或者整数切片（slice）等。 （数组和切片将在以后的文章中讲解。）</li> <li><code>%s</code>：将被替换为对应实参的字符串表示形式。实参的类型必须为字符串或者字节切片（byte slice）类型。</li> <li><code>%%</code>：将被替换为一个百分号。</li></ul> <p>一个例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	a<span class="token punctuation">,</span> b <span class="token operator">:=</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">&quot;Go&quot;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;a == %v == 0x%x, b == %s\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;type of a: %T, type of b: %T\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p> <div class="language- extra-class"><pre class="language-text"><code>
a == 123 == 0x7b, b == Go
type of a: int, type of b: string
1% 50% 99%
</code></pre></div><p>请阅读<a href="https://golang.google.cn/pkg/fmt/" target="_blank" rel="noopener noreferrer"><code>fmt</code> 标准库包的文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>以了解更多的占位字符组合。 我们也可以运行 <code>go doc fmt</code> 命令来在终端中查看 <code>fmt</code> 标准库包的文档。 运行 <code>go doc fmt.Printf</code> 命令可以查看 <code>fmt.Printf</code> 函数的文档。</p> <h2 id="代码包目录、代码包引入路径和代码包依赖关系"><a href="#代码包目录、代码包引入路径和代码包依赖关系" class="header-anchor">#</a> 代码包目录、代码包引入路径和代码包依赖关系</h2> <p>一个代码包可以由若干Go源文件组成。一个代码包的源文件须都处于同一个目录下。 一个目录（不包含子目录）下的所有源文件必须都处于同一个代码包中，亦即这些源文件开头的 <code>package pkgname</code> 语句必须一致。 所以，一个代码包对应着一个目录（不包含子目录），反之亦然。 对应着一个代码包的目录称为此代码包的目录。 一个代码包目录下的每个子目录对应的都是另外一个独立的代码包。</p> <p>对于Go官方工具链来说，一个引入路径中包含有 <code>internal</code> 目录名的代码包被视为一个特殊的代码包。 它只能被此 <code>internal</code> 目录的直接父目录（和此父目录的子目录）中的代码包所引入。 比如，代码包 <code>.../a/b/c/internal/d/e/f</code> 和 <code>.../a/b/c/internal</code> 只能被引入路径含有 <code>.../a/b/c</code> 前缀的代码包引入。</p> <p>当一个代码包中的某个文件引入了另外一个代码包，则我们说前者代码包依赖于后者代码包。</p> <p>Go不支持循环引用（依赖）。 如果一个代码包 <code>a</code> 依赖于代码包 <code>b</code> ，同时代码包 <code>b</code> 依赖于代码包 <code>c</code> ，则代码包 <code>c</code> 中的源文件不能引入代码包 <code>a</code> 和代码包 <code>b</code> ，代码包 <code>b</code> 中的源文件也不能引入代码包 <code>a</code> 。</p> <p>当然，一个代码包中的源文件不能也没必要引入此代码包本身。</p> <p>和包依赖类似，一个模块也可能依赖于一些其它模块。 此模块的直接依赖模块和这些依赖模块的版本在此模块中的 <code>go.mod</code> 文件中指定。 模块循环依赖是允许的，但模块循环依赖这种情况在实践中很少见。</p> <p>今后，我们称一个程序中含有 <code>main</code> 入口函数的名称为 <code>main</code> 的代码包为程序代码包（或者命令代码包），称其它代码包为库代码包。 程序代码包不能被其它代码包引入。一个程序只能有一个程序代码包。</p> <p>代码包目录的名称并不要求一定要和其对应的代码包的名称相同。 但是，库代码包目录的名称最好设为和其对应的代码包的名称相同。 因为一个代码包的引入路径中包含的是此包的目录名，但是此包的默认引入名为此包的名称。 如果两者不一致，会使人感到困惑。</p> <p>另一方面，最好给每个程序代码包目录指定一个有意义的名字，而不是它的包名 <code>main</code> 。</p> <h2 id="init-函数"><a href="#init-函数" class="header-anchor">#</a> <code>init</code> 函数</h2> <p>在一个代码包中，甚至一个源文件中，可以声明若干名为 <code>init</code> 的函数。 这些 <code>init</code> 函数必须不带任何输入参数和返回结果。</p> <p>注意：我们不能声明名为 <code>init</code> 的包级变量、常量或者类型。</p> <p>在程序运行时刻，在进入 <code>main</code> 入口函数之前，每个 <code>init</code> 函数在此包加载的时候将被（串行）执行并且只执行一遍。</p> <p>下面这个简单的程序中有两个 <code>init</code> 函数：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;hi,&quot;</span><span class="token punctuation">,</span> bob<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;bye&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;hello,&quot;</span><span class="token punctuation">,</span> smith<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">titledName</span><span class="token punctuation">(</span>who <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token string">&quot;Mr. &quot;</span> <span class="token operator">+</span> who
<span class="token punctuation">}</span>

<span class="token keyword">var</span> bob<span class="token punctuation">,</span> smith <span class="token operator">=</span> <span class="token function">titledName</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">titledName</span><span class="token punctuation">(</span><span class="token string">&quot;Smith&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>此程序的运行结果：</p> <div class="language- extra-class"><pre class="language-text"><code>
hi, Mr. Bob
hello, Mr. Smith
bye
</code></pre></div><h2 id="程序资源初始化顺序"><a href="#程序资源初始化顺序" class="header-anchor">#</a> 程序资源初始化顺序</h2> <p>一个程序中所涉及到的所有的在运行时刻要用到的代码包的加载是串行执行的。 在一个程序启动时，每个包中总是在它所有依赖的包都加载完成之后才开始加载。 程序代码包总是最后一个被加载的代码包。每个被用到的包会被而且仅会被加载一次。</p> <p>在加载一个代码包的过程中，所有的声明在此包中的 <code>init</code> 函数将被串行调用并且仅调用执行一次。 一个代码包中声明的 <code>init</code> 函数的调用肯定晚于此代码包所依赖的代码包中声明的 <code>init</code> 函数。 所有的 <code>init</code> 函数都将在调用 <code>main</code> 入口函数之前被调用执行。</p> <p>在同一个源文件中声明的 <code>init</code> 函数将按从上到下的顺序被调用执行。 对于声明在同一个包中的两个不同源文件中的两个 <code>init</code> 函数，Go语言白皮书推荐（但不强求）按照它们所处于的源文件的名称的词典序列（对英文来说，即字母顺序）来调用。 所以最好不要让声明在同一个包中的两个不同源文件中的两个 <code>init</code> 函数存在依赖关系。</p> <p>在加载一个代码包的时候，此代码包中声明的所有包级变量都将在此包中的任何一个 <code>init</code> 函数执行之前初始化完毕。</p> <p>在同一个包内，包级变量将尽量按照它们在代码中的出现顺序被初始化，但是一个包级变量的初始化肯定晚于它所依赖的其它包级变量。 比如，在下面的代码片段中，四个包级变量的初始化顺序依次为 <code>y</code> 、 <code>z</code> 、 <code>x</code> 、 <code>w</code> 。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> z <span class="token operator">+</span> y
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> y<span class="token operator">/</span><span class="token number">2</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
	w       <span class="token operator">=</span> x
	x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">,</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><p>关于更具体的包级变量的初始化顺序，请阅读<a href="https://gfw.go101.org/article/evaluation-orders.html#package-level-variables" target="_blank" rel="noopener noreferrer">表达式估值顺序规则<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文。</p> <h2 id="完整的引入声明语句形式"><a href="#完整的引入声明语句形式" class="header-anchor">#</a> 完整的引入声明语句形式</h2> <p>事实上，一个引入声明语句的完整形式为：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">import</span> importname <span class="token string">&quot;path/to/package&quot;</span>
</code></pre></div><p>其中引入名 <code>importname</code> 是可选的，它的默认值为被引入的包的包名（不是目录名）。</p> <p>事实上，在本文上面的例子中的包引入声明中， <code>importname</code> 部分都被省略掉了，因为它们都分别和引入的代码包的包名相同。 这些引入声明等价于下面这些：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">import</span> fmt <span class="token string">&quot;fmt&quot;</span>        <span class="token comment">// &lt;=&gt; import &quot;fmt&quot;</span>
<span class="token keyword">import</span> rand <span class="token string">&quot;math/rand&quot;</span> <span class="token comment">// &lt;=&gt; import &quot;math/rand&quot;</span>
<span class="token keyword">import</span> time <span class="token string">&quot;time&quot;</span>      <span class="token comment">// &lt;=&gt; import &quot;time&quot;</span>
</code></pre></div><p>如果一个包引入声明中的 <code>importname</code> 没有省略，则限定标识符使用的前缀必须为 <code>importname</code> ，而不是被引入的包的名称。</p> <p>引入声明语句的完整形式在日常编程中使用的频率不是很高。 但是在某些情况下，完整形式必须被使用。 比如，如果一个源文件引入的两个代码包的包名一样，为了防止使编译器产生困惑，我们至少需要用完整形式为其中一个包指定一个不同的引入名以区分这两个包。</p> <p>下面是一个使用了完整引入声明语句形式的例子。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	format <span class="token string">&quot;fmt&quot;</span>
	random <span class="token string">&quot;math/rand&quot;</span>
	<span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	random<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	format<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">&quot;一个随机数:&quot;</span><span class="token punctuation">,</span> random<span class="token punctuation">.</span><span class="token function">Uint32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span>

	<span class="token comment">// 下面这两行编译不通过，因为rand不可识别。</span>
	<span class="token comment">/*
	rand.Seed(time.Now().UnixNano())
	fmt.Print(&quot;一个随机数:&quot;, rand.Uint32(), &quot;\n&quot;)
	*/</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一些解释：</p> <ul><li>我们必须使用<code>format</code>和<code>random</code>，而不是<code>fmt</code>和<code>rand</code>，来做为限定标识符的前缀。</li> <li><code>Print</code>是<code>fmt</code>标准库包中的另外一个函数。 和<code>Println</code>函数调用一样，一个<code>Print</code>函数调用也接受任意数量实参。 它将逐个打印出每个实参的字符串表示形式。如果相邻的两个实参都不是字符串类型，则在它们中间会打印一个空格字符。</li></ul> <p>一个完整引入声明语句形式的引入名 <code>importname</code> 可以是一个句点( <code>.</code> )。 这样的引入称为句点引入。使用被句点引入的包中的导出资源时，限定标识符的前缀必须省略。</p> <p>例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token punctuation">.</span> <span class="token string">&quot;fmt&quot;</span>
	<span class="token punctuation">.</span> <span class="token string">&quot;time&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Current time:&quot;</span><span class="token punctuation">,</span> <span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面这个例子中， <code>Println</code> 和 <code>Now</code> 函数调用不需要带任何前缀。</p> <p>一般来说，句点引入不推荐使用，因为它们会导致较低的代码可读性。</p> <p>一个完整引入声明语句形式的引入名 <code>importname</code> 可以是一个空标识符( <code>_</code> )。 这样的引入称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的资源得以初始化。 被匿名引入的包中的 <code>init</code> 函数将被执行并且仅执行一遍。</p> <p>在下面这个例子中，<a href="https://golang.google.cn/pkg/net/http/pprof/" target="_blank" rel="noopener noreferrer"><code>net/http/pprof</code> 标准库包<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中的所有 <code>init</code> 函数将在 <code>main</code> 入口函数开始执行之前全部执行一遍。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token boolean">_</span> <span class="token string">&quot;net/http/pprof&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span> <span class="token comment">// 做一些事情</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="每个非匿名引入必须至少被使用一次"><a href="#每个非匿名引入必须至少被使用一次" class="header-anchor">#</a> 每个非匿名引入必须至少被使用一次</h2> <p>除了匿名引入，其它引入必须在代码中被使用一次。 比如，下面的程序编译不通过。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;net/http&quot;</span> <span class="token comment">// error: 引入未被使用</span>
	<span class="token punctuation">.</span> <span class="token string">&quot;time&quot;</span>   <span class="token comment">// error: 引入未被使用</span>
<span class="token punctuation">)</span>

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	format <span class="token string">&quot;fmt&quot;</span>  <span class="token comment">// okay: 下面被使用了一次</span>
	<span class="token boolean">_</span> <span class="token string">&quot;math/rand&quot;</span> <span class="token comment">// okay: 匿名引入</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	format<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 使用&quot;fmt&quot;包</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h2> <p>一个模块（module）为的若干代码包的集合。当被下载至本地后，这些代码包处于同一个目录（此模块的根目录）下。 一个模块可以有很多版本（版本号遵从<a href="https://semver.org/" target="_blank" rel="noopener noreferrer">Semantic Versioning<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>规范）。 更多关于模块的概念和使用，请阅读<a href="https://golang.google.cn/ref/mod" target="_blank" rel="noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/21/2021, 1:25:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/开发基础/GO/Go编程入门/6函数声明和调用.html" class="prev">
        函数声明和调用
      </a></span> <span class="next"><a href="/blog/开发基础/GO/Go编程入门/8表达式、语句和简单语句.html">
        表达式、语句和简单语句
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.3a2a0635.js" defer></script><script src="/blog/assets/js/3.21e2e031.js" defer></script><script src="/blog/assets/js/101.6bbce255.js" defer></script>
  </body>
</html>
