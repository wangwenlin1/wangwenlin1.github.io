<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Go问答 | 一名GO+PHP工程师</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/blog/assets/css/0.styles.bef719fb.css" as="style"><link rel="preload" href="/blog/assets/js/app.77332b34.js" as="script"><link rel="preload" href="/blog/assets/js/3.21e2e031.js" as="script"><link rel="preload" href="/blog/assets/js/107.df9ba599.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.6084136f.js"><link rel="prefetch" href="/blog/assets/js/100.d5cb88cb.js"><link rel="prefetch" href="/blog/assets/js/101.6bbce255.js"><link rel="prefetch" href="/blog/assets/js/102.968ea43c.js"><link rel="prefetch" href="/blog/assets/js/103.c5c5130e.js"><link rel="prefetch" href="/blog/assets/js/104.161b590d.js"><link rel="prefetch" href="/blog/assets/js/105.eaae1ece.js"><link rel="prefetch" href="/blog/assets/js/106.9b961ba0.js"><link rel="prefetch" href="/blog/assets/js/108.1e4967d1.js"><link rel="prefetch" href="/blog/assets/js/109.bab44539.js"><link rel="prefetch" href="/blog/assets/js/11.2e1457a2.js"><link rel="prefetch" href="/blog/assets/js/110.975b5aeb.js"><link rel="prefetch" href="/blog/assets/js/111.4db6087d.js"><link rel="prefetch" href="/blog/assets/js/112.bb76db96.js"><link rel="prefetch" href="/blog/assets/js/113.9b314292.js"><link rel="prefetch" href="/blog/assets/js/114.b05dc902.js"><link rel="prefetch" href="/blog/assets/js/115.6a21a21a.js"><link rel="prefetch" href="/blog/assets/js/116.1fd8cdf3.js"><link rel="prefetch" href="/blog/assets/js/117.193b54e8.js"><link rel="prefetch" href="/blog/assets/js/118.a54057c2.js"><link rel="prefetch" href="/blog/assets/js/119.857d484f.js"><link rel="prefetch" href="/blog/assets/js/12.48cd3c41.js"><link rel="prefetch" href="/blog/assets/js/120.c2fc1bab.js"><link rel="prefetch" href="/blog/assets/js/121.5bda4d33.js"><link rel="prefetch" href="/blog/assets/js/122.8ce24886.js"><link rel="prefetch" href="/blog/assets/js/123.90357e37.js"><link rel="prefetch" href="/blog/assets/js/124.2d89e041.js"><link rel="prefetch" href="/blog/assets/js/125.7be39e4f.js"><link rel="prefetch" href="/blog/assets/js/126.598ad722.js"><link rel="prefetch" href="/blog/assets/js/127.06c981b6.js"><link rel="prefetch" href="/blog/assets/js/128.ebd5e805.js"><link rel="prefetch" href="/blog/assets/js/129.b4fdbe4d.js"><link rel="prefetch" href="/blog/assets/js/13.b814da2c.js"><link rel="prefetch" href="/blog/assets/js/130.50ee8d35.js"><link rel="prefetch" href="/blog/assets/js/131.5f734cd7.js"><link rel="prefetch" href="/blog/assets/js/132.cb85c88a.js"><link rel="prefetch" href="/blog/assets/js/133.581b5e6c.js"><link rel="prefetch" href="/blog/assets/js/134.6a6cf86d.js"><link rel="prefetch" href="/blog/assets/js/135.313b60a3.js"><link rel="prefetch" href="/blog/assets/js/136.41c7a62b.js"><link rel="prefetch" href="/blog/assets/js/137.feeb7b80.js"><link rel="prefetch" href="/blog/assets/js/138.ddd4d1f7.js"><link rel="prefetch" href="/blog/assets/js/139.b13aa419.js"><link rel="prefetch" href="/blog/assets/js/14.d54ba5e3.js"><link rel="prefetch" href="/blog/assets/js/140.c2741475.js"><link rel="prefetch" href="/blog/assets/js/141.85f894e1.js"><link rel="prefetch" href="/blog/assets/js/142.8f3573aa.js"><link rel="prefetch" href="/blog/assets/js/143.e16816e7.js"><link rel="prefetch" href="/blog/assets/js/144.c91db5db.js"><link rel="prefetch" href="/blog/assets/js/145.95b58ec4.js"><link rel="prefetch" href="/blog/assets/js/146.92cd1d56.js"><link rel="prefetch" href="/blog/assets/js/147.1aad7186.js"><link rel="prefetch" href="/blog/assets/js/148.b0a6ba25.js"><link rel="prefetch" href="/blog/assets/js/149.cf51c7a4.js"><link rel="prefetch" href="/blog/assets/js/15.5840ca25.js"><link rel="prefetch" href="/blog/assets/js/150.8961d634.js"><link rel="prefetch" href="/blog/assets/js/151.9b1a9135.js"><link rel="prefetch" href="/blog/assets/js/152.d4fcbdac.js"><link rel="prefetch" href="/blog/assets/js/153.8f0df288.js"><link rel="prefetch" href="/blog/assets/js/154.3108e3fe.js"><link rel="prefetch" href="/blog/assets/js/155.1c76998b.js"><link rel="prefetch" href="/blog/assets/js/156.e514afd4.js"><link rel="prefetch" href="/blog/assets/js/157.d4566baf.js"><link rel="prefetch" href="/blog/assets/js/158.f649eaa4.js"><link rel="prefetch" href="/blog/assets/js/159.bde474db.js"><link rel="prefetch" href="/blog/assets/js/16.5bdde5ee.js"><link rel="prefetch" href="/blog/assets/js/160.567a6feb.js"><link rel="prefetch" href="/blog/assets/js/161.d8d1d0f9.js"><link rel="prefetch" href="/blog/assets/js/162.d7e72e4d.js"><link rel="prefetch" href="/blog/assets/js/163.33c153d8.js"><link rel="prefetch" href="/blog/assets/js/164.80cca623.js"><link rel="prefetch" href="/blog/assets/js/165.1d0cd529.js"><link rel="prefetch" href="/blog/assets/js/166.b73822d1.js"><link rel="prefetch" href="/blog/assets/js/167.1d799555.js"><link rel="prefetch" href="/blog/assets/js/168.281ad92f.js"><link rel="prefetch" href="/blog/assets/js/169.64dd7e3e.js"><link rel="prefetch" href="/blog/assets/js/17.5259d9eb.js"><link rel="prefetch" href="/blog/assets/js/170.e097186e.js"><link rel="prefetch" href="/blog/assets/js/171.ff778380.js"><link rel="prefetch" href="/blog/assets/js/172.6f3b63ce.js"><link rel="prefetch" href="/blog/assets/js/173.fc6d4e6a.js"><link rel="prefetch" href="/blog/assets/js/174.ae15fd8c.js"><link rel="prefetch" href="/blog/assets/js/175.bbae3a5c.js"><link rel="prefetch" href="/blog/assets/js/176.0b0e42b6.js"><link rel="prefetch" href="/blog/assets/js/177.1ff80e7e.js"><link rel="prefetch" href="/blog/assets/js/178.7f4bf5e6.js"><link rel="prefetch" href="/blog/assets/js/18.935f6748.js"><link rel="prefetch" href="/blog/assets/js/19.bee643b6.js"><link rel="prefetch" href="/blog/assets/js/2.97a298f6.js"><link rel="prefetch" href="/blog/assets/js/20.0f6c34c0.js"><link rel="prefetch" href="/blog/assets/js/21.c4b2e86b.js"><link rel="prefetch" href="/blog/assets/js/22.670160bc.js"><link rel="prefetch" href="/blog/assets/js/23.3ea9a5a9.js"><link rel="prefetch" href="/blog/assets/js/24.fded9b7a.js"><link rel="prefetch" href="/blog/assets/js/25.7a8d93d4.js"><link rel="prefetch" href="/blog/assets/js/26.4962fc80.js"><link rel="prefetch" href="/blog/assets/js/27.9f30f2c0.js"><link rel="prefetch" href="/blog/assets/js/28.dad4d7ea.js"><link rel="prefetch" href="/blog/assets/js/29.40a388e9.js"><link rel="prefetch" href="/blog/assets/js/30.09ea8215.js"><link rel="prefetch" href="/blog/assets/js/31.6a746a11.js"><link rel="prefetch" href="/blog/assets/js/32.30794034.js"><link rel="prefetch" href="/blog/assets/js/33.8fe12a68.js"><link rel="prefetch" href="/blog/assets/js/34.6ae8ca61.js"><link rel="prefetch" href="/blog/assets/js/35.770b0123.js"><link rel="prefetch" href="/blog/assets/js/36.aecfaf6e.js"><link rel="prefetch" href="/blog/assets/js/37.9eaa4368.js"><link rel="prefetch" href="/blog/assets/js/38.9037e52f.js"><link rel="prefetch" href="/blog/assets/js/39.bfc61cab.js"><link rel="prefetch" href="/blog/assets/js/4.fc4084f6.js"><link rel="prefetch" href="/blog/assets/js/40.4037bb53.js"><link rel="prefetch" href="/blog/assets/js/41.5b45d852.js"><link rel="prefetch" href="/blog/assets/js/42.eda4343c.js"><link rel="prefetch" href="/blog/assets/js/43.f1402b09.js"><link rel="prefetch" href="/blog/assets/js/44.c8598baf.js"><link rel="prefetch" href="/blog/assets/js/45.394124a5.js"><link rel="prefetch" href="/blog/assets/js/46.d684210c.js"><link rel="prefetch" href="/blog/assets/js/47.b05a79df.js"><link rel="prefetch" href="/blog/assets/js/48.09f94403.js"><link rel="prefetch" href="/blog/assets/js/49.cffe09bd.js"><link rel="prefetch" href="/blog/assets/js/5.3f398ea8.js"><link rel="prefetch" href="/blog/assets/js/50.bbc144de.js"><link rel="prefetch" href="/blog/assets/js/51.29fb5c68.js"><link rel="prefetch" href="/blog/assets/js/52.d2042f8d.js"><link rel="prefetch" href="/blog/assets/js/53.274cd25d.js"><link rel="prefetch" href="/blog/assets/js/54.38b1f6bf.js"><link rel="prefetch" href="/blog/assets/js/55.466512f8.js"><link rel="prefetch" href="/blog/assets/js/56.3be1bfea.js"><link rel="prefetch" href="/blog/assets/js/57.c919083e.js"><link rel="prefetch" href="/blog/assets/js/58.88f9f57c.js"><link rel="prefetch" href="/blog/assets/js/59.d78a1017.js"><link rel="prefetch" href="/blog/assets/js/6.02a67347.js"><link rel="prefetch" href="/blog/assets/js/60.85f7e060.js"><link rel="prefetch" href="/blog/assets/js/61.7f5a0117.js"><link rel="prefetch" href="/blog/assets/js/62.107841bb.js"><link rel="prefetch" href="/blog/assets/js/63.e52b96f1.js"><link rel="prefetch" href="/blog/assets/js/64.68cd3b45.js"><link rel="prefetch" href="/blog/assets/js/65.4f8891d2.js"><link rel="prefetch" href="/blog/assets/js/66.d83bdb2e.js"><link rel="prefetch" href="/blog/assets/js/67.56a423d5.js"><link rel="prefetch" href="/blog/assets/js/68.b57a2648.js"><link rel="prefetch" href="/blog/assets/js/69.84ae7ab6.js"><link rel="prefetch" href="/blog/assets/js/7.e9a4f415.js"><link rel="prefetch" href="/blog/assets/js/70.8185c301.js"><link rel="prefetch" href="/blog/assets/js/71.e92a9144.js"><link rel="prefetch" href="/blog/assets/js/72.78fc6941.js"><link rel="prefetch" href="/blog/assets/js/73.ca28169a.js"><link rel="prefetch" href="/blog/assets/js/74.5ba3efb6.js"><link rel="prefetch" href="/blog/assets/js/75.65e4ac58.js"><link rel="prefetch" href="/blog/assets/js/76.19907955.js"><link rel="prefetch" href="/blog/assets/js/77.d93015d9.js"><link rel="prefetch" href="/blog/assets/js/78.011dc4e2.js"><link rel="prefetch" href="/blog/assets/js/79.8204d6d2.js"><link rel="prefetch" href="/blog/assets/js/8.de76593a.js"><link rel="prefetch" href="/blog/assets/js/80.55ae373f.js"><link rel="prefetch" href="/blog/assets/js/81.04f50a1e.js"><link rel="prefetch" href="/blog/assets/js/82.db879ca5.js"><link rel="prefetch" href="/blog/assets/js/83.e89b8863.js"><link rel="prefetch" href="/blog/assets/js/84.07410b58.js"><link rel="prefetch" href="/blog/assets/js/85.d46c8682.js"><link rel="prefetch" href="/blog/assets/js/86.52351591.js"><link rel="prefetch" href="/blog/assets/js/87.c4ebf9a8.js"><link rel="prefetch" href="/blog/assets/js/88.09fc332a.js"><link rel="prefetch" href="/blog/assets/js/89.8b302469.js"><link rel="prefetch" href="/blog/assets/js/9.41767da0.js"><link rel="prefetch" href="/blog/assets/js/90.391f76ed.js"><link rel="prefetch" href="/blog/assets/js/91.b9d1bb73.js"><link rel="prefetch" href="/blog/assets/js/92.a65aa479.js"><link rel="prefetch" href="/blog/assets/js/93.bc850b53.js"><link rel="prefetch" href="/blog/assets/js/94.7dc858d7.js"><link rel="prefetch" href="/blog/assets/js/95.83afadb6.js"><link rel="prefetch" href="/blog/assets/js/96.85084d66.js"><link rel="prefetch" href="/blog/assets/js/97.68a76e8c.js"><link rel="prefetch" href="/blog/assets/js/98.fdb7d67a.js"><link rel="prefetch" href="/blog/assets/js/99.c4b1cfd7.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.bef719fb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">一名GO+PHP工程师</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述" class="sidebar-heading clickable"><span>Go类型系统</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述.html" class="sidebar-link">Go类型系统概述</a></li><li><a href="/blog/开发基础/GO/Go类型系统/2指针.html" class="sidebar-link">指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/3结构体.html" class="sidebar-link">结构体</a></li><li><a href="/blog/开发基础/GO/Go类型系统/4值部.html" class="sidebar-link">值部</a></li><li><a href="/blog/开发基础/GO/Go类型系统/5数组、切片和映射.html" class="sidebar-link">数组、切片和映射</a></li><li><a href="/blog/开发基础/GO/Go类型系统/6通道.html" class="sidebar-link">通道</a></li><li><a href="/blog/开发基础/GO/Go类型系统/7方法.html" class="sidebar-link">方法</a></li><li><a href="/blog/开发基础/GO/Go类型系统/8接口.html" class="sidebar-link">接口</a></li><li><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html" class="sidebar-link">类型内嵌</a></li><li><a href="/blog/开发基础/GO/Go类型系统/10非类型安全指针.html" class="sidebar-link">非类型安全指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/11泛型.html" class="sidebar-link">泛型</a></li><li><a href="/blog/开发基础/GO/Go类型系统/12反射.html" class="sidebar-link">反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍" class="sidebar-heading clickable"><span>Go编程入门</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍.html" class="sidebar-link">程序源代码基本元素介绍</a></li><li><a href="/blog/开发基础/GO/Go编程入门/2关键字和标识符.html" class="sidebar-link">关键字和标识符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/3基本类型和它们的字面量表示.html" class="sidebar-link">基本类型和它们的字面量表示</a></li><li><a href="/blog/开发基础/GO/Go编程入门/4常量和变量.html" class="sidebar-link">常量和变量</a></li><li><a href="/blog/开发基础/GO/Go编程入门/5运算操作符.html" class="sidebar-link">运算操作符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/6函数声明和调用.html" class="sidebar-link">函数声明和调用</a></li><li><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html" class="sidebar-link">代码包和包引入</a></li><li><a href="/blog/开发基础/GO/Go编程入门/8表达式、语句和简单语句.html" class="sidebar-link">表达式、语句和简单语句</a></li><li><a href="/blog/开发基础/GO/Go编程入门/9基本流程控制语法.html" class="sidebar-link">基本流程控制语法</a></li><li><a href="/blog/开发基础/GO/Go编程入门/10协程、延迟函数调用、以及恐慌和恢复.html" class="sidebar-link">协程、延迟函数调用、以及恐慌和恢复</a></li><li><a href="/blog/开发基础/GO/Go编程入门/GO官方链接工具.html" class="sidebar-link">GO官方链接工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/其他文章/Go技巧" class="sidebar-heading clickable open"><span>其他文章</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/其他文章/Go技巧.html" class="sidebar-link">Go技巧</a></li><li><a href="/blog/开发基础/GO/其他文章/Go细节.html" class="sidebar-link">Go细节</a></li><li><a href="/blog/开发基础/GO/其他文章/Go问答.html" class="active sidebar-link">Go问答</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#编译器错误信息-non-name-on-left-side-of-意味着什么" class="sidebar-link">编译器错误信息 non-name *** on left side of := 意味着什么?</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#编译器错误信息-unexpected-newline-expecting-意味着什么" class="sidebar-link">编译器错误信息 unexpected newline, expecting { ... 意味着什么?</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#编译器错误信息-declared-and-not-used-意味着什么" class="sidebar-link">编译器错误信息 declared and not used 意味着什么?</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#go运行时是否维护映射条目的遍历顺序" class="sidebar-link">Go运行时是否维护映射条目的遍历顺序？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#go编译器是否会进行字节填充以确保结构体字段的地址对齐" class="sidebar-link">Go编译器是否会进行字节填充以确保结构体字段的地址对齐？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸" class="sidebar-link">为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#new-t-是-var-t-t-t-的语法糖吗" class="sidebar-link">new(T) 是 var t T; (&amp;t) 的语法糖吗？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#运行时错误信息-all-goroutines-are-asleep-deadlock-意味着什么" class="sidebar-link">运行时错误信息 all goroutines are asleep - deadlock 意味着什么?</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#_64位整数值的地址是否能保证总是64位对齐的-以便可以被安全地原子访问" class="sidebar-link">64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#赋值是原子操作吗" class="sidebar-link">赋值是原子操作吗？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#是否每一个零值在内存中占据的字节都是零" class="sidebar-link">是否每一个零值在内存中占据的字节都是零？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#标准的go编译器是否支持函数内联" class="sidebar-link">标准的Go编译器是否支持函数内联？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#终结器-finalizer-可以用做对象的析构函数吗" class="sidebar-link">终结器（finalizer）可以用做对象的析构函数吗？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#如何使用尽可能短的代码行数来获取任意月份的天数" class="sidebar-link">如何使用尽可能短的代码行数来获取任意月份的天数？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#函数调用-time-sleep-d-和通道接收-time-after-d-操作之间有何区别" class="sidebar-link">函数调用 time. Sleep(d) 和通道接收 &lt;-time. After(d) 操作之间有何区别？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#调用-strings-和-bytes-标准库包里-trimleft-和-trimright-函数经常会返回不符预期的结果-这些函数的实现存在bugs吗" class="sidebar-link">调用 strings 和 bytes 标准库包里 TrimLeft 和 TrimRight 函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#函数-fmt-print-和-fmt-println-的区别是什么" class="sidebar-link">函数 fmt. Print 和 fmt. Println 的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#函数-log-print-和函数-log-println-有什么区别吗" class="sidebar-link">函数 log. Print 和函数 log.Println 有什么区别吗?</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#函数-fmt-print-、-fmt-println-和-fmt-printf-的实现进行同步了吗" class="sidebar-link">函数 fmt. Print 、 fmt. Println 和 fmt. Printf 的实现进行同步了吗？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#内置的-print-和-println-函数与-fmt-和-log-标准库包中相应的打印函数有什么区别" class="sidebar-link">内置的 print 和 println 函数与 fmt 和 log 标准库包中相应的打印函数有什么区别？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#标准库包-math-rand-和-crypto-rand-生成的随机数之间有什么区别" class="sidebar-link">标准库包 math/rand 和 crypto/rand 生成的随机数之间有什么区别？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#标准库中为什么没有-math-round-函数" class="sidebar-link">标准库中为什么没有 math. Round 函数?</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#哪些类型不支持比较" class="sidebar-link">哪些类型不支持比较？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#为什么两个-nil-值有时候会不相等" class="sidebar-link">为什么两个 nil 值有时候会不相等？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#为什么类型-t1-和-t2-没有共享相同底层类型-即使不同的类型-t1-和-t2-共享相同的底层类型" class="sidebar-link">为什么类型 []T1 和 []T2 没有共享相同底层类型，即使不同的类型 T1 和 T2 共享相同的底层类型？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#哪些值可以被取地址-哪些值不可以被取地址" class="sidebar-link">哪些值可以被取地址，哪些值不可以被取地址？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#为什么映射元素不可被取地址" class="sidebar-link">为什么映射元素不可被取地址？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#为什么非空切片的元素总是可被取地址-即便对于不可寻址的切片也是如此" class="sidebar-link">为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#对任意的非指针和非接口定义类型-t-为什么类型-t-的方法集总是类型-t-的方法集的超集-但是反之却不然" class="sidebar-link">对任意的非指针和非接口定义类型 T ，为什么类型 *T 的方法集总是类型 T 的方法集的超集，但是反之却不然？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#我们可以为哪些类型声明方法" class="sidebar-link">我们可以为哪些类型声明方法？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#在go里如何声明不可变量" class="sidebar-link">在Go里如何声明不可变量？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#为什么没有内置的-set-容器类型" class="sidebar-link">为什么没有内置的 set 容器类型？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#什么是byte-什么是rune-如何将-byte-和-rune-类型的值转换为字符串" class="sidebar-link">什么是byte？什么是rune？ 如何将 []byte 和 []rune 类型的值转换为字符串？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#如何原子地操作指针值" class="sidebar-link">如何原子地操作指针值？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#iota-是什么意思" class="sidebar-link">iota 是什么意思？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#为什么没有一个内置的-closed-函数用来检查通道是否已经关闭" class="sidebar-link">为什么没有一个内置的 closed 函数用来检查通道是否已经关闭？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#函数返回局部变量的指针是否安全" class="sidebar-link">函数返回局部变量的指针是否安全？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/其他文章/Go问答.html#单词-gopher-在go社区中表示什么" class="sidebar-link">单词*gopher*在Go社区中表示什么？</a></li></ul></li><li><a href="/blog/开发基础/GO/其他文章/命令-mod.html" class="sidebar-link">命令-mod</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Golang的time.NewTimer单次定时器使用案例.html" class="sidebar-link">基础-Golang的time. NewTimer单次定时器使用案例</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go中的nil.html" class="sidebar-link">Go中的 nil</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go代码断行规则.html" class="sidebar-link">Go代码断行规则</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-表达式估值顺序规则.html" class="sidebar-link">表达式估值顺序规则</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/学习资料" class="sidebar-heading clickable"><span>GO</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/学习资料.html" class="sidebar-link">教学书籍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/并发编程/1并发同步概述" class="sidebar-heading clickable"><span>并发编程</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/并发编程/1并发同步概述.html" class="sidebar-link">并发同步概述</a></li><li><a href="/blog/开发基础/GO/并发编程/2通道用例大全.html" class="sidebar-link">通道用例大全</a></li><li><a href="/blog/开发基础/GO/并发编程/3如何优雅地关闭通道.html" class="sidebar-link">如何优雅地关闭通道</a></li><li><a href="/blog/开发基础/GO/并发编程/4其它并发同步技术.html" class="sidebar-link">sync 标准库包中提供的并发同步技术</a></li><li><a href="/blog/开发基础/GO/并发编程/5原子操作 .html" class="sidebar-link">sync/atomic 标准库包中提供的原子操作</a></li><li><a href="/blog/开发基础/GO/并发编程/6Go中的内存顺序保证.html" class="sidebar-link">Go中的内存顺序保证</a></li><li><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html" class="sidebar-link">一些常见并发编程错误</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境" class="sidebar-heading clickable"><span>开发环境搭建</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境.html" class="sidebar-link">Docker和VS Code的Go开发环境</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="go问答"><a href="#go问答" class="header-anchor">#</a> Go问答</h1> <h2 id="编译器错误信息-non-name-on-left-side-of-意味着什么"><a href="#编译器错误信息-non-name-on-left-side-of-意味着什么" class="header-anchor">#</a> 编译器错误信息 <code>non-name *** on left side of :=</code> 意味着什么?</h2> <p>直到目前（Go 1.16）, Go中对短变量声明有一个<a href="https://golang.google.cn/ref/spec#Short_variable_declarations" target="_blank" rel="noopener noreferrer">强制性约束<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <p>所有位于 <code>:=</code> 符号左侧的条目都必须是纯<a href="https://golang.google.cn/ref/spec#Identifiers" target="_blank" rel="noopener noreferrer">标识符<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，并且其中至少有一个为新变量名称。</p> <p>这意味着容器元素索引表达式（ <code>x[i]</code> ）、结构体的字段选择器（ <code>x.f</code> ）、指针解引用（ <code>*p</code> ）和限定标识符（ <code>aPackage. Value</code> ）都不能出现在 <code>:=</code> 符号的左侧。</p> <p>目前，这还是一个<a href="https://github.com/golang/go/issues/377" target="_blank" rel="noopener noreferrer">未解决问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（已经和<a href="https://github.com/golang/go/issues/6842" target="_blank" rel="noopener noreferrer">一个相关问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>合并）。而且感觉Go核心开发团队目前<a href="https://github.com/golang/go/issues/30318" target="_blank" rel="noopener noreferrer">并未有立即解决此问题的打算<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="编译器错误信息-unexpected-newline-expecting-意味着什么"><a href="#编译器错误信息-unexpected-newline-expecting-意味着什么" class="header-anchor">#</a> 编译器错误信息 <code>unexpected newline, expecting { ...</code> 意味着什么?</h2> <p>在编写Go代码时，我们不能随意断行。 请阅读<a href="https://gfw.go101.org/article/line-break-rules.html" target="_blank" rel="noopener noreferrer">代码断行规则<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文以了解Go代码断行规则。 一般来说，根据这些规则，在左括号之前断行是不合法的。</p> <p>例如，下列代码片段</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">if</span> <span class="token boolean">true</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
<span class="token punctuation">{</span>
	<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre></div><p>将会被编译器解释成</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">if</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
	<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Go编译器将为每个左大括号 <code>{</code> 起始的代码行报告一个语法错误。 为避免这些报错，我们需要将上述代码重写为下面这样：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="编译器错误信息-declared-and-not-used-意味着什么"><a href="#编译器错误信息-declared-and-not-used-意味着什么" class="header-anchor">#</a> 编译器错误信息 <code>declared and not used</code> 意味着什么?</h2> <p>对于标准编译器，在局部代码块中声明的每一个变量必须被至少一次用做r-value（right-hand-side value，右值）。</p> <p>因此，下列代码将编译失败，因为 <code>y</code> 只被用做目标值（目标值都为左值）。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>x <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// y被声明了但没有被用做右值</span>
	<span class="token keyword">if</span> x <span class="token punctuation">{</span>
		y <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// 这里，y被用做左值</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="go运行时是否维护映射条目的遍历顺序"><a href="#go运行时是否维护映射条目的遍历顺序" class="header-anchor">#</a> Go运行时是否维护映射条目的遍历顺序？</h2> <p>不。<a href="https://golang.google.cn/ref/spec#For_range" target="_blank" rel="noopener noreferrer">Go白皮书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>明确提到映射元素的迭代顺序时未定义的。 所以对于同一个映射值，它的一个遍历过程和下一个遍历过程中的元素呈现次序不保证是相同的。 对于标准编译器，映射元素的遍历顺序是随机的。 如果你需要固定的映射元素遍历顺序，那么你就需要自己来维护这个顺序。 更多信息请阅读Go官方博客文章<a href="https://blog.golang.com/go-maps-in-action#TOC_7." target="_blank" rel="noopener noreferrer">Go maps in action<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>但是请注意：从Go 1.12开始，标准库包中的各个打印函数的结果中，映射条目总是排了序的。</p> <h2 id="go编译器是否会进行字节填充以确保结构体字段的地址对齐"><a href="#go编译器是否会进行字节填充以确保结构体字段的地址对齐" class="header-anchor">#</a> Go编译器是否会进行字节填充以确保结构体字段的地址对齐？</h2> <p>至少对于标准的Go编译器和gccgo，答案是肯定的。 具体需要填充多少个字节取决于操作系统和编译器实现。 请阅读<a href="https://gfw.go101.org/article/memory-layout.html#size-and-padding" target="_blank" rel="noopener noreferrer">关于Go值的内存布局<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文获取详情。</p> <p>Go编译器将不会重新排列结构体的字段来最小化结构体值的尺寸。 因为这样做会导致意想不到的结果。 但是，根据需要，程序员可以手工重新排序字段来实现填充最小化。</p> <h2 id="为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸"><a href="#为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸" class="header-anchor">#</a> 为什么一个结构体类型的最后一个字段类型的尺寸为零时会影响此结构体的尺寸？</h2> <p>一个可寻址的结构值的所有字段都可以被取地址。 如果非零尺寸的结构体值的最后一个字段的尺寸是零，那么取此最后一个字段的地址将会返回一个越出了为此结构体值分配的内存块的地址。 这个返回的地址可能指向另一个被分配的内存块。 在目前的官方Go标准运行时的实现中，如果一个内存块被至少一个依然活跃的指针引用，那么这个内存块将不会被视作垃圾因而肯定不会被回收。 所以只要有一个活跃的指针存储着此非零尺寸的结构体值的最后一个字段的越界地址，它将阻止垃圾收集器回收另一个内存块，从而可能导致内存泄漏。</p> <p>为避免上述问题，标准的Go编译器会确保取一个非零尺寸的结构体值的最后一个字段的地址时，绝对不会返回越出分配给此结构体值的内存块的地址。 Go标准编译器通过在需要时在结构体最后的零尺寸字段之后填充一些字节来实现这一点。</p> <p>如果一个结构体的全部字段的类型都是零尺寸的(因此整个结构体也是零尺寸的)，那么就不需要再填充字节，因为标准编译器会专门处理零尺寸的内存块。</p> <p>一个例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;unsafe&quot;</span>
	<span class="token string">&quot;fmt&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">type</span> T1 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
		a <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
		x <span class="token builtin">int64</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>T1<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 8</span>

	<span class="token keyword">type</span> T2 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
		x <span class="token builtin">int64</span>
		a <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>T2<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 16</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="new-t-是-var-t-t-t-的语法糖吗"><a href="#new-t-是-var-t-t-t-的语法糖吗" class="header-anchor">#</a> <code>new(T)</code> 是 <code>var t T; (&amp;t)</code> 的语法糖吗？</h2> <p>虽然这两者在实现上会有一些微妙的差别，取决于编译器的具体实现，但是我们基本上可以认为这两者是等价的。 即，通过 <code>new</code> 函数分配的内存块可以在栈上，也可以在堆上。</p> <h2 id="运行时错误信息-all-goroutines-are-asleep-deadlock-意味着什么"><a href="#运行时错误信息-all-goroutines-are-asleep-deadlock-意味着什么" class="header-anchor">#</a> 运行时错误信息 <code>all goroutines are asleep - deadlock</code> 意味着什么?</h2> <p>用词**<em>asleep*<strong>在这里其实并不准确，实际上它的意思是</strong><em>处于阻塞状态*</em></em>。</p> <p>因为一个处于阻塞状态的协程只能被另一个协程解除阻塞，如果程序中所有的协程都进入了阻塞状态，则它们将永远都处于阻塞状态。 这意味着程序死锁了。一个正常运行的程序永远不应该死锁，一个死锁的程序肯定是由于逻辑实现上的bug造成的。 因此官方Go标准运行时将在一个程序死锁时令其崩溃退出。</p> <h2 id="_64位整数值的地址是否能保证总是64位对齐的-以便可以被安全地原子访问"><a href="#_64位整数值的地址是否能保证总是64位对齐的-以便可以被安全地原子访问" class="header-anchor">#</a> 64位整数值的地址是否能保证总是64位对齐的，以便可以被安全地原子访问？</h2> <p>传递给 <code>sync/atomic</code> 标准库包中的64位函数的地址必须是64位对齐的，否则调用这些函数将在运行时导致恐慌产生。</p> <p>对于标准编译器和gccgo编译器，在64位架构下，64位整数的地址将保证总是64位对齐的。 所以它们总是可以被安全地原子访问。 但在32位架构下，64位整数的地址仅保证是32位对齐的。 所以原子访问某些64位整数可能会导致恐慌。 但是，有一些方法可以保证一些64位整数总是可以被安全地原子访问。 请阅读<a href="https://gfw.go101.org/article/memory-layout.html#64bit-atomic-operation" target="_blank" rel="noopener noreferrer">关于Go值的内存布局<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文以获得详情。</p> <h2 id="赋值是原子操作吗"><a href="#赋值是原子操作吗" class="header-anchor">#</a> 赋值是原子操作吗？</h2> <p>对于标准编译器来说，赋值不是原子操作。</p> <p>请阅读<a href="https://golang.google.cn/doc/faq#What_operations_are_atomic_What_about_mutexes" target="_blank" rel="noopener noreferrer">官方FAQ中的此问答<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>以了解更多。</p> <h2 id="是否每一个零值在内存中占据的字节都是零"><a href="#是否每一个零值在内存中占据的字节都是零" class="header-anchor">#</a> 是否每一个零值在内存中占据的字节都是零？</h2> <p>对于大部分类型，答案是肯定的。不过事实上，这依赖于编译器。 例如，对于标准编译器，对于某些字符串类型的零值，此结论并不十分正确。</p> <p>比如:</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;unsafe&quot;</span>
	<span class="token string">&quot;fmt&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> s1 <span class="token builtin">string</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0</span>
	<span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 4869856</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>反过来，对于标准编译器已经支持的所有架构，如果一个值的所有字节都是零，那么这个值肯定是它的类型的零值。 然而，Go规范并没有保证这一点。我曾听说在某些比较老的处理器上，空指针表示的内存地址并不为零。</p> <h2 id="标准的go编译器是否支持函数内联"><a href="#标准的go编译器是否支持函数内联" class="header-anchor">#</a> 标准的Go编译器是否支持函数内联？</h2> <p>是的，标准编译器支持函数内联。编译器会自动内联一些满足某些条件的短小函数。这些内联条件可能会在不同编译器版本之间发生变化。</p> <p>目前（Go 1.16），对于标准编译器，</p> <ul><li>没有显式的方式来在用户代码中指定哪些函数应该被内联。</li> <li>尽管编译参数<code>-gcflags &quot;-l&quot;</code>可以阻止任何函数被内联， 但是并没有一个正式的方式来避免某个特定的用户函数被内联。 目前我们可以在函数声明前增加一行<code>//go:noinline</code> 指令来避免这个函数被内联。 但是此方式不保证永久有效。</li></ul> <h2 id="终结器-finalizer-可以用做对象的析构函数吗"><a href="#终结器-finalizer-可以用做对象的析构函数吗" class="header-anchor">#</a> 终结器（finalizer）可以用做对象的析构函数吗？</h2> <p>在Go程序里，我们可以通过调用 <code>runtime. SetFinalizer</code> 函数来给一个对象设置一个终结器函数。 一般说来，此终结器函数将在此对象被垃圾回收之前调用。 但是终结器并非被设计为对象的析构函数。 通过 <code>runtime. SetFinalizer</code> 函数设置的终结器函数并不保证总会被运行。 因此我们不应该依赖于终结器来保证程序的正确性。</p> <p>终结器的主要用途是为了库包的维护者能够尽可能地避免因为库包使用者不正确地使用库包而带来的危害。 例如，我们知道，当在程序中使用完某个文件后，我们应该将其关闭。 但是有时候因为种种原因，比如经验不足或者粗心大意，导致一些文件在使用完成后并未被关闭，那么和这些文件相关的很多资源只有在此程序退出之后才能得到释放。这属于资源泄漏。 为了尽可能地避免防止资源泄露， <code>os</code> 库包的维护者将会在一个 <code>os. File</code> 对象被被创建的时候为之设置一个终结器。 此终结器函数将关闭此 <code>os. File</code> 对象。当此 <code>os. File</code> 对象因为不再被使用而被垃圾回收的时候，此终结器函数将被调用。</p> <p>请记住，有一些终结器函数永远不会被调用，并且有时候不当的设置终结器函数将会阻止对象被垃圾回收。 关于更多细节，请阅读<a href="https://golang.google.cn/pkg/runtime/#SetFinalizer" target="_blank" rel="noopener noreferrer">runtime. SetFinalizer函数的文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="如何使用尽可能短的代码行数来获取任意月份的天数"><a href="#如何使用尽可能短的代码行数来获取任意月份的天数" class="header-anchor">#</a> 如何使用尽可能短的代码行数来获取任意月份的天数？</h2> <p>假设输入的年份是一个自然年，并且输入的月份也是一个自然月（1代表1月）。</p> <div class="language-go extra-class"><pre class="language-go"><code>days <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span>year<span class="token punctuation">,</span> month<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>UTC<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>对于Go中的 <code>time</code> 标准库包，正常月份的去值范围为 <code>[1, 12]</code> ，并且每个月的起始日是 <code>1</code> 。 所以， <code>y</code> 年的 <code>m</code> 月的起始时间就是 <code>time. Date(y, m, 1, 0, 0, 0, 0, time. UTC)</code> 。</p> <p>传递给 <code>time. Date</code> 函数的实参可以超出它们的正常范围，此函数将这些实参进行规范化。 例如，1月32日会被转换成2月1日。</p> <p>以下是一些Go语言里的日期使用示例：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;time&quot;</span>
	<span class="token string">&quot;fmt&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 2017-02-01 00:00:00 +0000 UTC</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>UTC<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// 2017-01-31 23:59:59.999999999 +0000 UTC</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>UTC<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// 2017-01-31 00:00:00 +0000 UTC</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2017</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>UTC<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// 2016-12-31 00:00:00 +0000 UTC</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>UTC<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// 2017-02-01 00:00:00 +0000 UTC</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>UTC<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="函数调用-time-sleep-d-和通道接收-time-after-d-操作之间有何区别"><a href="#函数调用-time-sleep-d-和通道接收-time-after-d-操作之间有何区别" class="header-anchor">#</a> 函数调用 <code>time. Sleep(d)</code> 和通道接收 <code>&lt;-time. After(d)</code> 操作之间有何区别？</h2> <p>两者都会将当前的goroutine执行暂停一段时间。 区别在于 <code>time. Sleep(d)</code> 函数调用将使当前的协程进入睡眠字状态，但是当前协程的<a href="https://gfw.go101.org/article/control-flows-more.html#states-of-goroutine" target="_blank" rel="noopener noreferrer">（主）状态<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>依然为运行状态； 而通道接收 <code>&lt;-time. After(d)</code> 操作将使当前协程进入阻塞状态。</p> <h2 id="调用-strings-和-bytes-标准库包里-trimleft-和-trimright-函数经常会返回不符预期的结果-这些函数的实现存在bugs吗"><a href="#调用-strings-和-bytes-标准库包里-trimleft-和-trimright-函数经常会返回不符预期的结果-这些函数的实现存在bugs吗" class="header-anchor">#</a> 调用 <code>strings</code> 和 <code>bytes</code> 标准库包里 <code>TrimLeft</code> 和 <code>TrimRight</code> 函数经常会返回不符预期的结果，这些函数的实现存在bugs吗？</h2> <p>哈，我们不能保证这些函数的实现绝对没有bug，但是如果这些函数返回的结果是不符你的预期，更有可能的是你的期望是不正确的。</p> <p>标准包 <code>strings</code> 和 <code>bytes</code> 里有多个修剪（trim）函数。 这些函数可以被分类为两组：</p> <ol><li><code>Trim</code>、<code>TrimLeft</code>、<code>TrimRight</code>、<code>TrimSpace</code>、<code>TrimFunc</code>、<code>TrimLeftFunc</code>和<code>TrimRightFunc</code>。 这些函数将修剪首尾所有满足指定（或隐含）条件的utf-8编码的Unicode码点(即rune)。（<code>TrimSpace</code>隐含了修剪各种空格符。） 这些函数将检查每个开头或结尾的rune值，直到遇到一个不满足条件的rune值为止。</li> <li><code>TrimPrefix</code>和<code>TrimSuffix</code>。 这两个函数会把指定前缀或后缀的子字符串（或子切片）作为一个整体进行修剪。</li></ol> <p><a href="https://github.com/golang/go/issues/19172" target="_blank" rel="noopener noreferrer">部分<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><a href="https://github.com/golang/go/issues/18160" target="_blank" rel="noopener noreferrer">程序员<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><a href="https://github.com/golang/go/issues/14657" target="_blank" rel="noopener noreferrer">会<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>把 <code>TrimLeft</code> 和 <code>TrimRight</code> 函数当作 <code>TrimPrefix</code> 和 <code>TrimSuffix</code> 函数而<a href="https://github.com/golang/go/issues/19371" target="_blank" rel="noopener noreferrer">误用<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。 自然地，函数返回的结果很可能不是预期的那样。</p> <p>例如:</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;strings&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">&quot;abaay森z众xbbab&quot;</span>
	o <span class="token operator">:=</span> fmt<span class="token punctuation">.</span>Println
	<span class="token function">o</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">TrimPrefix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// aay森z众xbbab</span>
	<span class="token function">o</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">TrimSuffix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// abaay森z众xbb</span>
	<span class="token function">o</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">TrimLeft</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// y森z众xbbab</span>
	<span class="token function">o</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">TrimRight</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// abaay森z众x</span>
	<span class="token function">o</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Trim</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment">// y森z众x</span>
	<span class="token function">o</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">TrimFunc</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> r <span class="token operator">&lt;</span> <span class="token number">128</span> <span class="token comment">// trim all ascii chars</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 森z众</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="函数-fmt-print-和-fmt-println-的区别是什么"><a href="#函数-fmt-print-和-fmt-println-的区别是什么" class="header-anchor">#</a> 函数 <code>fmt. Print</code> 和 <code>fmt. Println</code> 的区别是什么？</h2> <p><code>fmt. Println</code> 函数总会在两个相邻的参数之间输出一个空格，然而 <code>fmt. Print</code> 函数仅当两个相邻的参数（的具体值）都不是字符串类型时才会在它们之间输出一个空格。</p> <p>另外一个区别是 <code>fmt. Println</code> 函数会在结尾写入一个换行符，但是 <code>fmt. Print</code> 函数不会。</p> <h2 id="函数-log-print-和函数-log-println-有什么区别吗"><a href="#函数-log-print-和函数-log-println-有什么区别吗" class="header-anchor">#</a> 函数 <code>log. Print</code> 和函数 <code>log.Println</code> 有什么区别吗?</h2> <p>函数 <code>log. Print</code> 与 <code>log. Println</code> 的区别与上一个问题里描述的关于函数 <code>fmt. Print</code> 和 <code>fmt. Println</code> 的第一个区别点类似。</p> <p>这两个函数都会在结尾输出一个换行符。</p> <h2 id="函数-fmt-print-、-fmt-println-和-fmt-printf-的实现进行同步了吗"><a href="#函数-fmt-print-、-fmt-println-和-fmt-printf-的实现进行同步了吗" class="header-anchor">#</a> 函数 <code>fmt. Print</code> 、 <code>fmt. Println</code> 和 <code>fmt. Printf</code> 的实现进行同步了吗？</h2> <p>没有。 如果有同步的需求，请使用 <code>log</code> 标准库包里的相应函数。 你可以调用 <code>log. SetFlags(0)</code> 来避免每一个日志行的前缀输出。</p> <h2 id="内置的-print-和-println-函数与-fmt-和-log-标准库包中相应的打印函数有什么区别"><a href="#内置的-print-和-println-函数与-fmt-和-log-标准库包中相应的打印函数有什么区别" class="header-anchor">#</a> 内置的 <code>print</code> 和 <code>println</code> 函数与 <code>fmt</code> 和 <code>log</code> 标准库包中相应的打印函数有什么区别？</h2> <p>除了上一个问题里提到的区别之外，这三组函数之间还有一些其他区别。</p> <ol><li>内置的<code>print</code>/<code>println</code>函数总是写入标准错误。 <code>fmt</code>标准包里的打印函数总是写入标准输出。 <code>log</code>标准包里的打印函数会默认写入标准错误，然而也可以通过<code>log.SetOutput</code>函数来配置。</li> <li>内置<code>print</code>/<code>println</code>函数的调用不能接受数组和结构体参数。</li> <li>对于组合类型的参数，内置的<code>print</code>/<code>println</code>函数将输出参数的底层值部的地址，而<code>fmt</code>和<code>log</code>标准库包中的打印函数将输出接口参数的动态值的字面形式。</li> <li>目前（Go 1.16），对于标准编译器，调用内置的<code>print</code>/<code>println</code>函数不会使调用参数引用的值逃逸到堆上，而<code>fmt</code>和<code>log</code>标准库包中的打印函数将使调用参数引用的值逃逸到堆上。</li> <li>如果一个实参有<code>String() string</code>或<code>Error() string</code>方法，那么<code>fmt</code>和<code>log</code>标准库包里的打印函数在打印参数时会调用这两个方法，而内置的<code>print</code>/<code>println</code>函数则会忽略参数的这些方法。</li> <li>内置的<code>print</code>/<code>println</code>函数不保证在未来的Go版本中继续存在。</li></ol> <h2 id="标准库包-math-rand-和-crypto-rand-生成的随机数之间有什么区别"><a href="#标准库包-math-rand-和-crypto-rand-生成的随机数之间有什么区别" class="header-anchor">#</a> 标准库包 <code>math/rand</code> 和 <code>crypto/rand</code> 生成的随机数之间有什么区别？</h2> <p>通过 <code>math/rand</code> 标准库包生成的伪随机数序列对于给定的种子是确定的。 这样生成的随机数不适用于安全敏感的环境中。 如果处于加密安全目的，我们应该使用 <code>crypto/rand</code> 标准库包生成的伪随机数序列。</p> <h2 id="标准库中为什么没有-math-round-函数"><a href="#标准库中为什么没有-math-round-函数" class="header-anchor">#</a> 标准库中为什么没有 <code>math. Round</code> 函数?</h2> <p><code>math. Round</code> 函数是有的，但是只是从Go 1.10开始才有这个函数。 从Go 1.10开始，标准库添加了两个新函数 <code>math. Round</code> 和 <code>math. RoundToEven</code> 。</p> <p>在Go 1.10之前，关于 <code>math. Round</code> 函数是否应该被添加进标准包，经历了<a href="https://github.com/golang/go/issues/4594" target="_blank" rel="noopener noreferrer">很长时候的讨论<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="哪些类型不支持比较"><a href="#哪些类型不支持比较" class="header-anchor">#</a> 哪些类型不支持比较？</h2> <p>下列类型不支持比较：</p> <ul><li>映射（map）</li> <li>切片</li> <li>函数</li> <li>包含不可比较字段的结构体类型</li> <li>元素类型为不可比较类型的数组类型</li></ul> <p>不支持比较的类型不能用做映射类型的键值类型。</p> <p>请注意：</p> <ul><li>尽管映射，切片和函数值不支持比较，但是它们的值可以与类型不确定的<code>nil</code>标识符比较。</li> <li>如果两个接口值的动态类型相同且不可比较，那么在运行时<a href="https://gfw.go101.org/article/interface.html#comparison" target="_blank" rel="noopener noreferrer">比较这两个接口的值<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>会产生一个恐慌。</li></ul> <p>关于为什么映射，切片和函数不支持比较，请阅读Go的官方FAQ中<a href="https://golang.google.cn/doc/faq#map_keys" target="_blank" rel="noopener noreferrer">关于这个问答<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="为什么两个-nil-值有时候会不相等"><a href="#为什么两个-nil-值有时候会不相等" class="header-anchor">#</a> 为什么两个 <code>nil</code> 值有时候会不相等？</h2> <p><em>（Go官方FAQ中的<a href="https://golang.google.cn/doc/faq#nil_error" target="_blank" rel="noopener noreferrer">这个答案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>也回答了这个问题。）</em></p> <p>一个接口值可以看作是一个包裹非接口值的盒子。被包裹在一个接口值中的非接口值的类型必须实现了此接口值的类型。 在Go中，很多种类型的类型的零值都是用 <code>nil</code> 来表示的。 一个什么都没包裹的接口值为一个零值接口值，即nil接口值。 一个包裹着其它非接口类型的nil值的接口值并非什么都没包裹，所以它不是（或者说它不等于）一个nil接口值。</p> <p>当对一个nil接口值和一个nil非接口值进行比较时（假设它们可以比较），此nil非接口值将先被转换为nil接口值的类型，然后再进行比较； 此转换的结果为一个包裹了此nil非接口值的一个副本的接口值，此接口值不是（或者说它不等于）一个nil接口值，所以此比较不相等。</p> <p>关于更详细的解释请阅读<a href="https://gfw.go101.org/article/interface.html" target="_blank" rel="noopener noreferrer">接口<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://gfw.go101.org/article/nil.html" target="_blank" rel="noopener noreferrer">关于Go中的 <code>nil</code> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>两篇文章。</p> <p>一个示例：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> pi <span class="token operator">*</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token keyword">var</span> pb <span class="token operator">*</span><span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
	<span class="token keyword">var</span> x <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> pi
	<span class="token keyword">var</span> y <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> pb
	<span class="token keyword">var</span> z <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token boolean">nil</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span>   <span class="token comment">// false</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> z<span class="token punctuation">)</span>   <span class="token comment">// false</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>y <span class="token operator">==</span> z<span class="token punctuation">)</span>   <span class="token comment">// false</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="为什么类型-t1-和-t2-没有共享相同底层类型-即使不同的类型-t1-和-t2-共享相同的底层类型"><a href="#为什么类型-t1-和-t2-没有共享相同底层类型-即使不同的类型-t1-和-t2-共享相同的底层类型" class="header-anchor">#</a> 为什么类型 <code>[]T1</code> 和 <code>[]T2</code> 没有共享相同底层类型，即使不同的类型 <code>T1</code> 和 <code>T2</code> 共享相同的底层类型？</h2> <p><em>（不久前，Go官方FAQ也增加了<a href="https://golang.google.cn/doc/faq#convert_slice_with_same_underlying_type" target="_blank" rel="noopener noreferrer">一个相似的问题<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。）</em></p> <p>在Go语言中，仅当两个切片类型共享相同的<a href="https://gfw.go101.org/article/type-system-overview.html#underlying-type" target="_blank" rel="noopener noreferrer">底层类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>时，其中一个切片类型才可以转换成另一个切片的类型而不需要使用<a href="https://gfw.go101.org/article/unsafe.html" target="_blank" rel="noopener noreferrer"><code>unsafe</code> 机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>一个非定义组合类型的底层类型是此组合类型本身。 所以即便两个不同的类型 <code>T1</code> 和 <code>T2</code> 共享相同的底层类型，类型 <code>[]T1</code> 和 <code>[]T2</code> 也依然是不同的类型，因此它们的底层类型也是不同的。这意味着其中一个的值不能转换为另一个。</p> <p>底层类型 <code>[]T1</code> 和 <code>[]T2</code> 不同的原因是：</p> <ul><li>把<code>[]T1</code>和<code>[]T2</code>的值相互转换的需求在实践中并不常见。</li> <li>使得<a href="https://gfw.go101.org/article/type-system-overview.html#underlying-type" target="_blank" rel="noopener noreferrer">底层类型的溯源规则<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>更加简单。</li></ul> <p>同样的原因也适用于其它组合类型。 例如：类型 <code>map[T]T1</code> 和 <code>map[T]T2</code> 同样不共享相同的底层类型，即便 <code>T1</code> 和 <code>T2</code> 共享相同的底层类型。</p> <p>类型 <code>[]T1</code> 的值时候有可能通过使用 <code>unsafe</code> 机制转换成 <code>[]T2</code> 的，但是一般不建议这么做：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;unsafe&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">type</span> MyInt <span class="token builtin">int</span>

	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span>
	<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span><span class="token punctuation">]</span>MyInt<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
	b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">123</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// [123 8 9]</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// [123 8 9]</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%T \n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">// []int</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%T \n&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">// []main.MyInt</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="哪些值可以被取地址-哪些值不可以被取地址"><a href="#哪些值可以被取地址-哪些值不可以被取地址" class="header-anchor">#</a> 哪些值可以被取地址，哪些值不可以被取地址？</h2> <p>以下的值是不可以寻址的：</p> <ul><li>字符串的字节元素</li> <li>映射元素</li> <li>接口值的动态值（类型断言的结果）</li> <li>常量（包括有名常量和字面量）</li> <li>声明的包级别函数</li> <li>方法（用做函数值）</li> <li>中间结果值
<ul><li>函数调用</li> <li>显式值转换</li> <li>各种操作，不包含指针解引用（dereference）操作，但是包含：
<ul><li>通道接收操作</li> <li>子字符串操作</li> <li>子切片操作</li> <li>加法、减法、乘法、以及除法等等。</li></ul></li></ul></li></ul> <p>请注意： <code>&amp;T{}</code> 在Go里是一个语法糖，它是 <code>tmp := T{}; (&amp;tmp)</code> 的简写形式。 所以 <code>&amp;T{}</code> 是合法的并不代表字面量 <code>T{}</code> 是可寻址的。</p> <p>以下的值是可寻址的，因此可以被取地址：</p> <ul><li>变量</li> <li>可寻址的结构体的字段</li> <li>可寻址的数组的元素</li> <li>任意切片的元素（无论是可寻址切片或不可寻址切片）</li> <li>指针解引用（dereference）操作</li></ul> <h2 id="为什么映射元素不可被取地址"><a href="#为什么映射元素不可被取地址" class="header-anchor">#</a> 为什么映射元素不可被取地址？</h2> <p>在Go中，映射的设计保证一个映射值在内存允许的情况下可以加入任意个条目。 另外为了防止一个映射中为其条目开辟的内存段支离破碎，官方标准编译器使用了哈希表来实现映射。 并且为了保证元素索引的效率，一个映射值的底层哈希表只为其中的所有条目维护一段连续的内存段。 因此，一个映射值随着其中的条目数量逐渐增加时，其维护的连续的内存段需要不断重新开辟来增容，并把原来内存段上的条目全部复制到新开辟的内存段上。 另外，即使一个映射值维护的内存段没有增容，某些哈希表实现也可能在当前内存段中移动其中的条目。 总之，映射中的元素的地址会因为各种原因而改变。 如果映射元素可以被取地址，则Go运行时（runtime）必须在元素地址改变的时候修改所有存储了元素地址的指针值。 这极大得增加了Go编译器和运行时的实现难度，并且严重影响了程序运行效率。 因此，目前，Go中禁止取映射元素的地址。</p> <p>映射元素不可被取地址的另一个原因是表达式 <code>aMap[key]</code> 可能返回一个存储于 <code>aMap</code> 中的元素，也可能返回一个不存储于其中的元素零值。 这意味着表达式 <code>aMap[key]</code> 在 <code>(&amp;aMap[key]). Modify()</code> 调用执行之后可能仍然被估值为元素零值。 这将使很多人感到困惑，因此在Go中禁止取映射元素的地址。</p> <h2 id="为什么非空切片的元素总是可被取地址-即便对于不可寻址的切片也是如此"><a href="#为什么非空切片的元素总是可被取地址-即便对于不可寻址的切片也是如此" class="header-anchor">#</a> 为什么非空切片的元素总是可被取地址，即便对于不可寻址的切片也是如此？</h2> <p>切片的内部类型是一个结构体，类似于</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">struct</span> <span class="token punctuation">{</span>
	elements unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 引用着一个元素序列</span>
	length   <span class="token builtin">int</span>
	capacity <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每一个切片间接引用一个元素序列。 尽管一个非空切片是不可取地址的，它的内部元素序列需要开辟在内存中的某处因而必须是可取地址的。 取一个切片的元素地址事实上是取内部元素序列上的元素地址。 因此，不可寻址的非空切片的元素也是可以被取地址的。</p> <h2 id="对任意的非指针和非接口定义类型-t-为什么类型-t-的方法集总是类型-t-的方法集的超集-但是反之却不然"><a href="#对任意的非指针和非接口定义类型-t-为什么类型-t-的方法集总是类型-t-的方法集的超集-但是反之却不然" class="header-anchor">#</a> 对任意的非指针和非接口定义类型 <code>T</code> ，为什么类型 <code>*T</code> 的方法集总是类型 <code>T</code> 的方法集的超集，但是反之却不然？</h2> <p>在Go语言中，为了方便，对于一个非指针和非接口定义类型 <code>T</code> ，</p> <ul><li>一个<code>T</code>类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此<code>T</code>的值是可寻址的情况下。 编译器在调用指针属主方法前，会自动取此<code>T</code>值的地址。 因为不是任何<code>T</code>值都是可寻址的，所以并非任何<code>T</code>值都能够调用为类型<code>*T</code>声明的方法。 这种便利只是一个语法糖，而不是一种固有的规则。</li> <li>一个<code>*T</code>类型的值可以调用为类型<code>T</code>声明的方法。 这是因为解引用指针总是合法的。 这种便利不仅仅是一个语法糖，它也是一种固有的规则。</li></ul> <p>所以很合理的， <code>*T</code> 的方法集总是 <code>T</code> 方法集的超集，但反之不然。</p> <p>事实上，你可以认为对于每一个为类型 <code>T</code> 声明的方法，编译器都会为类型 <code>*T</code> 自动隐式声明一个同名和同签名的方法。 详见<a href="https://gfw.go101.org/article/method.html#implicit-pointer-methods" target="_blank" rel="noopener noreferrer">方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>t T<span class="token punctuation">)</span> <span class="token function">MethodX</span><span class="token punctuation">(</span>v0 ParamType0<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ResultType0<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 编译器将会为*T隐式声明一个如下的方法。</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>pt <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token function">MethodX</span><span class="token punctuation">(</span>v0 ParamType0<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ResultType0<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>pt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">MethodX</span><span class="token punctuation">(</span>v0<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>更多解释请阅读Go官方FAQ中的<a href="https://golang.google.cn/doc/faq#different_method_sets" target="_blank" rel="noopener noreferrer">这个问答<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h2 id="我们可以为哪些类型声明方法"><a href="#我们可以为哪些类型声明方法" class="header-anchor">#</a> 我们可以为哪些类型声明方法？</h2> <p>请阅读<a href="https://gfw.go101.org/article/method.html" target="_blank" rel="noopener noreferrer">方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文获取答案。</p> <h2 id="在go里如何声明不可变量"><a href="#在go里如何声明不可变量" class="header-anchor">#</a> 在Go里如何声明不可变量？</h2> <p>如下是三种***不可变值***的定义：</p> <ol><li>没有地址的值（所以它们不可以寻址）。</li> <li>有地址但是因为种种原因在语法上不可以寻址的值。</li> <li>可寻址但不允许在语法上被修改的值。</li></ol> <p>在Go语言中，直到现在（Go 1.16），没有值满足第三种定义。</p> <p>有名常量值满足第一种定义。</p> <p>方法和声明的函数可以被视为声明的不可变值。 它们满足第二种定义。字符串的字节元素同样满足第二种定义。</p> <p>在Go中没有办法声明其它不可变值。</p> <h2 id="为什么没有内置的-set-容器类型"><a href="#为什么没有内置的-set-容器类型" class="header-anchor">#</a> 为什么没有内置的 <code>set</code> 容器类型？</h2> <p>集合（set）可以看作是不关心元素值的映射。 在Go语言里， <code>map[Tkey]struct{}</code> 经常被用做一个集合类型。</p> <h2 id="什么是byte-什么是rune-如何将-byte-和-rune-类型的值转换为字符串"><a href="#什么是byte-什么是rune-如何将-byte-和-rune-类型的值转换为字符串" class="header-anchor">#</a> 什么是byte？什么是rune？ 如何将 <code>[]byte</code> 和 <code>[]rune</code> 类型的值转换为字符串？</h2> <p>在Go语言里， <code>byte</code> 是 <code>uint8</code> 类型的一个别名。 换言之， <code>byte</code> 和 <code>uint8</code> 是相同的类型。 <code>rune</code> 和 <code>int32</code> 属于同样类似的关系。</p> <p>一个 <code>rune</code> 值通常被用来存储一个Unicode码点。</p> <p><code>[]byte</code> 和 <code>[]rune</code> 类型的值可以被显式地直接转换成字符串，反之亦然。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> s0 <span class="token operator">=</span> <span class="token string">&quot;Go&quot;</span>

	<span class="token keyword">var</span> bs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s0<span class="token punctuation">)</span>
	<span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span>

	<span class="token keyword">var</span> rs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s0<span class="token punctuation">)</span>
	<span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s0 <span class="token operator">==</span> s1<span class="token punctuation">)</span> <span class="token comment">// true</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s0 <span class="token operator">==</span> s2<span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>更多关于字符串的信息，请阅读<a href="https://gfw.go101.org/article/string.html" target="_blank" rel="noopener noreferrer">Go中的字符串<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文。</p> <h2 id="如何原子地操作指针值"><a href="#如何原子地操作指针值" class="header-anchor">#</a> 如何原子地操作指针值？</h2> <p>例如:</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;unsafe&quot;</span>
	<span class="token string">&quot;sync/atomic&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> T <span class="token builtin">int</span> <span class="token comment">// just a demo</span>

<span class="token keyword">var</span> p <span class="token operator">*</span>T

<span class="token keyword">func</span> <span class="token function">demo</span><span class="token punctuation">(</span>newP <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 加载（读取）</span>
	<span class="token keyword">var</span> <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">LoadPointer</span><span class="token punctuation">(</span>
		<span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// 存储（修改）</span>
	atomic<span class="token punctuation">.</span><span class="token function">StorePointer</span><span class="token punctuation">(</span>
		<span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newP<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">)</span>

	<span class="token comment">// 交换</span>
	<span class="token keyword">var</span> oldP <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">SwapPointer</span><span class="token punctuation">(</span>
		<span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newP<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// 比较并交换</span>
	<span class="token keyword">var</span> swapped <span class="token operator">=</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapPointer</span><span class="token punctuation">(</span>
		<span class="token punctuation">(</span><span class="token operator">*</span>unsafe<span class="token punctuation">.</span>Pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>oldP<span class="token punctuation">)</span><span class="token punctuation">,</span>
		unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span>newP<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">)</span>

	<span class="token boolean">_</span> <span class="token operator">=</span> swapped
<span class="token punctuation">}</span>
</code></pre></div><p>是的，目前指针的原子操作使用起来非常得繁琐。</p> <h2 id="iota-是什么意思"><a href="#iota-是什么意思" class="header-anchor">#</a> <code>iota</code> 是什么意思？</h2> <p>Iota是希腊字母表中的第九个字母。 在Go语言中， <code>iota</code> 用在常量声明中。 在每一个常量声明组中，其值在该常量声明组的第***N***个常量规范中的值为 <code>N</code> 。</p> <h2 id="为什么没有一个内置的-closed-函数用来检查通道是否已经关闭"><a href="#为什么没有一个内置的-closed-函数用来检查通道是否已经关闭" class="header-anchor">#</a> 为什么没有一个内置的 <code>closed</code> 函数用来检查通道是否已经关闭？</h2> <p>原因是此函数的实用性非常有限。 此类函数调用的返回结果不能总是反映输入通道实参的最新状态。 所以依靠此函数的返回结果来做决定不是一个好主意。</p> <p>如果你确实需要这种函数，你可以不怎么费功夫地自己写一个。 请阅读<a href="https://gfw.go101.org/article/channel-closing.html" target="_blank" rel="noopener noreferrer">如何优雅地关闭通道<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文来了解如何编写一个 <code>closed</code> 函数以及如何避免使用这样的函数。</p> <h2 id="函数返回局部变量的指针是否安全"><a href="#函数返回局部变量的指针是否安全" class="header-anchor">#</a> 函数返回局部变量的指针是否安全？</h2> <p>是的，在Go中这是绝对安全的。</p> <p>支持栈的Go编译器将会对每个局部变量进行逃逸分析。 对于官方标准编译器来说，如果一个值可以在编译时刻被断定它在运行时刻仅会在一个协程中被使用，则此值将被开辟在（此协程的）栈上；否则此值将被开辟在堆上。 请阅读<a href="https://gfw.go101.org/article/memory-block.html" target="_blank" rel="noopener noreferrer">内存块<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文了解更多。</p> <h2 id="单词-gopher-在go社区中表示什么"><a href="#单词-gopher-在go社区中表示什么" class="header-anchor">#</a> 单词***gopher***在Go社区中表示什么？</h2> <p>在Go社区中，<em><em><em>gopher***表示Go程序员。 这个昵称可能是源自于Go语言采用了<a href="https://blog.golang.com/gopher" target="_blank" rel="noopener noreferrer">一个卡通小地鼠（gopher）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>做为吉祥物。 顺便说一下，这个卡通小地鼠是由</em>Renee French</em>设计的。 <em>Renee French</em>是Go项目首任负责人</em>Rob Pike*的妻子。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/21/2021, 1:25:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/开发基础/GO/其他文章/Go细节.html" class="prev">
        Go细节
      </a></span> <span class="next"><a href="/blog/开发基础/GO/其他文章/命令-mod.html">
        命令-mod
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.77332b34.js" defer></script><script src="/blog/assets/js/3.21e2e031.js" defer></script><script src="/blog/assets/js/107.df9ba599.js" defer></script>
  </body>
</html>
