(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{1220:function(a,e,t){"use strict";t.r(e);var s=t(19),n=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"查询dsl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查询dsl"}},[a._v("#")]),a._v(" 查询DSL")]),a._v(" "),t("h2",{attrs:{id:"查询过滤的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查询过滤的区别"}},[a._v("#")]),a._v(" 查询过滤的区别")]),a._v(" "),t("p",[a._v("Elasticsearch提供了基于JSON的完整查询DSL来定义查询。查询DSL包括两种子句：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("叶查询子句 ：在特定的字段上查找特定的值，比如match、term或者range查询。这些查询可以自己使用。")])]),a._v(" "),t("li",[t("p",[a._v("复合查询子句 ：包含其他叶查询或复合查询子句，以合理的方式结合多条查询（比如bool或dis_max查询），或者改变查询行为（比如not或constant_score查询）。")])]),a._v(" "),t("li",[t("p",[a._v("查询 （query）用于检查内容与条件是否匹配，并且计算_score元字段表示匹配度。查询的结构中以query参数开始来执行内容查询。")])]),a._v(" "),t("li",[t("p",[a._v('过滤 （filter）不计算匹配得分，只是简单地决定文档是否匹配。内容过滤主要用于过滤结构化的数据，例如：时间段是否在2015到2016年之间，status字段是否设置为"published"。')])])]),a._v(" "),t("p",[a._v("使用过滤往往会被Elasticsearch自动缓存来提高性能。")]),a._v(" "),t("p",[a._v("查询的子句也可以传递filter参数，比如bool查询内的filter、constant_score查询内的filter参数等。")]),a._v(" "),t("p",[a._v("举个查询子句的例子。查询会匹配符合下列所有条件的文档：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("title字段包含单词Search。")])]),a._v(" "),t("li",[t("p",[a._v("content字段包含单词Elasticsearch。")])]),a._v(" "),t("li",[t("p",[a._v("status字段包含准确的单词published。")])]),a._v(" "),t("li",[t("p",[a._v("publish_date字段包含从2015年1月1日之后的日期。")])])]),a._v(" "),t("p",[a._v("请求：POST "),t("a",{attrs:{href:"http://127.0.0.1:9200/secisland/_search",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://127.0.0.1:9200/secisland/_search"),t("OutboundLink")],1)]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "query": {\n    "bool": {\n      "must": [\n        { "match": { "title":"Search"}},\n        { "match": { "content": "Elasticsearch" }}\n      ],\n      "filter": [\n        { "term":  { "status": "published" }},\n        { "range": { "publish_date": { "gte": "2015-01-01" }}}\n      ]\n    }\n  }\n}\n')])])]),t("p",[a._v("query参数表示内容查询。内容查询中使用的bool和match子句，用于计算每个文档的匹配得分。")]),a._v(" "),t("p",[a._v("filter参数表示内容过滤。内容过滤中使用的term和range子句，会过滤掉不匹配的文档，并且不影响计算文档匹配得分。")]),a._v(" "),t("p",[a._v("最简单的查询，匹配所有文档，文档的_score值是1.0。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{ "match_all": {} }\n')])])]),t("p",[a._v("可以使用boost参数修改_score值：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{ "match_all": { "boost" : 1.2 }}\n')])])]),t("h2",{attrs:{id:"全文搜索"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全文搜索"}},[a._v("#")]),a._v(" 全文搜索")]),a._v(" "),t("p",[a._v("在文本字段上执行全文搜索。在执行查询之前，要了解被查询字段的分词方式，在查询字符串上应用每个被查询字段的映射分词器（或搜索分词器）。")]),a._v(" "),t("p",[a._v("标准查询 接受文本/数字/日期的查询，分析参数并组成查询条件。例如：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match" : {"message" : "this is a test"}\n}\n')])])]),t("p",[a._v("注意，message是字段名，可以用任何字段的名（包括_all）来替换。")]),a._v(" "),t("p",[a._v("有三种类型的match查询：布尔（boolean）、短语（phrase）和短语前缀（phrase_prefix）。除此之外还有多段查询、Lucene语法查询、简化查询。下面分别介绍。")]),a._v(" "),t("ol",[t("li",[a._v("布尔查询")])]),a._v(" "),t("p",[a._v("默认的标准查询类型，分析文本并且组成一个布尔查询。operator参数可以设置为or或者and来控制布尔子句（默认为or）。用于匹配的should子句（可选）的最小数量可以使用minimun_should_match参数来设置。")]),a._v(" "),t("p",[a._v("可以设置analyzer来控制在文本上执行分析过程的分词器。默认是字段映射中明确定义或者默认的搜索分词器。")]),a._v(" "),t("p",[a._v("lenient参数可以设置为true来忽略数据类型匹配出错造成的异常，例如尝试通过文本查询字符串来查询数字类型字段。默认为false。")]),a._v(" "),t("p",[a._v("（1）模糊匹配")]),a._v(" "),t("p",[a._v("fuzziness可以对请求的字段类型进行模糊匹配。")]),a._v(" "),t("p",[a._v("prefix_length 和 max_expansions 在这种情况下可以用来控制模糊过程。如果设置模糊选项，查询会使用 top_terms_blended_freqs_${max_expansions}作为重写方法。fuzzy_rewrite 参数可以控制查询会怎样进行重写。")]),a._v(" "),t("p",[a._v("提供额外参数的例子：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match" : {\n    "message" : {"query" : "this is a test","operator" : "and"}\n  }\n}\n')])])]),t("p",[a._v("（2）零索引词查询")]),a._v(" "),t("p",[a._v("如果查询使用的分词器移除所有词元，默认行为是不匹配任何文档。可以使用zero_terms_query选项进行修改，接受none（默认）和all（相当于match_all查询）。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match" : {\n    "message" : {\n      "query" : "to be or not to be",\n      "operator" : "and",\n      "zero_terms_query": "all"\n    }\n  }\n}\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("短语查询")])]),a._v(" "),t("p",[a._v("短语查询分析文本并且创建短语查询。例如：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match_phrase" : {\n    "message" : "this is a test"\n  }\n}\n')])])]),t("p",[a._v("因为短语查询只是标准查询的一个类型，所以也可以用下面的方式使用：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match" : {\n    "message" : {"query" : "this is a test","type" : "phrase"}\n  }\n}\n')])])]),t("p",[a._v("短语查询根据一个可配置的slop（默认为0）匹配索引词。")]),a._v(" "),t("p",[a._v("可以设置analyzer来控制将要在文本上执行分词的分词器。默认是字段映射中定义的分析器，或者是默认的搜索分析器，例如：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match_phrase" : {\n    "message" : {"query" : "this is a test","analyzer" : "my_analyzer"}\n  }\n}\n')])])]),t("ol",{attrs:{start:"3"}},[t("li",[a._v("短语前缀查询")])]),a._v(" "),t("p",[a._v("可以对文本最后一个字段进行前缀匹配。例如：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match_phrase_prefix" : {"message" : "this is a test"}\n}\n')])])]),t("p",[a._v("和短语查询一样，也可以用下面的方式：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match" : {\n    "message" : {"query" : "this is a test","type" : "phrase_prefix"}\n  }\n}\n')])])]),t("p",[a._v("接受短语查询相同的参数。此外，也接受max_expansions参数，可以控制最后索引词会扩展多少前缀。推荐设置为一个可以接受的值来控制查询的执行时间。例如：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "match_phrase_prefix" : {\n    "message" : {"query" : "this is a test","max_expansions" : 10}\n  }\n}\n')])])]),t("ol",{attrs:{start:"4"}},[t("li",[a._v("多字段查询")])]),a._v(" "),t("p",[a._v("在标准查询的基础上，支持多字段查询：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query": "this is a test",\n    "fields": [ "subject", "message" ]\n  }\n}\n')])])]),t("p",[a._v("字段可以通过通配符指定：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query": "Will Smith",\n    "fields": [ "title", "*_name" ]\n  }\n}\n')])])]),t("p",[a._v("个别字段可以用caret（^）符号加权：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query" : "this is a test",\n    "fields" : [ "subject^3", "message" ]\n  }\n}\n')])])]),t("p",[a._v("上述代码的含义是：subject字段比message字段重要三倍。")]),a._v(" "),t("p",[a._v("多匹配查询内部执行方式取决于type参数，可以设置的值如下所示：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("best_fields------（默认）查找匹配任何字段的文档，但是使用最佳匹配字段的_score。")])]),a._v(" "),t("li",[t("p",[a._v("most_fields------查找匹配任何字段的文档，结合每个字段的_score。")])]),a._v(" "),t("li",[t("p",[a._v("cross_fields------用相同的分析器处理字段，把这些字段当作一个大字段。查找任何字段的每个单词。")])]),a._v(" "),t("li",[t("p",[a._v("phrase------在每个字段上运行短语匹配查询，结合每个字段的_score。")])]),a._v(" "),t("li",[t("p",[a._v("phrase_prefix------在每个字段上运行短语前缀匹配查询，结合每个字段的_score。")])])]),a._v(" "),t("p",[a._v("下面介绍这几个值。")]),a._v(" "),t("p",[a._v("（1）best_fields")]),a._v(" "),t("p",[a._v('在同一个字段中搜索多个单词的时候此参数最有用。例如，一个字段中包含"brown fox"比包含"brown"或包含"fox"更有意义。best_fields类型对每个字段生成一个匹配查询并且封装成dis_max查询，来找到最佳匹配字段。例如，查询语句：')]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query": "brown fox",\n    "type": "best_fields",\n    "fields": [ "subject", "message" ],\n    "tie_breaker": 0.3\n  }\n}\n')])])]),t("p",[a._v("会执行为：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "dis_max": {\n    "queries": [\n      { "match": { "subject": "brown fox" }},\n      { "match": { "message": "brown fox" }}\n    ],\n    "tie_breaker": 0.3\n  }\n}\n')])])]),t("p",[a._v('通常，best_fields类型使用最佳匹配字段的得分，但是如果指定了tie_breaker，可以通过"最佳匹配字段的得分"来计算匹配得分。')]),a._v(" "),t("p",[a._v("所有其他匹配字段的参数包括tie_breaker*_score相加。同时，接受analyzer、boost、operator、minimum_should_match、fuzziness、prefix_length、max_expansions、rewrite、zero_terms_query和cutoff_frequency。")]),a._v(" "),t("p",[a._v("其中，minimum_should_match参数可能的值见表4-2。")]),a._v(" "),t("p",[a._v("（2）most_fields")]),a._v(" "),t("p",[a._v("当查询多字段包含相同文本以不同方式分词的时候此参数最有用。例如，主字段包含同义词、词根和不区分大小写的索引词；第二个字段可能包含原始的索引词；第三个字段可以包含单个索引词。通过结合所有三个字段的得分可以通过主字段匹配尽可能多的文档，通过第二个和第三个字段把最相近的结果推到列表的顶端。")]),a._v(" "),t("p",[a._v("表4-2　最低匹配值")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://reader.epubee.com/books/mobile/f8/f8fc674e229abfd9abb3cc5ba2ec41de/Image00043.jpg",alt:""}})]),a._v(" "),t("p",[a._v("查询语句：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query": "quick brown fox",\n    "type": "most_fields",\n    "fields": [ "title", "title.original", "title.shingles" ]\n  }\n}\n')])])]),t("p",[a._v("会执行为：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "bool": {\n    "should": [\n      { "match": { "title": "quick brown fox" }},\n      { "match": { "title.original": "quick brown fox" }},\n      { "match": { "title.shingles": "quick brown fox" }}\n    ]\n  }\n}\n')])])]),t("p",[a._v("最终的匹配得分是将每个匹配子句的得分加在一块，然后除以匹配子句的数量。")]),a._v(" "),t("p",[a._v("接受的参数有：analyzer、boost、operator、minimun_should_match、fuzziness、prefix_length、max_expansions、rewrite、zero_terms_query和cutoff_frequency。")]),a._v(" "),t("p",[a._v("（3）cross_fields")]),a._v(" "),t("p",[a._v('当结构化的文档中多个字段应该匹配的时候，此参数特别有用。例如，当通过first_name和last_name字段查询"Will Smith"的时候，最佳的匹配是"Will"在一个字段，"Smith"在另一个字段。')]),a._v(" "),t("p",[a._v("一种处理这种查询的简单方式是将first_name和last_name字段索引到一个full_name字段。当然，这只能在索引的时候完成。")]),a._v(" "),t("p",[a._v("cross_fields类型在查询时通过采取term-centric方法来尝试解决这个问题。首先将查询字符串分词为单独的索引词，然后在任一字段中查找每个索引词。")]),a._v(" "),t("p",[a._v("查询示例如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query": "Will Smith",\n    "type": "cross_fields",\n    "fields": [ "first_name", "last_name" ],\n    "operator": "and"\n  }\n}\n')])])]),t("p",[a._v("接受的参数有：analyzer、boost、operator、minimum_should_match、zero_terms_query和cutoff_frequency。")]),a._v(" "),t("p",[a._v("（4）phrase和phrase_prefix")]),a._v(" "),t("p",[a._v("短语和短语前缀类型和best_fields一样，只不过使用的是match_phrase查询或者match_phrase_prefix查询而不是match查询。")]),a._v(" "),t("p",[a._v("查询示例如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query": "quick brown f",\n    "type": "phrase_prefix",\n    "fields": [ "subject", "message" ]\n  }\n}\n')])])]),t("p",[a._v("会执行为：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "dis_max": {\n    "queries": [\n      { "match_phrase_prefix": { "subject": "quick brown f" }},\n      { "match_phrase_prefix": { "message": "quick brown f" }}\n    ]\n  }\n}\n')])])]),t("p",[a._v("接受如下参数：analyzer、boost、slop和zero_terms_query参数。此外，短语前缀类型接受max_expansions。")]),a._v(" "),t("p",[a._v("（5）cross_field和分词器")]),a._v(" "),t("p",[a._v("cross_field类型只能够工作在使用相同分词器的term-centric模式的字段。具有相同分词器的字段被分在一组，如果有多个分组，会通过bool查询结合在一起。")]),a._v(" "),t("p",[a._v("例如，first和last字段拥有相同的分词器，添加first.edge和last.edge使用edge_ngram分析器，查询：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query": "Jon",\n    "type": "cross_fields",\n    "fields": ["first", "first.edge","last",  "last.edge"]\n  }\n}\n')])])]),t("p",[a._v("first和last会被组在一起作为单独的字段，first.edge和last.edge会被组在一起作为单独的字段。")]),a._v(" "),t("p",[a._v("可以重写查询作为两个通过bool查询联合在一起的cross_fields查询，然后对其中一个应用minimum_should_match参数：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "bool": {\n    "should": [\n      {\n        "multi_match" : {\n          "query": "Will Smith",\n          "type": "cross_fields",\n          "fields": [ "first", "last" ],\n          "minimum_should_match": "50%"\n        }\n      },\n    {\n        "multi_match" : {\n          "query": "Will Smith",\n          "type": "cross_fields",\n          "fields": [ "*.edge" ]\n        }\n      }\n    ]\n  }\n}\n')])])]),t("p",[a._v("也可以强迫所有字段到相同的分组，方法是在查询中指定analyzer参数：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "multi_match" : {\n    "query": "Jon",\n    "type": "cross_fields",\n    "analyzer": "standard",\n    "fields": [ "first", "last", "*.edge" ]\n  }\n}\n')])])]),t("ol",{attrs:{start:"5"}},[t("li",[a._v("Lucene语法查询")])]),a._v(" "),t("p",[a._v("通过使用语法分析器来分析内容进行查询：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "query_string" : {\n    "default_field" : "content",\n    "query" : "this AND that OR thus"\n  }\n}\n')])])]),t("p",[a._v("query_string为最高级别，参数见表4-3。")]),a._v(" "),t("p",[a._v("表4-3　查询字符串参数")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://reader.epubee.com/books/mobile/f8/f8fc674e229abfd9abb3cc5ba2ec41de/Image00044.jpg",alt:""}})]),a._v(" "),t("p",[a._v("（1）默认字段")]),a._v(" "),t("p",[a._v("如果在查询字符串语法中没有明确指出查询的字段，会inde.query.default_field提取需要搜索的字段。默认为_all字段。")]),a._v(" "),t("p",[a._v("所以，如果_all字段被禁用，将其修改设置为一个不同的默认字段是很有必要的。")]),a._v(" "),t("p",[a._v("（2）多字段")]),a._v(" "),t("p",[a._v('query_string查询也可以在多个字段上执行。可以通过"fields"参数定义字段。')]),a._v(" "),t("p",[a._v("多字段执行query_string查询的意义在于利用OR子句扩展每个查询索引词，形如：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("field1:query_term OR field2:query_term | ...\n\n")])])]),t("p",[a._v("例如，下面的查询：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "query_string" : {"fields" : ["content", "name"],"query" : "this AND that"}\n}\n')])])]),t("p",[a._v("实际匹配形式：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "query_string": {\n  "query": "(content:this OR name:this) AND (content:that OR name:that)"}\n}\n')])])]),t("p",[a._v("（3）语法")]),a._v(" "),t("p",[a._v("查询字符串被解析为一系列字段和运算符。字段可以是一个单词或者短语（搜索短语中的所有单词，以相同的顺序用双引号包起来）。")]),a._v(" "),t("p",[a._v("可用的选项有：")]),a._v(" "),t("p",[a._v("1）字段名------可以指定default_field之外的其他字段。")]),a._v(" "),t("ul",[t("li",[a._v("status字段包含active。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("status:active\n\n")])])]),t("ul",[t("li",[a._v("title字段包含quick或brown。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("title:(quick OR brown)\ntitle:(quick brown)\n\n")])])]),t("ul",[t("li",[a._v('author字段包含短语"John Smith"。')])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('author:"John Smith"\n\n')])])]),t("ul",[t("li",[a._v("任何book.title、book.content或book.date字段包含quick或brown（注意，需要用反斜线转义*）。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("book.\\*:(quick brown)\n\n")])])]),t("ul",[t("li",[a._v("title字段不包含（或者缺失）值。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("_missing_:title\n\n")])])]),t("ul",[t("li",[a._v("title字段包含任何非空值。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("_exists_:title\n\n")])])]),t("p",[a._v("2）通配符------通配符搜索使用? 代替单个字符，使用*代替零个或多个字符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("qu?ck bro*\n\n")])])]),t("p",[a._v("3）正则表达式------通过使用斜线（/）包围，正则表达式可以植入到查询字符串中。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("name:/joh?n(ath[oa]n)/\n\n")])])]),t("p",[a._v("4）模糊化。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("quikc~1\n\n")])])]),t("p",[a._v("5）邻近搜索------可以指定短语中单词的最大编辑距离。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('"fox quick"~5\n\n')])])]),t("p",[a._v('字段中的文本越接近于查询字符串的顺序，文档的相关性越高。短语"quick fox"的相关性高于"quick brown fox"。')]),a._v(" "),t("p",[a._v("6）范围------可以指定日期、数字或字符串字段的范围。包含的范围用方括号指定[min TO max]，不包含的范围用花括号指定{min TO max}。")]),a._v(" "),t("p",[a._v("-2016年的所有日期")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("date:[2016-01-01 TO 2016-12-31]\n\n")])])]),t("p",[a._v("-数字1到5")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("count:[1 TO 5]\n\n")])])]),t("p",[a._v("-alpha和omega之间的标签，不包括alpha和omega")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("tag:{alpha TO omega}\n")])])]),t("p",[a._v("-大于等于10的数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("count:[10 TO *]\n\n")])])]),t("p",[a._v("-2016年之前的日期")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("date:{* TO 2016-01-01}\n")])])]),t("p",[a._v("-大于等于1小于5的数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("count:[1 TO 5}\n")])])]),t("p",[a._v("-一边值为无限")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("age:>10\nage:>=10\nage:<10\nage:<=10\n\n")])])]),t("p",[a._v("7）增权。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('quick^2 fox\n"john smith"^2\n(foo bar)^4\n\n')])])]),t("p",[a._v("8）布尔操作符。")]),a._v(" "),t("p",[a._v("+必须包含。")]),a._v(" "),t("p",[a._v("-必须不包含。")]),a._v(" "),t("p",[a._v("支持AND、OR和NOT（也可以写作&&、||和!）操作符。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("((quick AND fox) OR (brown AND fox) OR fox) AND NOT news\n\n")])])]),t("p",[a._v("等同于：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "bool": {\n    "must": { "match": "fox"},\n    "should": { "match": "quick brown" },\n    "must_not": { "match": "news"}\n  }\n}\n')])])]),t("p",[a._v("9）分组------多字段或子句可以使用圆括号进行分组。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("status:(active OR pending) title:(full text search)^2\n\n")])])]),t("p",[a._v("10）保留字符------查询中出现保留字符的时候，需要进行转义。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\\(1\\+1\\)\\=2\n\n")])])]),t("p",[a._v('保留字符有：+-=&&||><!(){}[]^"~*?😕')]),a._v(" "),t("p",[a._v("11）空查询------如果查询字符串是空的或者仅包含空格，查询会生成一个空结果集。")]),a._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[a._v("简化查询")])]),a._v(" "),t("p",[a._v("系统提供了简化语法来进行查询。不像普通的Lucene语法查询，简化查询不会抛出异常，而且会丢弃查询无效部分：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "simple_query_string" : {\n    "query": "\\"fried eggs\\" +(eggplant | potato) -frittata",\n    "analyzer": "snowball",\n    "fields": ["body^5","_all"],\n    "default_operator": "and"\n  }\n}\n')])])]),t("p",[a._v("简化查询可以接受参数见表4-4。")]),a._v(" "),t("p",[a._v("表4-4　简化查询参数")]),a._v(" "),t("p",[t("img",{attrs:{src:"http://reader.epubee.com/books/mobile/f8/f8fc674e229abfd9abb3cc5ba2ec41de/Image00045.jpg",alt:""}})]),a._v(" "),t("p",[a._v("（1）语法")]),a._v(" "),t("p",[a._v("简单查询字符串支持的特殊字符如下所示：")]),a._v(" "),t("p",[a._v("+　表示AND运算符。")]),a._v(" "),t("p",[a._v("|　表示OR运算符。")]),a._v(" "),t("p",[a._v("--　排除一个词元。")]),a._v(" "),t("p",[a._v('"　包含一批词元来指定搜索短语。')]),a._v(" "),t("p",[a._v("*　在索引词结尾表示前缀查询。")]),a._v(" "),t("p",[a._v("（和）　表示优先。")]),a._v(" "),t("p",[a._v("~N　在单词的后面，表示编辑距离（模糊性）。")]),a._v(" "),t("p",[a._v("~N　在短语的后面，表示溢出量。")]),a._v(" "),t("p",[a._v("为了搜索任何这些特殊字符，需要使用斜线（\\）。")]),a._v(" "),t("p",[a._v("（2）默认字段")]),a._v(" "),t("p",[a._v("当在搜索字符串语法中没有明确指出需要搜索的字段时，index.query.default_field会用来提取要搜索的字段。默认为_all字段。")]),a._v(" "),t("p",[a._v("（3）多字段")]),a._v(" "),t("p",[a._v("字段参数也可以包括基于模式的字段名，可以自动扩展相关字段（动态引入包含的字段）。例如：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "simple_query_string" : {"fields" : ["content", "name.*^5"],\n  "query" : "foo bar baz"}\n}\n')])])]),t("p",[a._v("（4）标记")]),a._v(" "),t("p",[a._v("简单查询字符串支持多个标记来指定需要启用的解析功能。在flags参数中指定为一个用|分隔的字符串：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('{\n  "simple_query_string" : {"query" : "foo | bar + baz*",\n    "flags" : "OR|AND|PREFIX"}\n}\n')])])]),t("p",[a._v("可用的标记有：ALL、NONE、AND、OR、NOT、PREFIX、PHRASE、PRECEDENCE、ESCAPE、WHITESPACE、FUZZY、NEAR和SLOP。")])])}),[],!1,null,null,null);e.default=n.exports}}]);