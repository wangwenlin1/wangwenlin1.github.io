(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{1222:function(t,n,a){"use strict";a.r(n);var e=a(19),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"动态模版"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态模版"}},[t._v("#")]),t._v(" 动态模版")]),t._v(" "),a("p",[t._v("动态模板允许您更好地控制 Elasticsearch 如何将数据映射到默认的动态字段映射规则之外。您可以通过将动态参数设置为 true 或运行时来启用动态映射。然后你可以使用动态模板定义自定义的映射，这些映射可以根据匹配条件应用到动态添加的字段:")]),t._v(" "),a("ul",[a("li",[t._v("操作 Elasticsearch 检测到的数据类型")]),t._v(" "),a("li",[t._v("使用模式来匹配字段名")]),t._v(" "),a("li",[t._v("按照完整的虚线路径进行操作")])]),t._v(" "),a("p",[t._v("使用映射规范中的{name}和{dynamic_type}模板变量作为占位符。")]),t._v(" "),a("p",[t._v("动态字段映射只有在字段包含具体值时才会添加ー而不是null或空数组。如果在动态模板中使用 null_value 选项，则只有在第一个具有字段具体值的文档被索引之后，才会应用它。")]),t._v(" "),a("p",[t._v("动态模板被指定为命名对象的数组:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' "dynamic_templates": [\n    {\n      "my_template_name": { \n        ...  match conditions ... \n        "mapping": { ... } \n      }\n    },\n    ...\n  ]\n')])])]),a("ul",[a("li",[t._v("模板名称可以是任何字符串值。")]),t._v(" "),a("li",[t._v("匹配条件可以包括: match_mapping_type、 match、 match_pattern、 unmatch、 path_match、 path_unmatch。")]),t._v(" "),a("li",[t._v("匹配字段应该使用的映射。")])]),t._v(" "),a("h2",{attrs:{id:"验证动态模板"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#验证动态模板"}},[t._v("#")]),t._v(" 验证动态模板")]),t._v(" "),a("p",[t._v("如果提供的映射包含无效映射代码片段，则返回验证错误。在索引时应用动态模板时进行验证，在大多数情况下，在更新动态模板时进行验证。在某些情况下，提供无效的映射代码片段可能会导致动态模板的更新或验证失败:")]),t._v(" "),a("ul",[a("li",[t._v("如果没有 但该模板对于至少一个预定义的映射类型有效，则映射代码片段被认为是有效的。但是，如果与模板匹配的字段被索引为不同的类型，则在索引时返回验证错误。例如，将动态模板配置为 被认为作为字符串类型有效，但是如果匹配动态模板的字段被索引为 long，则在索引时返回验证错误。建议配置 或配置所需的 JSON 类型 在地图片段中")]),t._v(" "),a("li",[t._v("如果 占位符用于映射代码片段，在更新动态模板时跳过验证。这是因为当时字段名称未知。相反，在索引时应用模板时进行验证")])]),t._v(" "),a("p",[t._v("模板是按顺序处理的ーー第一个匹配的模板胜出。当通过 put 映射 API 放置新的动态模板时，所有现有的模板都会被覆盖。这允许在最初添加动态模板之后对其进行重新排序或删除。")]),t._v(" "),a("h2",{attrs:{id:"映射动态模板中的运行时字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#映射动态模板中的运行时字段"}},[t._v("#")]),t._v(" 映射动态模板中的运行时字段")]),t._v(" "),a("p",[t._v('如果希望 Elasticsearch 动态地将特定类型的新字段映射为运行时字段，请在索引映射中设置"dynamic":"runtime"。这些字段没有索引，并且在查询时从 _source 加载。')]),t._v(" "),a("p",[t._v('或者，您可以使用默认的动态映射规则，然后创建动态模板来将特定字段映射为运行时字段。在索引映射中设置"dynamic": "true"，然后创建一个动态模板，将特定类型的新字段映射为运行时字段。')]),t._v(" "),a("p",[t._v("假设您有每个字段都以 ip_开头的数据。根据动态映射规则，Elasticsearch 将任何通过数值检测的字符串映射为 float 或 long。但是，您可以创建一个动态模板，将新字符串映射为类型为 ip 的运行时字段。")]),t._v(" "),a("p",[t._v('下面的请求定义了一个名为 strings_as_ip 的动态模板。当 Elasticsearch 检测到与 ip * 模式匹配的新字符串字段时，它会将这些字段映射为类型为 ip 的运行时字段。因为 ip 字段不是动态映射的，所以您可以使用这个模板"dynamic": "true" 或 "dynamic": "runtime"。')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001/\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "strings_as_ip": {\n          "match_mapping_type": "string",\n          "match": "ip*",\n          "runtime": {\n            "type": "ip"\n          }\n        }\n      }\n    ]\n  }\n}\n')])])]),a("p",[t._v("有关如何使用动态模板将字符串字段映射为索引字段或运行时字段，请参见此示例。")]),t._v(" "),a("p",[t._v("match_mapping_type 是 JSON 解析器检测到的数据类型。因为 JSON 不区分 long 和整数，也不区分 double 和 float，所以它总是选择更广泛的数据类型，比如 long 表示整数，double 表示浮点数。")]),t._v(" "),a("p",[t._v("自动检测以下数据类型:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[a("strong",[t._v("JSON data type")])]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[a("strong",[a("code",[t._v('"dynamic":"true"')])])]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[a("strong",[a("code",[t._v('"dynamic":"runtime"')])])])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("null")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("No field added")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("No field added")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("true")]),t._v(" or "),a("code",[t._v("false")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("boolean")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("boolean")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("double")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("float")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("double")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("integer")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("long")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("long")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("object")]),t._v("^1^")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("object")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("object")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("array")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("Depends on the first non-"),a("code",[t._v("null")]),t._v(" value in the array")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("Depends on the first non-"),a("code",[t._v("null")]),t._v(" value in the array")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("通过日期检测的string")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("date")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("date")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("通过数字检测的string")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("float")]),t._v(" or "),a("code",[t._v("long")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("double")]),t._v(" or "),a("code",[t._v("long")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("不能通过日期检测或数字检测的字符串")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("带有. keyword 子字段的 text")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("keyword")])])])])]),t._v(" "),a("p",[t._v("使用通配符(*)匹配所有数据类型。")]),t._v(" "),a("p",[t._v("例如，如果我们想将所有整数字段映射为整数字段而不是长字段，并将所有字符串字段映射为文本和关键字，我们可以使用以下模板:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "integers": {\n          "match_mapping_type": "long",\n          "mapping": {\n            "type": "integer"\n          }\n        }\n      },\n      {\n        "strings": {\n          "match_mapping_type": "string",\n          "mapping": {\n            "type": "text",\n            "fields": {\n              "raw": {\n                "type":  "keyword",\n                "ignore_above": 256\n              }\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  "my_integer": 5, \n  "my_string": "Some string" \n}\n')])])]),a("ul",[a("li",[t._v("my_integer 字段被映射为整数。")]),t._v(" "),a("li",[t._v("my_string 字段被映射为一个文本，带有一个关键字 multi 字段。")])]),t._v(" "),a("h2",{attrs:{id:"match-和-unmatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#match-和-unmatch"}},[t._v("#")]),t._v(" match 和 unmatch")]),t._v(" "),a("p",[t._v("match 参数使用一个模式来匹配字段名，而 unmatch 使用一个模式来排除匹配的字段。")]),t._v(" "),a("p",[t._v("match_pattern 参数调整 match 参数的行为，以支持字段名称上的完整 Java 正则表达式匹配，而不是简单的通配符。例如:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('  "match_pattern": "regex",\n  "match": "^profit_\\d+$"\n')])])]),a("p",[t._v("下面的示例匹配所有名称以 long_ (除了以 _text 结尾的字段)开头的字符串字段，并将它们映射为长字段:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "longs_as_strings": {\n          "match_mapping_type": "string",\n          "match":   "long_*",\n          "unmatch": "*_text",\n          "mapping": {\n            "type": "long"\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  "long_num": "5", \n  "long_text": "foo" \n}\n')])])]),a("ul",[a("li",[t._v("long_num 字段被映射为 long。")]),t._v(" "),a("li",[t._v("long_text 字段使用默认的字符串映射。")])]),t._v(" "),a("p",[t._v("path_match 和 path_unmatch 参数的工作方式与 match 和 unmatch 相同，但是操作的是字段的完整虚线路径，而不仅仅是最终名称，例如某个_object。*.某个地方。")]),t._v(" "),a("p",[t._v("此示例将 name 对象中任何字段的值复制到顶级 full_name 字段，但中间字段除外:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "full_name": {\n          "path_match":   "name.*",\n          "path_unmatch": "*.middle",\n          "mapping": {\n            "type":       "text",\n            "copy_to":    "full_name"\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  "name": {\n    "first":  "John",\n    "middle": "Winston",\n    "last":   "Lennon"\n  }\n}\n')])])]),a("p",[t._v("请注意，path_match 和 path_unmatch 参数除了与叶字段相匹配外，还与对象路径相匹配。例如，为下面的文档建立索引会导致一个错误，因为 path_match 设置也匹配对象字段 name.title，它不能被映射为文本:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001/_doc/2\n{\n  "name": {\n    "first":  "Paul",\n    "last":   "McCartney",\n    "title": {\n      "value": "Sir",\n      "category": "order of chivalry"\n    }\n  }\n}\n')])])]),a("h2",{attrs:{id:"模板变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板变量"}},[t._v("#")]),t._v(" 模板变量")]),t._v(" "),a("p",[t._v("在与字段名称和检测到的动态类型的映射中替换{ name }和{ dynamic_type }占位符。下面的示例设置所有字符串字段，使用与字段同名的分析器，并禁用所有非字符串字段的 doc_value:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "named_analyzers": {\n          "match_mapping_type": "string",\n          "match": "*",\n          "mapping": {\n            "type": "text",\n            "analyzer": "{name}"\n          }\n        }\n      },\n      {\n        "no_doc_values": {\n          "match_mapping_type":"*",\n          "mapping": {\n            "type": "{dynamic_type}",\n            "doc_values": false\n          }\n        }\n      }\n    ]\n  }\n}\n\nPUT my-index-000001/_doc/1\n{\n  "english": "Some English text", \n  "count":   5 \n}\n')])])]),a("ul",[a("li",[t._v("英文字段被映射为带有英文分析器的字符串字段。")]),t._v(" "),a("li",[t._v("count 字段映射为禁用 doc_值的长字段。")])]),t._v(" "),a("h2",{attrs:{id:"动态模板示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态模板示例"}},[t._v("#")]),t._v(" 动态模板示例")]),t._v(" "),a("p",[t._v("下面是一些可能有用的动态模板的例子:")]),t._v(" "),a("h3",{attrs:{id:"结构化搜索"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结构化搜索"}},[t._v("#")]),t._v(" 结构化搜索")]),t._v(" "),a("p",[t._v('当您设置" dynamic": "true"时，Elasticsearch 将把字符串字段映射为带有关键字子字段的文本字段。如果你只是索引结构化内容或者对全文搜索不感兴趣，你可以使 Elasticsearch 只把你的字段作为关键字字段。但是，必须搜索与索引搜索这些字段完全相同的值。')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "strings_as_keywords": {\n          "match_mapping_type": "string",\n          "mapping": {\n            "type": "keyword"\n          }\n        }\n      }\n    ]\n  }\n}\n')])])]),a("h3",{attrs:{id:"text-只有字符串的映射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#text-只有字符串的映射"}},[t._v("#")]),t._v(" text-只有字符串的映射")]),t._v(" "),a("p",[t._v("与前面的例子相反，如果你只关心字符串字段的全文搜索，而不打算运行聚合、排序或精确搜索，你可以告诉 Elasticsearch 将字符串映射为文本:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "strings_as_text": {\n          "match_mapping_type": "string",\n          "mapping": {\n            "type": "text"\n          }\n        }\n      }\n    ]\n  }\n}\n')])])]),a("p",[t._v("或者，您可以创建一个动态模板，将字符串字段映射为映射的运行时部分中的关键字字段。当 Elasticsearch 检测到类型为 string 的新字段时，这些字段将被创建为类型为 keyword 的运行时字段。")]),t._v(" "),a("p",[t._v("虽然字符串字段不会被索引，但是它们的值存储在_source 中，可以用于搜索请求、聚合、筛选和排序。")]),t._v(" "),a("p",[t._v("例如，下面的请求创建一个动态模板，将字符串字段映射为 keyword 类型的运行时字段。虽然运行时定义是空白的，新的字符串字段将被映射为基于 Elasticsearch 用于向映射添加字段类型的动态映射规则的关键字运行时字段。任何没有通过日期检测或数字检测的字符串都会自动映射为关键字:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "strings_as_keywords": {\n          "match_mapping_type": "string",\n          "runtime": {}\n        }\n      }\n    ]\n  }\n}\n')])])]),a("p",[t._v("你索引一个简单的文档:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001/_doc/1\n{\n  "english": "Some English text",\n  "count":   5\n}\n')])])]),a("p",[t._v("当你查看映射时，你会看到英文字段是一个类型为 keyword 的运行时字段:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("GET  my-index-000001/_mapping\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('{\n  "my-index-000001" : {\n    "mappings" : {\n      "dynamic_templates" : [\n        {\n          "strings_as_keywords" : {\n            "match_mapping_type" : "string",\n            "runtime" : { }\n          }\n        }\n      ],\n      "runtime" : {\n        "english" : {\n          "type" : "keyword"\n        }\n      },\n      "properties" : {\n        "count" : {\n          "type" : "long"\n        }\n      }\n    }\n  }\n}\n')])])]),a("h3",{attrs:{id:"禁用标准"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#禁用标准"}},[t._v("#")]),t._v(" 禁用标准")]),t._v(" "),a("p",[t._v("常模为指数时间评分因子。如果您不关心计分，例如，如果您从来不按分数对文档进行排序，那么您可以禁用索引中这些计分因子的存储并节省一些空间。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "strings_as_keywords": {\n          "match_mapping_type": "string",\n          "mapping": {\n            "type": "text",\n            "norms": false,\n            "fields": {\n              "keyword": {\n                "type": "keyword",\n                "ignore_above": 256\n              }\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n')])])]),a("p",[t._v("子关键字字段在此模板中显示为与动态映射的默认规则一致。当然，如果您不需要它们，因为您不需要对这个字段执行精确的搜索或聚合，那么您可以按照前面部分的描述移除它。")]),t._v(" "),a("h3",{attrs:{id:"时间序列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间序列"}},[t._v("#")]),t._v(" 时间序列")]),t._v(" "),a("p",[t._v("在使用 Elasticsearch 进行时间序列分析时，通常会有许多数字字段，您经常会对这些字段进行聚合，但是不会对其进行过滤。在这种情况下，你可以禁用这些字段的索引，以节省磁盘空间，也许还可以获得一些索引速度:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('PUT my-index-000001\n{\n  "mappings": {\n    "dynamic_templates": [\n      {\n        "unindexed_longs": {\n          "match_mapping_type": "long",\n          "mapping": {\n            "type": "long",\n            "index": false\n          }\n        }\n      },\n      {\n        "unindexed_doubles": {\n          "match_mapping_type": "double",\n          "mapping": {\n            "type": "float", \n            "index": false\n          }\n        }\n      }\n    ]\n  }\n}\n')])])]),a("ul",[a("li",[t._v("与默认的动态映射规则一样，双精度打印被映射为浮点数，这通常足够精确，但需要一半的磁盘空间。")])])])}),[],!1,null,null,null);n.default=s.exports}}]);