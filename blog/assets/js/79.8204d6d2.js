(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{1015:function(t,s,a){t.exports=a.p+"assets/img/2021-04-22-21-12-32.8ca068e2.png"},1276:function(t,s,a){"use strict";a.r(s);var e=a(19),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"核心技术-探针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心技术-探针"}},[t._v("#")]),t._v(" 核心技术-探针")]),t._v(" "),e("h2",{attrs:{id:"探针类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#探针类型"}},[t._v("#")]),t._v(" 探针类型")]),t._v(" "),e("p",[t._v("K8s 中存在两种类型的探针：liveness probe 和 readiness probe。")]),t._v(" "),e("h2",{attrs:{id:"liveness-probe-存活探针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#liveness-probe-存活探针"}},[t._v("#")]),t._v(" liveness probe（存活探针）")]),t._v(" "),e("p",[t._v("用于判断容器是否存活，即 Pod 是否为 running 状态，如果 LivenessProbe 探针探测到容器不健康，则 kubelet 将 kill 掉容器，并根据容器的重启策略是否重启。如果一个容器不包含 LivenessProbe 探针，则 Kubelet 认为容器的 LivenessProbe 探针的返回值永远成功。有时应用程序可能因为某些原因（后端服务故障等）导致暂时无法对外提供服务，但应用软件没有终止，导致 K8S 无法隔离有故障的 pod，调用者可能会访问到有故障的 pod，导致业务不稳定。K8S 提供 livenessProbe 来检测应用程序是否正常运行，并且对相应状况进行相应的补救措施。")]),t._v(" "),e("h2",{attrs:{id:"readiness-probe-就绪探针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#readiness-probe-就绪探针"}},[t._v("#")]),t._v(" readiness probe（就绪探针）")]),t._v(" "),e("p",[t._v("用于判断容器是否启动完成，即容器的 Ready 是否为 True，可以接收请求，如果ReadinessProbe 探测失败，则容器的 Ready 将为 False，控制器将此 Pod 的 Endpoint 从对应的 service 的 Endpoint 列表中移除，从此不再将任何请求调度此 Pod 上，直到下次探测成功。通过使用 Readiness 探针，Kubernetes 能够等待应用程序完全启动，然后才允许服务将流量发送到新副本。")]),t._v(" "),e("p",[t._v("比如使用 tomcat 的应用程序来说，并不是简单地说 tomcat 启动成功就可以对外提供服务的，还需要等待 spring 容器初始化，数据库连接没连上等等。对于 spring boot 应用，默认的 actuator 带有/health 接口，可以用来进行启动成功的判断。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(1015),alt:""}})]),t._v(" "),e("h2",{attrs:{id:"每类探针都支持三种探测方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#每类探针都支持三种探测方法"}},[t._v("#")]),t._v(" 每类探针都支持三种探测方法：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("exec：通过执行命令来检查服务是否正常，针对复杂检测或无 HTTP 接口的服务，命令返回值为 0 则表示容器健康。")])]),t._v(" "),e("li",[e("p",[t._v("httpGet：通过发送 http 请求检查服务是否正常，返回 200-399 状态码则表明容器健康。")])]),t._v(" "),e("li",[e("p",[t._v("tcpSocket：通过容器的 IP 和 Port 执行 TCP 检查，如果能够建立 TCP 连接，则表明容器健康。")])])]),t._v(" "),e("h2",{attrs:{id:"探针探测的结果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#探针探测的结果"}},[t._v("#")]),t._v(" 探针探测的结果")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Success：Container 通过了检查。")])]),t._v(" "),e("li",[e("p",[t._v("Failure：Container 未通过检查。")])]),t._v(" "),e("li",[e("p",[t._v("Unknown：未能执行检查，因此不采取任何措施。")])])]),t._v(" "),e("h2",{attrs:{id:"pod-重启策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pod-重启策略"}},[t._v("#")]),t._v(" Pod 重启策略：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Always: 总是重启")])]),t._v(" "),e("li",[e("p",[t._v("OnFailure: 如果失败就重启")])]),t._v(" "),e("li",[e("p",[t._v("Never: 永远不重启")])])]),t._v(" "),e("h2",{attrs:{id:"示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),e("div",{staticClass:"language-yaml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-yaml"}},[e("code",[e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("apiVersion")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" v1\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("kind")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Pod\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("metadata")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" goproxy\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("labels")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("app")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" goproxy\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spec")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containers")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("name")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" goproxy\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("image")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" k8s.gcr.io/goproxy"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("ports")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("containerPort")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8080")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("readinessProbe")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("tcpSocket")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("port")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8080")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initialDelaySeconds")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("periodSeconds")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("livenessProbe")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("tcpSocket")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("port")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8080")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initialDelaySeconds")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("periodSeconds")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v("\n\n")])])]),e("p",[t._v("探针(Probe)有许多可选字段，可以用来更加精确的控制 Liveness 和 Readiness 两种探针的行为。这些参数包括：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("initialDelaySeconds：容器启动后第一次执行探测是需要等待多少秒。")])]),t._v(" "),e("li",[e("p",[t._v("periodSeconds：执行探测的频率。默认是 10 秒，最小 1 秒。")])]),t._v(" "),e("li",[e("p",[t._v("timeoutSeconds：探测超时时间。默认 1 秒，最小 1 秒。")])]),t._v(" "),e("li",[e("p",[t._v("successThreshold：探测失败后，最少连续探测成功多少次才被认定为成功。默认是 1。对于 liveness 必须是 1。最小值是 1。")])]),t._v(" "),e("li",[e("p",[t._v("failureThreshold：探测成功后，最少连续探测失败多少次才被认定为失败。默认是 3。最小值是 1。")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);