(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{1039:function(t,e,a){t.exports=a.p+"assets/img/2021-04-18-12-45-12.77876861.png"},1040:function(t,e,a){t.exports=a.p+"assets/img/2021-04-18-12-47-08.e9511649.png"},1280:function(t,e,a){"use strict";a.r(e);var r=a(19),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),r("h2",{attrs:{id:"kubernetes-基本介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-基本介绍"}},[t._v("#")]),t._v(" kubernetes 基本介绍")]),t._v(" "),r("p",[t._v('kubernetes，简称 K8s，是用 8 代替 8 个字符"ubernete"而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）, Kubernetes 提供了应用部署，规划，更新，维护的一种机制。')]),t._v(" "),r("p",[t._v("传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。")]),t._v(" "),r("p",[t._v("新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。")]),t._v(" "),r("p",[t._v('容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在 build 或 release 的阶段，为应用创建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚拟机轻量、更"透明"，这更便于监控和管理。Kubernetes 是 Google 开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。')]),t._v(" "),r("p",[t._v("在 Kubernetes 中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。")]),t._v(" "),r("h2",{attrs:{id:"kubernetes-功能和架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-功能和架构"}},[t._v("#")]),t._v(" kubernetes 功能和架构")]),t._v(" "),r("h3",{attrs:{id:"概述-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),r("p",[t._v("Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes 能够进行应用的自动化部署和扩缩容。在 Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。Kubernetes 积累了作为 Google 生产环境运行工作负载十几年的经验，并吸收了来自于社区的最佳想法和实践。")]),t._v(" "),r("h3",{attrs:{id:"k8s-功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#k8s-功能"}},[t._v("#")]),t._v(" K8s 功能")]),t._v(" "),r("h4",{attrs:{id:"自动装箱"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自动装箱"}},[t._v("#")]),t._v(" 自动装箱")]),t._v(" "),r("ul",[r("li",[t._v("基于容器对应用运行环境的资源配置要求自动部署应用容器")])]),t._v(" "),r("h4",{attrs:{id:"自我修复-自愈能力"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自我修复-自愈能力"}},[t._v("#")]),t._v(" 自我修复(自愈能力)")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("当容器失败时，会对容器进行重启")])]),t._v(" "),r("li",[r("p",[t._v("当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度")])]),t._v(" "),r("li",[r("p",[t._v("当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务")])])]),t._v(" "),r("h4",{attrs:{id:"水平扩展"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#水平扩展"}},[t._v("#")]),t._v(" 水平扩展")]),t._v(" "),r("p",[t._v("通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大")]),t._v(" "),r("p",[t._v("或规模剪裁")]),t._v(" "),r("h4",{attrs:{id:"服务发现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务发现"}},[t._v("#")]),t._v(" 服务发现")]),t._v(" "),r("ul",[r("li",[t._v("用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡")])]),t._v(" "),r("h4",{attrs:{id:"滚动更新"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#滚动更新"}},[t._v("#")]),t._v(" 滚动更新")]),t._v(" "),r("ul",[r("li",[t._v("可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新")])]),t._v(" "),r("h4",{attrs:{id:"版本回退"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#版本回退"}},[t._v("#")]),t._v(" 版本回退")]),t._v(" "),r("ul",[r("li",[t._v("可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退")])]),t._v(" "),r("h4",{attrs:{id:"密钥和配置管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#密钥和配置管理"}},[t._v("#")]),t._v(" 密钥和配置管理")]),t._v(" "),r("p",[t._v("在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。")]),t._v(" "),r("h4",{attrs:{id:"存储编排"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存储编排"}},[t._v("#")]),t._v(" 存储编排")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要")])]),t._v(" "),r("li",[r("p",[t._v("存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务")])])]),t._v(" "),r("h4",{attrs:{id:"批处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#批处理"}},[t._v("#")]),t._v(" 批处理")]),t._v(" "),r("ul",[r("li",[t._v("提供一次性任务，定时任务；满足批量数据处理和分析的场景")])]),t._v(" "),r("h3",{attrs:{id:"应用部署架构分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#应用部署架构分类"}},[t._v("#")]),t._v(" 应用部署架构分类")]),t._v(" "),r("h4",{attrs:{id:"无中心节点架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#无中心节点架构"}},[t._v("#")]),t._v(" 无中心节点架构")]),t._v(" "),r("p",[t._v("GlusterFS")]),t._v(" "),r("h4",{attrs:{id:"有中心节点架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有中心节点架构"}},[t._v("#")]),t._v(" 有中心节点架构")]),t._v(" "),r("p",[t._v("HDFS")]),t._v(" "),r("p",[t._v("K8S")]),t._v(" "),r("h3",{attrs:{id:"k8s-集群架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#k8s-集群架构"}},[t._v("#")]),t._v(" k8s 集群架构")]),t._v(" "),r("p",[r("img",{attrs:{src:a(1039),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"k8s-集群架构节点角色功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#k8s-集群架构节点角色功能"}},[t._v("#")]),t._v(" k8s 集群架构节点角色功能")]),t._v(" "),r("h4",{attrs:{id:"master-node"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#master-node"}},[t._v("#")]),t._v(" Master Node")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("k8s 集群控制节点，对集群进行调度管理，接受集群外用户去集群操作请求；、")])]),t._v(" "),r("li",[r("p",[t._v("Master Node 由 API Server、Scheduler、ClusterState Store（ETCD 数据库）和Controller MangerServer 所组成")])])]),t._v(" "),r("h4",{attrs:{id:"worker-node"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#worker-node"}},[t._v("#")]),t._v(" Worker Node")]),t._v(" "),r("ul",[r("li",[t._v("集群工作节点，运行用户业务应用容器；")]),t._v(" "),r("li",[t._v("Worker Node 包含 kubelet、kube proxy 和 ContainerRuntime；")])]),t._v(" "),r("p",[r("img",{attrs:{src:a(1040),alt:""}})])])}),[],!1,null,null,null);e.default=s.exports}}]);