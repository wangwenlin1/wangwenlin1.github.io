(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{1017:function(e,s,n){e.exports=n.p+"assets/img/2020-12-02-17-40-48.88c1485d.png"},1018:function(e,s,n){e.exports=n.p+"assets/img/2020-12-02-17-41-37.786b06e8.png"},1019:function(e,s,n){e.exports=n.p+"assets/img/2020-12-02-17-43-04.882acacb.png"},1267:function(e,s,n){"use strict";n.r(s);var v=n(19),_=Object(v.a)({},(function(){var e=this,s=e.$createElement,v=e._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"redis有多快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis有多快"}},[e._v("#")]),e._v(" Redis有多快?")]),e._v(" "),v("blockquote",[v("p",[e._v("Redis 自带了一个叫 redis-benchmark 的工具来模拟 N 个客户端同时发出 M 个请求。（类似于 Apache ab 程序）。你可以使用 redis-benchmark -h 来查看基准参数。")])]),e._v(" "),v("p",[e._v("以下参数被支持：")]),e._v(" "),v("blockquote",[v("p",[e._v("Usage: redis-benchmark [-h <host>] [-p <port>] [-c <clients>] [-n <requests]> [-k <boolean>]")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v(" -h \\<hostname>      Server hostname (default 127.0.0.1)\n -p \\<port>          Server port (default 6379)\n -s \\<socket>        Server socket (overrides host and port)\n -a \\<password>      Password for Redis Auth\n -c \\<clients>       Number of parallel connections (default 50)\n -n \\<requests>      Total number of requests (default 100000)\n -d \\<size>          Data size of SET/GET value in bytes (default 2)\n -dbnum \\<db>        SELECT the specified db number (default 0)\n -k \\<boolean>       1=keep alive 0=reconnect (default 1)\n -r \\<keyspacelen>   Use random keys for SET/GET/INCR, random values for SADD\n  Using this option the benchmark will expand the string __rand_int__\n  inside an argument with a 12 digits number in the specified range\n  from 0 to keyspacelen-1. The substitution changes every time a command\n  is executed. Default tests use this to hit random keys in the\n  specified range.\n -P \\<numreq>        Pipeline \\<numreq> requests. Default 1 (no pipeline).\n -q                 Quiet. Just show query/sec values\n --csv              Output in CSV format\n -l                 Loop. Run the tests forever\n -t \\<tests>         Only run the comma separated list of tests. The test\n                    names are the same as the ones produced as output.\n -I                 Idle mode. Just open N idle connections and wait.\n")])])]),v("blockquote",[v("p",[e._v("你需要在基准测试之前启动一个 Redis 实例。")])]),e._v(" "),v("p",[e._v("一般这样启动测试：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("redis-benchmark -q -n 100000\n")])])]),v("p",[e._v("这个工具使用起来非常方便，同时你可以使用自己的基准测试工具， 不过开始基准测试时候，我们需要注意一些细节。")]),e._v(" "),v("h2",{attrs:{id:"只运行一些测试用例的子集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#只运行一些测试用例的子集"}},[e._v("#")]),e._v(" 只运行一些测试用例的子集")]),e._v(" "),v("p",[e._v("你不必每次都运行 "),v("code",[e._v("redis-benchmark")]),e._v(" 默认的所有测试。 使用 "),v("code",[e._v("-t")]),e._v(" 参数可以选择你需要运行的测试用例，比如下面的范例：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("$ redis-benchmark -t set,lpush -n 100000 -q\nSET: 74239.05 requests per second\nLPUSH: 79239.30 requests per second\n")])])]),v("p",[e._v("在上面的测试中，我们只运行了 "),v("code",[e._v("SET")]),e._v(" 和 "),v("code",[e._v("LPUSH")]),e._v(" 命令， 并且运行在安静模式中（使用 "),v("code",[e._v("-q")]),e._v(" 参数）。 也可以直接指定命令来直接运行，比如下面的范例：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("$ redis-benchmark -n 100000 -q script load \"redis.call('set','foo','bar')\"\nscript load redis.call('set','foo','bar'): 69881.20 requests per second\n")])])]),v("p",[e._v("选择测试键的范围大小"),v("br"),e._v("\n默认情况下面，基准测试使用单一的 "),v("code",[e._v("key")]),e._v("。在一个基于内存的数据库里， 单一 "),v("code",[e._v("key")]),e._v(" 测试和真实情况下面不会有巨大变化。当然，使用一个大的 "),v("code",[e._v("key")]),e._v(" 范围空间， 可以模拟现实情况下面的缓存不命中情况。")]),e._v(" "),v("p",[e._v("这时候我们可以使用 "),v("code",[e._v("-r")]),e._v(" 命令。比如，假设我们想设置 10 万随机 "),v("code",[e._v("key")]),e._v(" 连续 "),v("code",[e._v("SET")]),e._v(" 100 万次，我们可以使用下列的命令：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("$ redis-cli flushall\nOK\n\n$ redis-benchmark -t set -r 100000 -n 1000000\n====== SET ======\n  1000000 requests completed in 13.86 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n99.76% `\\<=` 1 milliseconds\n99.98% `\\<=` 2 milliseconds\n100.00% `\\<=` 3 milliseconds\n100.00% `\\<=` 3 milliseconds\n72144.87 requests per second\n\n$ redis-cli dbsize\n(integer) 99993\n")])])]),v("h2",{attrs:{id:"使用-pipelining"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用-pipelining"}},[e._v("#")]),e._v(" 使用 "),v("code",[e._v("pipelining")])]),e._v(" "),v("p",[e._v("默认情况下，每个客户端都是在一个请求完成之后才发送下一个请求 （benchmark 会模拟 "),v("code",[e._v("50")]),e._v(" 个客户端除非使用 "),v("code",[e._v("-c")]),e._v(" 指定特别的数量）， 这意味着服务器几乎是按顺序读取每个客户端的命令。Also RTT is payed as well.")]),e._v(" "),v("p",[e._v("真实世界会更复杂，Redis 支持 "),v("code",[e._v("/topics/pipelining")]),e._v("，使得可以一次性执行多条命令成为可能。 "),v("code",[e._v("Redis pipelining")]),e._v(" 可以提高服务器的 "),v("code",[e._v("TPS")]),e._v("。 下面这个案例是在 Macbook air 11” 上使用 "),v("code",[e._v("pipelining")]),e._v(" 组织 "),v("code",[e._v("16")]),e._v(" 条命令的测试范例：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("$ redis-benchmark -n 1000000 -t set,get -P 16 -q\nSET: 403063.28 requests per second\nGET: 508388.41 requests per second\n")])])]),v("p",[e._v("记得在多条命令需要处理时候使用 "),v("code",[e._v("pipelining。")])]),e._v(" "),v("h2",{attrs:{id:"陷阱和错误的认识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#陷阱和错误的认识"}},[e._v("#")]),e._v(" 陷阱和错误的认识")]),e._v(" "),v("p",[e._v("第一点是显而易见的：基准测试的黄金准则是使用相同的标准。 用相同的任务量测试不同版本的 Redis，或者用相同的参数测试测试不同版本 Redis。 如果把 Redis 和其他工具测试，那就需要小心功能细节差异。")]),e._v(" "),v("p",[v("code",[e._v("Redis")]),e._v(" 是一个服务器：所有的命令都包含网络或 IPC 消耗。这意味着和它和 "),v("code",[e._v("SQLite")]),e._v("， "),v("code",[e._v("Berkeley DB")]),e._v("， "),v("code",[e._v("Tokyo/Kyoto Cabinet")]),e._v(" 等比较起来无意义， 因为大部分的消耗都在网络协议上面。"),v("br"),e._v(" "),v("code",[e._v("Redis")]),e._v(" 的大部分常用命令都有确认返回。有些数据存储系统则没有（比如 "),v("code",[e._v("MongoDB")]),e._v(" 的写操作没有返回确认）。把 "),v("code",[e._v("Redis")]),e._v(" 和其他单向调用命令存储系统比较意义不大。"),v("br"),e._v("\n简单的循环操作 "),v("code",[e._v("Redis")]),e._v(" 其实不是对 "),v("code",[e._v("Redis")]),e._v(" 进行基准测试，而是测试你的网络（或者 "),v("code",[e._v("IPC")]),e._v("）延迟。想要真正测试 Redis，需要使用多个连接（比如 "),v("code",[e._v("redis-benchmark")]),e._v(")， 或者使用 "),v("code",[e._v("pipelining")]),e._v(" 来聚合多个命令，另外还可以采用多线程或多进程。"),v("br"),e._v(" "),v("code",[e._v("Redis")]),e._v(" 是一个内存数据库，同时提供一些可选的持久化功能。 如果你想和一个持久化服务器（"),v("code",[e._v("MySQL")]),e._v(", "),v("code",[e._v("PostgreSQL")]),e._v(" 等等） 对比的话， 那你需要考虑启用 "),v("code",[e._v("AOF")]),e._v(" 和适当的 "),v("code",[e._v("fsync")]),e._v(" 策略。"),v("br"),e._v(" "),v("code",[e._v("Redis")]),e._v(" 是单线程服务。它并没有设计为多 "),v("code",[e._v("CPU")]),e._v(" 进行优化。如果想要从多核获取好处， 那就考虑启用多个实例吧。将单实例 "),v("code",[e._v("Redis")]),e._v(" 和多线程数据库对比是不公平的。"),v("br"),e._v("\n一个普遍的误解是 "),v("code",[e._v("redis-benchmark")]),e._v(" 特意让基准测试看起来更好， 所表现出来的数据像是人造的，而不是真实产品下面的。")]),e._v(" "),v("p",[v("code",[e._v("Redis-benchmark")]),e._v(" 程序可以简单快捷的对给定硬件条件下面的机器计算出性能参数。 但是，通常情况下面这并不是 Redis 服务器可以达到的最大吞吐量。 事实上，使用 "),v("code",[e._v("pipelining")]),e._v(" 和更快的客户端（ "),v("code",[e._v("hiredis")]),e._v("）可以达到更大的吞吐量。 "),v("code",[e._v("redis-benchmark")]),e._v(" 默认情况下面仅仅使用并发来提高吞吐量（创建多条连接）。 它并没有使用 pipelining 或者其他并行技术（仅仅多条连接，而不是多线程）。")]),e._v(" "),v("p",[e._v("如果想使用 "),v("code",[e._v("pipelining")]),e._v(" 模式来进行基准测试（了达到更高吞吐量），可以使用 "),v("code",[e._v("-P")]),e._v(" 参数。这种方案的确可以提高性能，有很多使用 Redis 的应用在生产环境中这样做。")]),e._v(" "),v("p",[e._v("最后，基准测试需要使用相同的操作和数据来对比，如果这些不一样， 那么基准测试是无意义的。")]),e._v(" "),v("p",[e._v("比如，"),v("code",[e._v("Redis")]),e._v(" 和 "),v("code",[e._v("memcached")]),e._v(" 可以在单线程模式下面对比 "),v("code",[e._v("GET/SET")]),e._v(" 操作。 两者都是内存数据库，协议也基本相同，甚至把多个请求合并为一条请求的方式也类似 （"),v("code",[e._v("pipelining")]),e._v("）。在使用相同数量的连接后，这个对比是很有意义的。")]),e._v(" "),v("p",[e._v("下面这个很不错例子是在 Redis（"),v("code",[e._v("antirez")]),e._v("）和 memcached（"),v("code",[e._v("dormando")]),e._v("）测试的。")]),e._v(" "),v("p",[v("a",{attrs:{href:"http://antirez.com/post/redis-memcached-benchmark.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("antirez 1 - On Redis, Memcached, Speed, Benchmarks and The Toilet"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"http://dormando.livejournal.com/525147.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("dormando - Redis VS Memcached (slightly better bench)"),v("br"),e._v(" "),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"http://antirez.com/post/update-on-memcached-redis-benchmark.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("antirez 2 - An update on the Memcached/Redis benchmark"),v("OutboundLink")],1)]),e._v(" "),v("p",[e._v("你可以发现相同条件下面最终结果是两者差别不大。请注意最终测试时候， 两者都经过了充分优化。")]),e._v(" "),v("p",[e._v("最后，当特别高性能的服务器在基准测试时候（比如 "),v("code",[e._v("Redis")]),e._v("、"),v("code",[e._v("memcached")]),e._v(" 这类）， 很难让服务器性能充分发挥，通常情况下，客户端回事瓶颈限制而不是服务器端。 在这种情况下面，客户端（比如 "),v("code",[e._v("benchmark")]),e._v(" 程序自身）需要优化，或者使用多实例， 从而能达到最大的吞吐量。")]),e._v(" "),v("h2",{attrs:{id:"影响-redis-性能的因素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#影响-redis-性能的因素"}},[e._v("#")]),e._v(" 影响 Redis 性能的因素")]),e._v(" "),v("p",[e._v("有几个因素直接决定 "),v("code",[e._v("Redis")]),e._v(" 的性能。它们能够改变基准测试的结果， 所以我们必须注意到它们。一般情况下，"),v("code",[e._v("Redis")]),e._v(" 默认参数已经可以提供足够的性能， 不需要调优。")]),e._v(" "),v("p",[e._v("网络带宽和延迟通常是最大短板。建议在基准测试之前使用 "),v("code",[e._v("ping")]),e._v(" 来检查服务端到客户端的延迟。根据带宽，可以计算出最大吞吐量。 比如将 "),v("code",[e._v("4 KB")]),e._v(" 的字符串塞入 Redis，吞吐量是 "),v("code",[e._v("100000 q/s")]),e._v("，那么实际需要 "),v("code",[e._v("3.2 Gbits/s")]),e._v(" 的带宽，所以需要 "),v("code",[e._v("10 GBits/s")]),e._v(" 网络连接， "),v("code",[e._v("1 Gbits/s")]),e._v(" 是不够的。 在很多线上服务中，"),v("code",[e._v("Redis")]),e._v(" 吞吐会先被网络带宽限制住，而不是 "),v("code",[e._v("CPU")]),e._v("。 为了达到高吞吐量突破 "),v("code",[e._v("TCP/IP")]),e._v(" 限制，最后采用 "),v("code",[e._v("10 Gbits/s")]),e._v(" 的网卡， 或者多个 "),v("code",[e._v("1 Gbits/s")]),e._v(" 网卡。"),v("br"),e._v(" "),v("code",[e._v("CPU")]),e._v(" 是另外一个重要的影响因素，由于是单线程模型，"),v("code",[e._v("Redis")]),e._v(" 更喜欢大缓存快速 "),v("code",[e._v("CPU")]),e._v("， 而不是多核。这种场景下面，比较推荐 "),v("code",[e._v("Intel CPU")]),e._v("。"),v("code",[e._v("AMD CPU")]),e._v(" 可能只有 "),v("code",[e._v("Intel CPU")]),e._v(" 的一半性能（通过对 "),v("code",[e._v("Nehalem EP/Westmere EP/Sandy")]),e._v(" 平台的对比）。 当其他条件相当时候，"),v("code",[e._v("CPU")]),e._v(" 就成了 "),v("code",[e._v("redis-benchmark")]),e._v(" 的限制因素。"),v("br"),e._v("\n在小对象存取时候，内存速度和带宽看上去不是很重要，但是对大对象（"),v("code",[e._v("> 10 KB")]),e._v("）， 它就变得重要起来。不过通常情况下面，倒不至于为了优化 "),v("code",[e._v("Redis")]),e._v(" 而购买更高性能的内存模块。"),v("br"),e._v(" "),v("code",[e._v("Redis")]),e._v(" 在 "),v("code",[e._v("VM")]),e._v(" 上会变慢。虚拟化对普通操作会有额外的消耗，"),v("code",[e._v("Redis")]),e._v(" 对系统调用和网络终端不会有太多的 "),v("code",[e._v("overhead")]),e._v("。建议把 "),v("code",[e._v("Redis")]),e._v(" 运行在物理机器上， 特别是当你很在意延迟时候。在最先进的虚拟化设备（"),v("code",[e._v("VMWare")]),e._v("）上面，"),v("code",[e._v("redis-benchmark")]),e._v(" 的测试结果比物理机器上慢了一倍，很多 "),v("code",[e._v("CPU")]),e._v(" 时间被消费在系统调用和中断上面。"),v("br"),e._v("\n如果服务器和客户端都运行在同一个机器上面，那么 "),v("code",[e._v("TCP/IP loopback")]),e._v(" 和 "),v("code",[e._v("unix domain sockets")]),e._v(" 都可以使用。对 "),v("code",[e._v("Linux")]),e._v(" 来说，使用 "),v("code",[e._v("unix socket")]),e._v(" 可以比 "),v("code",[e._v("TCP/IP loopback")]),e._v(" 快 "),v("code",[e._v("50%")]),e._v("。 默认 "),v("code",[e._v("redis-benchmark")]),e._v(" 是使用 "),v("code",[e._v("TCP/IP loopback")]),e._v("。 当大量使用 "),v("code",[e._v("pipelining")]),e._v(" 时候，"),v("code",[e._v("unix domain sockets")]),e._v(" 的优势就不那么明显了。"),v("br"),e._v("\n当大量使用 "),v("code",[e._v("pipelining")]),e._v(" 时候，"),v("code",[e._v("unix domain sockets")]),e._v(" 的优势就不那么明显了。"),v("br"),e._v("\n当使用网络连接时，并且以太网网数据包在 "),v("code",[e._v("1500 bytes")]),e._v(" 以下时， 将多条命令包装成 "),v("code",[e._v("pipelining")]),e._v(" 可以大大提高效率。事实上，处理 "),v("code",[e._v("10 bytes")]),e._v("，"),v("code",[e._v("100 bytes")]),e._v("， "),v("code",[e._v("1000 bytes")]),e._v(" 的请求时候，吞吐量是差不多的，详细可以见下图。"),v("br"),e._v(" "),v("img",{attrs:{src:n(1017),alt:""}})]),e._v(" "),v("p",[e._v("在多核 "),v("code",[e._v("CPU")]),e._v(" 服务器上面，"),v("code",[e._v("Redis")]),e._v(" 的性能还依赖 "),v("code",[e._v("NUMA")]),e._v(" 配置和 处理器绑定位置。 最明显的影响是 "),v("code",[e._v("redis-benchmark")]),e._v(" 会随机使用 "),v("code",[e._v("CPU")]),e._v(" 内核。为了获得精准的结果， 需要使用固定处理器工具（在 "),v("code",[e._v("Linux")]),e._v(" 上可以使用 "),v("code",[e._v("taskset")]),e._v(" 或 "),v("code",[e._v("numactl")]),e._v("）。 最有效的办法是将客户端和服务端分离到两个不同的 "),v("code",[e._v("CPU")]),e._v(" 来高校使用三级缓存。 这里有一些使用 "),v("code",[e._v("4 KB")]),e._v(" 数据 "),v("code",[e._v("SET")]),e._v(" 的基准测试，针对三种 "),v("code",[e._v("CPU")]),e._v("（"),v("code",[e._v("AMD Istanbul, Intel Nehalem EX")]),e._v("， 和 "),v("code",[e._v("Intel Westmere")]),e._v("）使用不同的配置。请注意， 这不是针对 "),v("code",[e._v("CPU")]),e._v(" 的测试。"),v("br"),e._v(" "),v("img",{attrs:{src:n(1018),alt:""}})]),e._v(" "),v("p",[e._v("在高配置下面，客户端的连接数也是一个重要的因素。得益于 "),v("code",[e._v("epoll/kqueue")]),e._v("， "),v("code",[e._v("Redis")]),e._v(" 的事件循环具有相当可扩展性。"),v("code",[e._v("Redis")]),e._v(" 已经在超过 "),v("code",[e._v("60000")]),e._v(" 连接下面基准测试过， 仍然可以维持 "),v("code",[e._v("50000 q/s")]),e._v("。一条经验法则是，"),v("code",[e._v("30000")]),e._v(" 的连接数只有 "),v("code",[e._v("100")]),e._v(" 连接的一半吞吐量。 下面有一个关于连接数和吞吐量的测试。"),v("br"),e._v(" "),v("img",{attrs:{src:n(1019),alt:""}})]),e._v(" "),v("p",[e._v("在高配置下面，可以通过调优 "),v("code",[e._v("NIC")]),e._v(" 来获得更高性能。最高性能在绑定 "),v("code",[e._v("Rx/Tx")]),e._v(" 队列和 "),v("code",[e._v("CPU")]),e._v(" 内核下面才能达到，还需要开启 "),v("code",[e._v("RPS")]),e._v("（网卡中断负载均衡）。更多信息可以在 "),v("code",[e._v("thread")]),e._v(" 。"),v("code",[e._v("Jumbo frames")]),e._v(" 还可以在大对象使用时候获得更高性能。")]),e._v(" "),v("p",[e._v("在不同平台下面，"),v("code",[e._v("Redis")]),e._v(" 可以被编译成不同的内存分配方式（"),v("code",[e._v("libc malloc")]),e._v(", "),v("code",[e._v("jemalloc")]),e._v(", "),v("code",[e._v("tcmalloc")]),e._v("），他们在不同速度、连续和非连续片段下会有不一样的表现。 如果你不是自己编译的 Redis，可以使用 "),v("code",[e._v("INFO")]),e._v(" 命令来检查内存分配方式。 请注意，大部分基准测试不会长时间运行来感知不同分配模式下面的差异， 只能通过生产环境下面的 "),v("code",[e._v("Redis")]),e._v(" 实例来查看。")]),e._v(" "),v("h3",{attrs:{id:"其他需要注意的点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他需要注意的点"}},[e._v("#")]),e._v(" 其他需要注意的点")]),e._v(" "),v("p",[e._v("任何基准测试的一个重要目标是获得可重现的结果，这样才能将此和其他测试进行对比。")]),e._v(" "),v("p",[e._v("一个好的实践是尽可能在隔离的硬件上面测试。如果没法实现，那就需要检测 "),v("code",[e._v("benchmark")]),e._v(" 没有受其他服务器活动影响。"),v("br"),e._v("\n有些配置（桌面环境和笔记本，有些服务器也会）会使用可变的 "),v("code",[e._v("CPU")]),e._v(" 分配策略。 这种策略可以在 OS 层面配置。有些 "),v("code",[e._v("CPU")]),e._v(" 型号相对其他能更好的调整 "),v("code",[e._v("CPU")]),e._v(" 负载。 为了达到可重现的测试结果，最好在做基准测试时候设定 "),v("code",[e._v("CPU")]),e._v(" 到最高使用限制。"),v("br"),e._v("\n一个重要因素是配置尽可能大内存，千万不要使用 "),v("code",[e._v("SWAP")]),e._v("。注意 "),v("code",[e._v("32 位")]),e._v("和 "),v("code",[e._v("64 位")]),e._v(" Redis 有不同的内存限制。"),v("br"),e._v("\n如果你计划在基准测试时候使用 "),v("code",[e._v("RDB")]),e._v(" 或 "),v("code",[e._v("AOF")]),e._v("，请注意不要让系统同时有其他 "),v("code",[e._v("I/O")]),e._v(" 操作。 避免将 "),v("code",[e._v("RDB")]),e._v(" 或 "),v("code",[e._v("AOF")]),e._v(" 文件放到 "),v("code",[e._v("NAS")]),e._v(" 或 "),v("code",[e._v("NFS")]),e._v(" 共享或其他依赖网络的存储设备上面（比如 "),v("code",[e._v("Amazon EC2")]),e._v(" 上 的 "),v("code",[e._v("EBS")]),e._v("）。"),v("br"),e._v("\n将 "),v("code",[e._v("Redis")]),e._v(" 日志级别设置到 "),v("code",[e._v("warning")]),e._v(" 或者 "),v("code",[e._v("notice")]),e._v("。避免将日志放到远程文件系统。"),v("br"),e._v("\n避免使用检测工具，它们会影响基准测试结果。使用 "),v("code",[e._v("INFO")]),e._v(" 来查看服务器状态没问题， 但是使用 "),v("code",[e._v("MONITOR")]),e._v(" 将大大影响测试准确度。"),v("br"),e._v("\n不同云主机和物理机器上的基准测试结果"),v("br"),e._v("\n这些测试模拟了 "),v("code",[e._v("50")]),e._v(" 客户端和 "),v("code",[e._v("200w")]),e._v(" 请求。"),v("br"),e._v("\n使用了 "),v("code",[e._v("Redis 2.6.14")]),e._v("。"),v("br"),e._v("\n使用了 "),v("code",[e._v("loopback")]),e._v(" 网卡。"),v("br"),e._v(" "),v("code",[e._v("key")]),e._v(" 的范围是 "),v("code",[e._v("100 w")]),e._v("。"),v("br"),e._v("\n同时测试了 有 "),v("code",[e._v("pipelining")]),e._v(" 和没有的情况（"),v("code",[e._v("16")]),e._v(" 条命令使用 "),v("code",[e._v("pipelining")]),e._v("）。")]),e._v(" "),v("blockquote",[v("p",[e._v("Intel(R) Xeon(R) CPU E5520 @ 2.27GHz (with pipelining)")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -P 16 -q\nSET: 552028.75 requests per second\nGET: 707463.75 requests per second\nLPUSH: 767459.75 requests per second\nLPOP: 770119.38 requests per second\nIntel(R) Xeon(R) CPU E5520 @ 2.27GHz (without pipelining)\n\n$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -q\nSET: 122556.53 requests per second\nGET: 123601.76 requests per second\nLPUSH: 136752.14 requests per second\nLPOP: 132424.03 requests per second\nLinode 2048 instance (with pipelining)\n\n$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -q -P 16\nSET: 195503.42 requests per second\nGET: 250187.64 requests per second\nLPUSH: 230547.55 requests per second\nLPOP: 250815.16 requests per second\nLinode 2048 instance (without pipelining)\n\n$ ./redis-benchmark -r 1000000 -n 2000000 -t get,set,lpush,lpop -q\nSET: 35001.75 requests per second\nGET: 37481.26 requests per second\nLPUSH: 36968.58 requests per second\nLPOP: 35186.49 requests per second\n")])])]),v("h3",{attrs:{id:"更多使用-pipeline-的测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更多使用-pipeline-的测试"}},[e._v("#")]),e._v(" 更多使用 pipeline 的测试")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("$ redis-benchmark -n 100000\n\n====== SET ======\n  100007 requests completed in 0.88 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n58.50% \\<= 0 milliseconds\n99.17% \\<= 1 milliseconds\n99.58% \\<= 2 milliseconds\n99.85% \\<= 3 milliseconds\n99.90% \\<= 6 milliseconds\n100.00% \\<= 9 milliseconds\n114293.71 requests per second\n\n====== GET ======\n  100000 requests completed in 1.23 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n43.12% \\<= 0 milliseconds\n96.82% \\<= 1 milliseconds\n98.62% \\<= 2 milliseconds\n100.00% \\<= 3 milliseconds\n81234.77 requests per second\n\n====== INCR ======\n  100018 requests completed in 1.46 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n32.32% \\<= 0 milliseconds\n96.67% \\<= 1 milliseconds\n99.14% \\<= 2 milliseconds\n99.83% \\<= 3 milliseconds\n99.88% \\<= 4 milliseconds\n99.89% \\<= 5 milliseconds\n99.96% \\<= 9 milliseconds\n100.00% \\<= 18 milliseconds\n68458.59 requests per second\n\n====== LPUSH ======\n  100004 requests completed in 1.14 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n62.27% \\<= 0 milliseconds\n99.74% \\<= 1 milliseconds\n99.85% \\<= 2 milliseconds\n99.86% \\<= 3 milliseconds\n99.89% \\<= 5 milliseconds\n99.93% \\<= 7 milliseconds\n99.96% \\<= 9 milliseconds\n100.00% \\<= 22 milliseconds\n100.00% \\<= 208 milliseconds\n88109.25 requests per second\n\n====== LPOP ======\n  100001 requests completed in 1.39 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n54.83% \\<= 0 milliseconds\n97.34% \\<= 1 milliseconds\n99.95% \\<= 2 milliseconds\n99.96% \\<= 3 milliseconds\n99.96% \\<= 4 milliseconds\n100.00% \\<= 9 milliseconds\n100.00% \\<= 208 milliseconds\n71994.96 requests per second\n\n")])])]),v("p",[e._v("注意：包大小从 "),v("code",[e._v("256")]),e._v(" 到 "),v("code",[e._v("1024")]),e._v(" 或者 "),v("code",[e._v("4096")]),e._v(" bytes 不会改变结果的量级 （但是到 "),v("code",[e._v("1024 bytes")]),e._v(" 后，"),v("code",[e._v("GETs")]),e._v(" 操作会变慢）。同样的，"),v("code",[e._v("50")]),e._v(" 到 "),v("code",[e._v("256")]),e._v(" 客户端的测试结果相同。 "),v("code",[e._v("10")]),e._v(" 个客户端时候，吞吐量会变小（译者按：总量到不了最大吞吐量）。")]),e._v(" "),v("p",[e._v("不同机器可以获的不一样的结果，下面是 "),v("code",[e._v("Intel T5500 1.66 GHz")]),e._v(" 在 "),v("code",[e._v("Linux 2.6")]),e._v(" 下面的结果：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("\n$ ./redis-benchmark -q -n 100000\nSET: 53684.38 requests per second\nGET: 45497.73 requests per second\nINCR: 39370.47 requests per second\nLPUSH: 34803.41 requests per second\nLPOP: 37367.20 requests per second\n")])])]),v("p",[e._v("另外一个是 64 位 Xeon L5420 2.5 GHz 的结果：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("$ ./redis-benchmark -q -n 100000\nPING: 111731.84 requests per second\nSET: 108114.59 requests per second\nGET: 98717.67 requests per second\nINCR: 95241.91 requests per second\nLPUSH: 104712.05 requests per second\nLPOP: 93722.59 requests per second\n")])])]),v("p",[e._v("高性能硬件下面的基准测试"),v("br"),e._v(" "),v("code",[e._v("Redis 2.4.2")]),v("br"),e._v("\n默认连接数，数据包大小 "),v("code",[e._v("256 bytes")]),e._v("。"),v("br"),e._v(" "),v("code",[e._v("Linux")]),e._v(" 是 "),v("code",[e._v("SLES10 SP3 2.6.16.60-0.54.5-smp")]),e._v("，"),v("code",[e._v("CPU")]),e._v(" 是 "),v("code",[e._v("Intel X5670 @ 2.93 GHz")]),e._v("."),v("br"),e._v("\n固定 "),v("code",[e._v("CPU")]),e._v("，但是使用不同 "),v("code",[e._v("CPU")]),e._v(" 内核。"),v("br"),e._v("\n使用 "),v("code",[e._v("unix domain socket")]),e._v("：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("$ numactl -C 6 ./redis-benchmark -q -n 100000 -s /tmp/redis.sock -d 256\nPING (inline): 200803.22 requests per second\nPING: 200803.22 requests per second\nMSET (10 keys): 78064.01 requests per second\nSET: 198412.69 requests per second\nGET: 198019.80 requests per second\nINCR: 200400.80 requests per second\nLPUSH: 200000.00 requests per second\nLPOP: 198019.80 requests per second\nSADD: 203665.98 requests per second\nSPOP: 200803.22 requests per second\nLPUSH (again, in order to bench LRANGE): 200000.00 requests per second\nLRANGE (first 100 elements): 42123.00 requests per second\nLRANGE (first 300 elements): 15015.02 requests per second\nLRANGE (first 450 elements): 10159.50 requests per second\nLRANGE (first 600 elements): 7548.31 requests per second\n使用 TCP loopback：\n\n$ numactl -C 6 ./redis-benchmark -q -n 100000 -d 256\nPING (inline): 145137.88 requests per second\nPING: 144717.80 requests per second\nMSET (10 keys): 65487.89 requests per second\nSET: 142653.36 requests per second\nGET: 142450.14 requests per second\nINCR: 143061.52 requests per second\nLPUSH: 144092.22 requests per second\nLPOP: 142247.52 requests per second\nSADD: 144717.80 requests per second\nSPOP: 143678.17 requests per second\nLPUSH (again, in order to bench LRANGE): 143061.52 requests per second\nLRANGE (first 100 elements): 29577.05 requests per second\nLRANGE (first 300 elements): 10431.88 requests per second\nLRANGE (first 450 elements): 7010.66 requests per second\nLRANGE (first 600 elements): 5296.61 requests per second\n")])])]),v("p",[e._v("原文：http://www.redis.cn/topics/benchmarks.html")])])}),[],!1,null,null,null);s.default=_.exports}}]);